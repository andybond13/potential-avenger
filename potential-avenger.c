//potential-avenger.c
//Andrew Stershic
//DCML, Duke University
//(c) 2013, 2014

#include <potential-avenger.h>
#include <limits>
#include <sys/stat.h>

using namespace std;

PotentialAvenger::PotentialAvenger(double& in0, double& in1, double& in2, unsigned& in3, double& in4, unsigned& in5, unsigned& in6, int& in7, double& in8, double& in9, unsigned& in10, unsigned& in11, unsigned& in12, string& path){
    strain_rate = in0;
    ts_refine = in1;
    end_t = in2;
    Nelt = in3;
    lc = in4;
    startWithLoad = in5;
    printVTK = in6;
    oneAtATime = in7;
    minOpenDist = in8;
	alpha = in9;
    localOnly = in10;
    visualizeCracks = in11;
    fullCompression = in12;
    _path = path + "/results";

    _numFrag = 0;    

    //make plot files
    printClean();
	plotEnergies();
    plotFrags();
    plotHisto();
    plotSTheta();

};

PotentialAvenger::~PotentialAvenger(){
// create a plot file if necessary
    std::string plotFil = _path+"/plot.sh";		//"../results/plot.sh"
    FILE * pFileP;
    pFileP = fopen( plotFil.c_str(), "w" );
    fprintf( pFileP, "#!/bin/bash\n" );
    fprintf( pFileP, "# shell script generated by <ring.h>" );
    fprintf( pFileP, " -- MH [DCML] (2010)\n\n" );
    if ( _EnrgFile.size() != 0 ) {
        std::string enrgFil = "./gnuplot/plotEnrg.plt";
        fprintf( pFileP, "gnuplot %s\n", enrgFil.c_str() );
    }
    if ( _FragFile.size() != 0 ) {
        std::string fragFil = "./gnuplot/plotFragInfo.plt";
        fprintf( pFileP, "gnuplot %s\n", fragFil.c_str() );
    }
    if ( _HistoFile.size() != 0 ) {
        std::string histoFil = "./gnuplot/plotHisto.plt";
        fprintf( pFileP, "gnuplot %s\n", histoFil.c_str() );
    }
    if ( _SThetaFile.size() != 0 ) {
        std::string sThetaFil = "./gnuplot/plotSTheta.plt";
        fprintf( pFileP, "gnuplot %s\n", sThetaFil.c_str() );
    }
    fprintf( pFileP, "\n/usr/bin/open -a \"/Applications/Google Chrome.app\" ./pngFiles/*.svg &\n" );
    fclose( pFileP );
    chmod( plotFil.c_str(), 0775 );

};

unsigned min(const vector<unsigned> in) {
    assert(in.size() > 0);
    unsigned min = in[0];
    for (unsigned i = 1; i < in.size(); ++i) {
        if (in[i] < min) min = in[1];
    }
    return min;
}

unsigned max(const vector<unsigned> in) {
    assert(in.size() > 0);
    unsigned max = in[0];
    for (unsigned i = 1; i < in.size(); ++i) {
        if (in[i] > max) max = in[1];
    }
    return max;
}

double dotProduct(const vector<double> a, const vector<double> b) {
    double sum = 0;
    assert(a.size() == b.size() );
    for (unsigned i = 0; i < a.size(); ++i) sum+= a[i]*b[i];
    return sum;
}

int median(const vector<int> in) {
    return in[(in.size()-1)/2];
}

double sum(const vector<double> in) {
    return dotProduct(in,vector<double>(in.size(),1));
}

double sum(const vector<unsigned> in) {
    unsigned result = 0;
    for (unsigned i = 0; i < in.size(); ++i) result += in[i];
    return result;
}

template <typename T> double sgn(T val) {
    return (T(0) < val) - (val < T(0));
}

double printable (double in) {
    double limit = numeric_limits<double>::epsilon();
	if (fabs(in) < limit) return 0.0;
    else return in;
}

void PotentialAvenger::run(const double& Ein, const double& rhoIn, const double& Ain, const double& Lin, const double& Ycin, const vector<double>& pg, const vector<double>& wg, const vector<double>& phiIn, const vector<Segment*> segIn, const unsigned& nucleatedIn, bool& vbc, const vector<double>& eIn, const vector<double>& xIn, vector<double>& uIn, const vector<double>& vIn, const vector<double>& YcvIn, const DamageModel& dmIn) {

    printRunInfo();

	//copy input variables
	E = Ein;
	rho = rhoIn;
	A = Ain;
	L = Lin;
	Yc = Ycin;
	dm = dmIn;
	nucleated = nucleatedIn;

    Nnod = Nelt+1;
    _Nt = 0;
    double c = sqrt(E/rho);
    h = 1/static_cast<double>(Nelt); //
    double cfl = 1./ts_refine;
    dt = cfl * h/c;//
    unsigned Ntim = static_cast<unsigned>(Nelt*ts_refine*end_t*c)+1;
    ec = sqrt(2 * Yc / E);
    sigc = E * ec;
	
	EPS = numeric_limits<double>::epsilon();
    d = vector<double>(Nelt,0);
    d_quad = vector<vector<double> >(Nelt);
    d_quad_wt = vector<vector<double> >(Nelt);
    d_1 = vector<double>(Nelt,0);
    d_max = vector<double>(Nelt,0);
    s = vector<double>(Nelt,0.0);
    energy = vector<double>(Nelt,0);
    Y = vector<double>(Nelt,0);
    Ybar = vector<double>(Nelt,0);
    Ycv = vector<double>(Nelt,Yc);
    strain_energy = 0.0;
    kinetic_energy = 0.0;
    dissip_energy = 0.0;
    dissip_energy_local = 0.0;
    dissip_energy_TLS = 0.0;
    ext_energy = 0.0;
    tot_energy = 0.0;
    vector<Fragment*> fragment_list;

    ustat = vector<double>(Nnod,0);
    Ystat = vector<double>(Nnod,0);
    u = uIn;
    v = vIn;
    a = vector<double>(Nnod,0);
    phiL = vector<double>(Nelt,0);
    phiNL = phiIn;

    phiNL_1 = vector<double>(Nnod,0);
    phidot = vector<vector<double> >(Ntim);
    gradPhiL = vector<double>(Nnod,0.0);
    gradPhiNL = vector<double>(Nnod,0.0);
    gradPhiNLelem = vector<double>(Nelt,0.0);

    vector<unsigned> nbiter = vector<unsigned>(Ntim,0);
    nfrags = vector<unsigned>(Ntim,0);
    _numFrag = 0;
    vector<Segment*> segments;
	for (unsigned j = 0; j < segIn.size(); ++j) segments.push_back(segIn.at(j));

    m.assign(Nnod,rho*h*A);
    m[0] = m[0]/2; m[Nnod-1] = m[Nnod-1]/2;

    //initialization
	Ycv = YcvIn;
	e = eIn;
	x = xIn;

    xe = vector<double>(Nnod,0);
    for (unsigned j = 0; j < Nelt; ++j) xe[j] = 0.5*(x[j] + x[j+1]);

    t = vector<double>(Ntim,0);
    for (unsigned j = 0; j < Ntim; ++j) t[j] = static_cast<double>(j)*dt;

    // Initially the bar is loaded and all elements are at Yc
    // A tls is placed on the first element, obviously it satifies
    //   Ybar = Yc
    // This extra damage will create new stress that are less than in the next element
    // and ill thus give an unloading wave.

    //constant strain rate applied

    for (unsigned j = 0; j < Nnod; ++j) {
        ustat[j] = 0.0;//x[j] * ec * L * 0.999*(1-vbc);
        if (j < Nnod-1) phiL[j] = 0.0;//(2*h-x[j])*(1-vbc)-vbc;
    }

    //check to see which elements are in TLS zones
    inTLS.assign(Nelt,0);
    inTLSnode.assign(Nnod,0);
    checkInTLS(segments,inTLS,inTLSnode);

    //calculate stresses
	for (unsigned j = 0; j < Nelt; ++j) calculateStressesL(pg,wg,j);

    if (localOnly == 0) calculateStressesNL(pg,wg,segments);
    //acceleration
    a[0] = 0;
    a[Nnod-1] = 0;
    for (unsigned j = 1; j < Nnod-1; ++j)  a[j] = A*(s[j] - s[j-1]) /m[j];

    nbiter[0] = 0;
    analyzeDamage(phiNL,h,segments);
    unsigned len = 0;
    for (unsigned l = 0; l < segments.size(); ++l) {
        if (segments[l]->size() == 0) continue;
        len++;
    }
    phidot[0].resize(len);

    //print data to file
    vector<double>fragLength = findFragments(nfrags[0],segments);
    calculateEnergies(0,pg,wg);
    if (printVTK != 0) printVtk(_Nt);
    printFrags(fragLength);
    printGlobalInfo();

    //time-integration loop
    for (unsigned i = 1; i < Ntim; ++i){
        _Nt++;
//cout << "t = " << t[i] << endl;

		Ybar.assign(Nelt,0.0);

        //Copy kinematic variables to "old"
        u_1 = vector<double>(Nnod,0); u_1 = u; u.assign(Nnod,0.0);
        vector<double> v_1 = vector<double>(Nnod,0); v_1 = v; v.assign(Nnod,0.0);
        vector<double> a_1 = vector<double>(Nnod,0); a_1 = a; a.assign(Nnod,0.0);
        d_1 = vector<double>(Nnod,0); d_1 = d; d.assign(Nnod,0.0);
        phiNL_1 = phiNL;


        //prediction
        for (unsigned j = 0; j < Nnod; ++j) {
            v[j]= v_1[j] + 0.5*dt*a_1[j];
            u[j]= u_1[j] + dt*v_1[j] + 0.5*dt*dt*a_1[j];
        }

        //def computation and Y update.
        for (unsigned j = 0; j < Nelt; ++j) {
            e[j] = (u[j+1] - u[j]) / h;
            //b=0.5*E*e(i,j)*e(i,j)-Yc;
        }

        //updating the stress and level-set fields
		//local
		for (unsigned j = 0; j < Nelt; ++j) {
			unsigned status = calculateStressesL(pg,wg,j); 
        	if (status == 1) updateLevelSetL(i,nbiter,segments,pg,wg,j);
		}
		//non-local / TLS
		if (localOnly == 0) {
        	updateLevelSetNL(i,nbiter,segments,pg,wg);
        	if (nucleated > 0) setPeakAll(phiNL,segments); 
    		analyzeDamage(phiNL,h,segments);
        	for (unsigned j = 0; j < Nnod; ++j)  phiNL[j] = max(phiNL[j], phiNL_1[j]);
        	calculateStressesNL(pg,wg,segments);
		} 
        // moving the localization front
        // we compute a = integral (Yn+1 - Yc) d' in the current non-local zone
        // then we compute b = (Yn+1-Yc) d' on the front
        // the shift in level set if the ratio of the two.


                if (alpha > 0) calculateLevelSetGradientL(d, gradPhiL);
                calculateLevelSetGradientNL(d, gradPhiNL);
        //check for nucleation
		unsigned numNuc = 0;
		unsigned nSegs = segments.size();
        if (localOnly == 0) {
	    	if (alpha == 0) {
	    		//non-local-only model
    	        vector<double> Yin;
	            for (unsigned l = 0; l < Nelt; ++l)  Yin.push_back(0.5*E*e[l]*e[l]);
    	        string elemOrNodal="elem";
            	numNuc = checkFailureCriteria(i,Ycv,elemOrNodal,Yin,false,false,1.0*h,segments, nbiter, pg, wg);//delete this 0.5*h rather than 2*h
    		} else {
		    	//local / non-local hybrid model
		    	string elemOrNodal = "nodal";
		    	vector<double> gradLimit(Nnod,1.0);
		    	numNuc = checkFailureCriteria(i,gradLimit,elemOrNodal,gradPhiL,true,true, 1.0*h, segments, nbiter, pg, wg);
		    }
        }

        //enforce phi constraints - update segments
		//if it nucleated this time-step, set YbarmYc = 0
		if (numNuc > 0) for (unsigned l = nSegs; l < segments.size(); ++l) segments.at(l)->YbarmYc = 0.0;

		if (numNuc > 0) {
    		analyzeDamage(phiNL,h,segments);
        	setPeakAll(phiNL,segments); 
        	for (unsigned j = 0; j < Nnod; ++j)  phiNL[j] = max(phiNL[j], phiNL_1[j]);
            checkInTLS(segments,inTLS,inTLSnode);
            calculateStressesNL(pg,wg,segments);
		}
        int index = -1;
        for (unsigned l = 0; l < segments.size(); ++l) {
            if (segments[l]->size() == 0) continue;
            index++;
            //median(segments[l]);
            int smid = median(segments[l]->indices);

            len = 0;
            for (unsigned j = 0; j < segments.size(); ++j) {
                if (segments[j]->size() == 0) continue;
                len++;
            }
            phidot.at(i).resize(len);
            phidot.at(i).at(index) = (phiNL[smid] - phiNL_1[smid])/dt;
            if (numNuc > 0) phidot.at(i).at(index) = min(phidot.at(i).at(index), 1.0); //"hack", but for phidot plot, I don't need to see nucleation as 100000
            if (phidot[i][index] * dt > h*1.01 ) {
                printf("level-set front advancing more than one element per time-step: t=%f, segment %u , dphi/h = %f \n",t[i],l,phidot[i][index]*dt/h);
            }
        }


        //check to see which elements are in TLS zones
        checkInTLS(segments,inTLS,inTLSnode);
       

        for (unsigned j = 1; j < Nnod-1; ++j)  phiNL[j] = max(phiNL[j], phiNL_1[j]);

		//acceleration
        if (max(phiL[0],phiNL[0]) <= lc) a[0] = 0;
        else a[0] =  A*s[0]/m[0];
        a[Nnod-1] = 0; //note: this is a constraint which was hidden. if free, it would be -s(i,Nnod)/m(j);
        for (unsigned j = 1; j < Nnod - 1; ++j) a[j] = A*(s[j] - s[j-1]) /m[j];

        //correction
        for (unsigned j = 0; j < Nnod; ++j) v[j]= v[j] + 0.5*dt*a[j];

        //record number of fragments and quantities per fragment
        fragLength.clear();
        fragLength = findFragments(nfrags[i],segments);
        _numFrag = nfrags[i];

        //calculate energies
        calculateEnergies(i,pg,wg);

        //update gradient for printing
		calculateLevelSetGradientL(d, gradPhiL);
		calculateLevelSetGradientNL(d, gradPhiNL);
/*//disabled so that the Ybar calculated is right for the segment it was calculated for (limited boundary). If enabled, this calculates Ybar after the boundary has been moved, potentially making it appear to be less than Yc at this point even with the segment growing. this was not an issue when the boundaries were updated per iteration.
		//update Ybar after segments redefined
        for (unsigned l = 0; l < segments.size(); ++l) {
            if (segments[l]->size()==0) continue;//segments.erase(segments.begin()+l);
            unsigned sbegin = segments[l]->begin();
            unsigned send = segments[l]->end();
            //clear Ybar
            segments[l]->YbarmYc = 0.0; 
			double segZero = calculateZero(segments[l],phiNL); 
            double YbarmYc = 0.0; double Ycavg = 0.0;
            double residu_Y = 0.0; double tangent_Y = 0.0;
            double phimin = 0.0;  double phimax = 0.0;
       		double phiminY = 0.0; double phimaxY = 0.0;
        	unsigned status = calculateYbar(pg,wg,Ycavg,YbarmYc,residu_Y,tangent_Y,phimin,phimax,phiminY,phimaxY,nbiter[i],sbegin,send,segments[l],segZero);
		}
*/
        //check enforcement of constraints
        checkConstraints(gradPhiL,gradPhiNL,segments);

		//print the rest of the table/graph data
        if (printVTK != 0) if ( ( _Nt % printVTK) == 0 ) {printVtk(_Nt); cout << "*t = " << t[i] << endl;}
        printFrags(fragLength);
        printGlobalInfo();

    }//end time-loop

    //find fragment length total & minimum
    cout << " fragment lengths:" << endl;
    double minfrag = _fMin; 
	double sumfrag = 0.0;
    for (unsigned i = 0; i < fragLength.size(); ++i) {
        cout << fragLength[i] << endl;
		if (minfrag > fragLength[i] ) minfrag = fragLength[i];
		sumfrag += fragLength[i];
	}
     nfrags[Ntim-1] = fragLength.size(); 

    printf("Final number of fragments: %i \nMinimum fragment length: %f    avg = %f\nFinal dissipated energy: %3.3e   = local %3.3e + TLS %3.3e  (%f/%f)\n",nfrags[Ntim-1],minfrag,sumfrag*L/static_cast<double>(nfrags[Ntim-1]),dissip_energy,dissip_energy_local,dissip_energy_TLS,dissip_energy_local/dissip_energy,dissip_energy_TLS/dissip_energy);
    double alt_dissip_energy = 0.0 + ext_energy - strain_energy - kinetic_energy; 
    printf("alt. dissipated energy: %3.3e \n",alt_dissip_energy); 
   cout << " fragment total length " << sumfrag << "     powder length = " << 2.0*L - sumfrag << endl;
    
    //print histogram
    printHisto(fragLength);

    //kill all segments and fragments
    killSegments(segments);
    killFragments(fragment_list);

	//return displacement for testing
	uIn = u;

    return;
};

void PotentialAvenger::killSegments(vector<Segment*>& seg) {
    for (unsigned i = 0; i < seg.size(); ++i) delete seg[i];
    seg.clear();
    return;
}

void PotentialAvenger::killFragments(vector<Fragment*>& frag) {
    for (unsigned i = 0; i < frag.size(); ++i) delete frag[i];
    frag.clear();
    return;
}

void PotentialAvenger::calculateLevelSetGradientL( const vector<double>& dV, vector<double>& gradientPhi) {
	//calculate the gradient of the levelset (local model). This will be used to see if the |gradPhi| > 1,
	//in which case, a non-local zone will be inserted
	assert(gradientPhi.size() == Nnod);
    assert(gradientPhi.size() > 4);
	for (unsigned i = 1; i < Nnod-1; ++i) {
		double phiM = phiL[i];
        double phiM1 = phiL[i-1];
		gradientPhi[i] = (phiM - phiM1) / h;
	}
    gradientPhi[0] = gradientPhi[1]; 
	for (unsigned i = 0; i < Nelt; ++i) if (inTLS[i]) gradientPhi[i] = 0.0; 
    return;
}

void PotentialAvenger::calculateLevelSetGradientNL( const vector<double>& dV, vector<double>& gradientPhi) {
    //calculate the gradient of the levelset (non-local model). This will be used to see if the |gradPhi| > 1,
    //in which case, a non-local zone will be inserted
    assert(gradientPhi.size() == Nnod);
    assert(gradientPhi.size() > 4);
    //gradientPhi[0] = (phiNL[1]-phiNL[0])/(h); //first-order boundary difference
    gradientPhi[0] = (-phiNL[2]+4*phiNL[1]-3*phiNL[0])/(2*h); //second-order boundary difference
    //gradientPhi[Nnod-1] = (phiNL[Nnod-1]-phiNL[Nnod-2])/(h); //first-order boundary difference
    gradientPhi[Nnod-1] = (3*phiNL[Nnod-1]-4*phiNL[Nnod-2]+phiNL[Nnod-3])/(2*h); //second-order boundary difference
    for (unsigned i = 1; i < Nnod-1; ++i) {
       double phiM = 0.5 * (phiNL[i] + phiNL[i+1]); 
       double phiM1 = 0.5* (phiNL[i] + phiNL[i-1]);
       gradientPhi[i] = (phiM - phiM1) / h;
    }

	//calculate gradient of level-set within elements of non-local zone
	for (unsigned i = 0; i < Nelt; ++i) {
		gradPhiNLelem[i] = (phiNL[i+1]-phiNL[i])/h;
	}
    return;
}

void PotentialAvenger::checkInTLS(const vector<Segment*>& segments, vector<unsigned>& elem, vector<unsigned>& nodes) {
	
	vector<unsigned> nodes_old = nodes;
	elem.assign(Nelt, 0);
	nodes.assign(Nnod,0);
    //check nodes; 1 = in TLS zone, 0 = not
    if (nucleated > 0) {
        for (unsigned index = 0; index < Nnod; ++index) {
			//compare to phiL on both sides (if possible). inTLS if phiNL > max(phiL)
			double phiLocal = 0.0;
			if (index > 0) phiLocal = max(phiLocal, phiL[index]);
			if (index < Nnod-1) phiLocal = max(phiLocal, phiL[index+1]);
			if (phiNL[index] >= phiLocal || nodes_old[index] == 1) nodes[index] = 1;
    	}
    }
//assert(elem.size() == inTLS.size() );
    //check elements based on node results
    for (unsigned k = 0; k < Nelt; ++k) {
        //if both nodes are not in TLS zones, then element is not in TLS zone; if one or both are in, then element is in
        if (nodes[k] == 0 && nodes[k+1] == 0) elem[k] = 0;
        else elem[k] = 1;
    }
    return;
}

void PotentialAvenger::checkConstraints(const vector<double>& gradientPhiL, const vector<double>& gradientPhiNL, const vector<Segment*>& segments) {

	//check gradient of level-set
	assert(gradientPhiL.size() == Nnod);
	assert(gradientPhiNL.size() == Nnod);
   
	if (localOnly == 0 && minOpenDist == 0.0 && alpha > 0) for (unsigned j = 0; j < Nnod; ++j) assert(fabs(gradientPhiL[j]) < 1.0 + Nelt*EPS);
    //if (localOnly == 0) for (unsigned j = 0; j < Nnod; ++j) assert(fabs(gradientPhiNL[j]) <= 1.0);

    //for local: check that Y <= Yc
	if (alpha > 0) {
    	for (unsigned j = 0; j < Nelt; ++j) if (inTLS[j] == 0 && d[j] < 1.0) assert( Y[j]/Ycv[j] < 1.0 + EPS*Nnod);
	}

	//for non-local: check that Ybar <= Yc
	if (minOpenDist == 0.0) {
    for (unsigned j = 0; j < segments.size(); ++j) assert( (segments[j]->YbarmYc) <= 1.e-6);
	}

	//for non-local: check that gradient of phi is 1 on all elements
	if (nucleated > 0) {
        for (unsigned l = 0; l < segments.size(); ++l) {
		double qty = (segments[l]->phipeak-segments[l]->phimin)/(segments[l]->xpeak-segments[l]->xmin);
		
/*			for (unsigned j = segments[l]->begin()+1; j < segments[l]->end()-1; ++j) {
				
				if( fabs(phiNL[j] - phiNL[j+1]) == h) {cout << " failing on segment " << l << "  element " << j << endl;} 
				assert( fabs(phiNL[j] - phiNL[j+1]) == h); 
			}
*/		}
	}

	return;
}

void PotentialAvenger::calculateStressesNL(const vector<double>& pg, const vector<double>& wg, vector<Segment*>& segments) {
    
	vector<double> dLocal = d;

    for (unsigned j = 0; j < Nelt; ++j) {

		if (inTLS[j] == 0) continue; //skip if local!
		
        d_quad[j].clear();
		d_quad_wt[j].clear();
	    s[j] = 0;
	    d[j] = 0;
   		if ((inTLS[j] == 1 && localOnly == 0) || alpha ==0.0 ) { 	//in TLS: use non-local damage model
	        assert(pg.size() == wg.size());
	
			if (inTLSnode[j]) phiNL[j] = max(phiNL[j],phiNL_1[j]);	
			if (inTLSnode[j+1]) phiNL[j+1] = max(phiNL[j+1],phiNL_1[j+1]);	
	        e[j] = (u[j+1] - u[j])/h;
  	    	vector<double> dloc(pg.size(),0.0);
			if (inTLSnode[j] == 1 && inTLSnode[j+1] == 0) {
				//element at transition: left in, right out
				double phiLocal = phiL[j+1];
				double delta = fabs(phiNL[j] - phiLocal); 
                delta = max(delta, 0.0); delta = min(delta, h);
        	    for (unsigned k = 0; k < pg.size(); ++k) {
					double philoc1 = pg[k] * phiNL[j] + (1-pg[k]) * (phiLocal);
					d_quad[j].push_back(dm.dval(philoc1));
					d_quad_wt[j].push_back(wg[k] * delta/h);
					dloc[k] = dm.dval(philoc1);
					d[j] += wg[k] * dloc[k] * delta/h;
            	    s[j] += wg[k] * (1.0-dloc[k]) * E * e[j] * delta/h;
                }
				d[j] += (h-delta)/h * dm.dval(phiLocal);
				s[j] += (h-delta)/h * (1.0-dm.dval(phiLocal)) * E * e[j];
				d_quad[j].push_back(dm.dval(phiLocal)); 
				d_quad_wt[j].push_back(1.0 * (h-delta)/h );
                

			} else if (inTLSnode[j] == 0 && inTLSnode[j+1] == 1) {
				//element at transition: left out, right in
				double phiLocal = phiL[j];
                double delta = h - fabs(phiLocal - phiNL[j+1]);
                delta = max(delta, 0.0); delta = min(delta, h);
                for (unsigned k = 0; k < pg.size(); ++k) {
                    double philoc1 = pg[k] * phiLocal + (1-pg[k]) * (phiNL[j+1]);
                    d_quad[j].push_back(dm.dval(philoc1));
                    d_quad_wt[j].push_back(wg[k] * (h-delta)/h);
                    dloc[k] = dm.dval(philoc1);
                    d[j] += wg[k] * dloc[k] * (h-delta)/h;
                    s[j] += wg[k] * (1.0-dloc[k]) * E * e[j] * (h-delta)/h;
//cout << " added 0 " << dm.dval(philoc1) << " ( " << wg[k] * delta/h << " )" <<endl;
                }   
				d[j] += delta/h * dm.dval(phiLocal);
				s[j] += delta/h * (1.0 - dm.dval(phiLocal)) * E * e[j];
                d_quad[j].push_back(dm.dval(phiLocal));
                d_quad_wt[j].push_back(1.0 * delta/h );
//cout << " added 0 " << dm.dval(phiLocal) <<  " ( " << (h-delta)/h << " ) " << endl;

    	    } else if (phiNL[j] > 0  && phiNL[j+1] > 0) {
				//both sides positive
        	    for (unsigned k = 0; k < pg.size(); ++k) {
            	    if (fabs(fabs(phiNL[j] - phiNL[j+1]) - h) > EPS) {
                	    //there's a peak/anti-peak inside!
                    	double delta = 0.5*(h - phiNL[j+1] + phiNL[j]); //delta computed for anti-peak

						//see if any peaks are within element -> reverse delta
						bool flag = false;
						for (unsigned ii = 0; ii < segments.size(); ++ii) {
							if (segments[ii]->xpeak >= x[j] && segments[ii]->xpeak <= x[j+1]) flag = true;
						}
						if (flag == true)  delta = h - delta;

	                    //subdivide interval into two: [x1, x1+delta] [x1+delta, x2], effectively double number of integration points
    	                double philoc1 = pg[k] * phiNL[j] + (1-pg[k]) * (phiNL[j] - delta);
    	                if (flag) philoc1 = pg[k] * phiNL[j] + (1-pg[k]) * (phiNL[j] + delta);
        	            double philoc2 = pg[k] * (phiNL[j] - delta) + (1-pg[k]) * phiNL[j+1];
        	            if (flag) philoc2 = pg[k] * (phiNL[j] + delta) + (1-pg[k]) * phiNL[j+1];
						d_quad[j].push_back(dm.dval(philoc1));
						d_quad[j].push_back(dm.dval(philoc2));
						d_quad_wt[j].push_back(delta/h * wg[k]);
						d_quad_wt[j].push_back((h-delta)/h * wg[k]);
            	        dloc[k] = delta/h * dm.dval(philoc1) + (h-delta)/h * dm.dval(philoc2);
                	} else {
	                    double philoc = pg[k] * phiNL[j] + (1-pg[k]) * phiNL[j+1];
						d_quad[j].push_back(dm.dval(philoc));
						d_quad_wt[j].push_back(wg[k]);
    	                dloc[k] = dm.dval(philoc);
        	        }
            	    s[j] += wg[k] * (1-dloc[k]) * E * e[j];
					d[j] += wg[k] * dloc[k];
	            }
    	    } else if  (phiNL[j] <= 0 && phiNL[j+1] <= 0) {
				//both sides negative
        	    s[j] = E * e[j];
			    d_quad[j].push_back(0.0);
				d_quad_wt[j].push_back(1.0); 
	        } else if  (phiNL[j] > 0 && phiNL[j+1] <= 0) {
				//left side positive, right side negative
    	        double delta = fabs(phiNL[j]) / (fabs(phiNL[j])+fabs(phiNL[j+1]));
        	    double sloc = 0;
            	for (unsigned k = 0; k < pg.size(); ++k) {
                	double philoc = pg[k] * phiNL[j];
	                dloc[k] = dm.dval(philoc);
    	            sloc += wg[k] * (1-dloc[k]) * E * e[j];
			        d[j] += wg[k] * dloc[k] * delta; //+ ( 1-delta) * 0.0
					d_quad[j].push_back(dm.dval(philoc));
					d_quad_wt[j].push_back(wg[k] * delta);
        	    }
				d_quad[j].push_back(0.0);
				d_quad_wt[j].push_back( 1-delta );
            	s[j] = delta *  sloc +  (1-delta) * E * e[j];
	        } else if (phiNL[j] <= 0 && phiNL[j+1] > 0) {
				//left side negative, right side positive
    	        double delta = fabs(phiNL[j+1]) / (fabs(phiNL[j])+fabs(phiNL[j+1]));
        	    double sloc = 0;
            	for (unsigned k = 0; k < pg.size(); ++k) {
                	double philoc = pg[k] * phiNL[j+1];
	                dloc[k] = dm.dval(philoc);
    	            sloc += wg[k] * (1-dloc[k]) * E * e[j];
			        d[j] += wg[k] * dloc[k] * delta; //+ ( 1-delta) * 0.0
					d_quad[j].push_back(dm.dval(philoc));
					d_quad_wt[j].push_back(wg[k] * delta); 
        	    }
				d_quad[j].push_back(0.0);
				d_quad_wt[j].push_back( 1-delta );
            	s[j] = delta *  sloc +  (1-delta) * E * e[j];
	        }

            if (d[j] > d_max[j]) d_max[j] = d[j];		//update maximum damage

			if (inTLSnode[j] + inTLSnode[j+1] == 1) {
				//if (d[j] < d_max[j]) d[j] = d_max[j];
			}

            if (fullCompression) {
                //this makes compression fully in contact no matter what the damage
                if (e[j] < 0) s[j] = e[j] * E;
            }
		}

        assert(d_quad[j].size() == d_quad_wt[j].size());
        assert(fabs(sum(d_quad_wt[j]) - 1.0) < 1.0e-6);
        assert(d_quad[j].size() == d_quad_wt[j].size());
	}

	return;
}

unsigned PotentialAvenger::calculateStressesL(const vector<double>& pg, const vector<double>& wg, const unsigned& j) {

	//for (unsigned j = 0; j < Nelt; ++j) {
	    //inTLS == 0 : local damage model
		unsigned status = 0;

        unsigned nodesInTLS = 0;
        if (inTLSnode[j]) nodesInTLS++;
        if (inTLSnode[j+1]) nodesInTLS++;
        if (nodesInTLS >= 2) return 0;


		d[j] = 0.0;
        s[j] = 0.0;
		double dee = d_1[j];
//cout << " dee before = " << dee << "  phiL before = " << phiL[j] << endl;
		//check to see if damage needs to be recalculated; (local model so no need to use quadrature for dH)
		if (0.5 * E * e[j] * e[j] > dH(j,d_1[j]) + Ycv[j]) 	{
			double factor = sqrt(2.0 * Ycv[j] / (E * e[j] * e[j]) ); 
			dee = (1.0 - fabs(factor)) / alpha;
            if (dee < 0.0) //E * e[j] * e[j] < 2.0 * Yc) 
				dee = 0.0;			//not damaged if Y < Yc
            if (dee > 1.0)
                dee = 1.0;
            assert(nodesInTLS < 2);
			status = 1;
		}
        if (dee > d_max[j]) d_max[j] = dee;		//update maximum damage
		d[j] = dee;
        s[j] = E * (1.0 - dee) * e[j];
		assert(d[j] >= d_1[j]);
		if (d[j] < 1.0) assert(0.5 * E * e[j] * e[j] - dH(j,d[j]) <= Ycv[j] * (1 + 1.0e-6));
		
        if (fullCompression) {
            //this makes compression fully in contact no matter what the damage
            if (e[j] < 0) s[j] = e[j] * E;
        }

		d_quad[j].clear();
		d_quad_wt[j].clear();

		d_quad[j].push_back(d[j]);
        d_quad_wt[j].push_back(1.0);

/*		if (d[j] > 0.0) {
			printf("elem = %u, 0.5Eee = %6.3e, dH = %6.3e, Ycv = %6.3e\n",j, 0.5 * E * e[j] * e[j], dH(j,d_1[j]), Ycv[j]);
			cout << "   new D = " << d[j] << endl;
			assert(1 == 0);
		} 
  */  
	//}
    return status;
}

void PotentialAvenger::calculateEnergies(const unsigned& i, const vector<double>& pg, const vector<double>& wg) {
    dissip_energy = 0.0;
    kinetic_energy = 0.0;

    for (unsigned j = 0; j < Nelt; ++j) {
        Y[j] = 0.5 * E * e[j] * e[j];
        for (unsigned k = 0; k < d_quad_wt[j].size(); ++k) {
            double dloc = d_quad[j][k];
            Y[j] -= d_quad_wt[j][k] * dH(j,dloc);
        }

		if (Ybar[j] == 0.0) {
			if (d[j] == 1 && inTLS[j] == 1) Ybar[j] = 0.0;  //not sure why some are excluded
			else Ybar[j] = Y[j]/Yc;
		}

        if (inTLS[j] == 1) dissip_energy_TLS += h * A * Y[j] * (d[j] - d_1[j]); //global dissipation = int: Y dd/dt dV
        if (inTLS[j] == 0) dissip_energy_local += h * A * Y[j] * (d[j] - d_1[j]); //global dissipation = int: Y dd/dt dV
        if (i > 0) {
            kinetic_energy += 0.5 * h * A * rho * 0.5 *
                                ( pow(u[j] - u_1[j],2) + pow(u[j+1] - u_1[j+1],2) ) / pow(dt,2);
            //ustat(i,j+1) = ustat(i,j) + h*s(0,Nelt)/(E*(1-d(i,j)));
        } else {
            kinetic_energy += 0.5 * h * A * rho * 0.5 * ( v[j] * v[j] + v[j+1] * v[j+1]);
        }
        energy[j] = h * A * 0.5 * E * e[j] * e[j] * (1.0 - d[j]);
    }
    //ustat(i,:) *= u(1,Nnod)/ustat(i,Nnod);
    for (unsigned j = 0; j < Nelt; ++j) Ystat[j] = 0.5 * E * pow((ustat[j+1] - ustat[j])/h,2);

	dissip_energy = dissip_energy_local + dissip_energy_TLS;

    strain_energy = sum (energy);
    if (i > 0) ext_energy += (a[Nnod-1] * m[Nnod-1] + s[Nnod-2] * A) * v[Nnod-1] * dt;
    else ext_energy = dissip_energy + strain_energy + kinetic_energy;
    tot_energy = strain_energy + kinetic_energy + dissip_energy - ext_energy;
    max_energy = max(max(kinetic_energy,dissip_energy),strain_energy);
    return;
}

std::string convertInt(unsigned number) {
    if (number == 0)
        return "0";
    string temp="";
    string returnvalue="";
	//read from back
    while (number>0)
    {
        temp+=number%10+48;
        number/=10;
    }
    for (unsigned i=0;i<temp.length();i++)
        returnvalue+=temp[temp.length()-i-1];
    return returnvalue;
}

double PotentialAvenger::H (const unsigned j, const double dee) { 
    return (Ycv[j] * alpha * dee * dee)/(1.0 - alpha * dee);
}    

double PotentialAvenger::dH (const unsigned j, const double dee) const { 
    return (Ycv[j] * alpha * dee) * (2.0 - alpha * dee)/pow(1.0 - alpha * dee,2);
}    

double PotentialAvenger::d2H (const unsigned j, const double dee) const { 
    return (2.0 * Ycv[j] * alpha) /pow(1.0 - alpha * dee,3);
}    

void PotentialAvenger::updateLevelSetL( const unsigned& i, vector<unsigned>& nbiter, vector<Segment*>& segments, const vector<double>& pg, const vector<double>& wg, const unsigned& j) {

     //for (unsigned j = 0; j < Nelt; ++j) {
        unsigned nodesInTLS = 0;
        if (inTLSnode[j]) nodesInTLS++;
        if (inTLSnode[j+1]) nodesInTLS++;
		double dee = d[j];
        if (nodesInTLS < 2) 	phiL[j] = dm.phi(dee);
		else 				phiL[j] = 0.0;
	
     //}
	 return;
}

void PotentialAvenger::updateLevelSetNL( const unsigned& i, vector<unsigned>& nbiter, vector<Segment*>& segments, const vector<double>& pg, const vector<double>& wg ) {
	//non-local nodes   

	//save phiNL beforehand
	vector<double> phiNL_before = phiNL;
 
    for (unsigned l = 0; l < segments.size(); ++l) {
        if (segments[l]->size()==0) continue;//segments.erase(segments.begin()+l);
        unsigned sbegin = segments[l]->begin();
        unsigned send = segments[l]->end();
        
		//clear Ybar
		segments[l]->YbarmYc = 0.0;

		double segZero = calculateZero(segments[l], phiNL);
 
        //skip if all negative
        bool allNeg = true;
        for (unsigned k = sbegin; k <= send; ++k) {
            if (phiNL[k] != -1) {
                allNeg = false;
                break;
            }
        }
        if (allNeg) continue;
        
        double err_crit = 1e15;
        double dphi = 0;
        nbiter[i] = 0;
        double residu = 0;
//cout << "int: [" << sbegin << "," << send<< "]  dmax = " << dm.dval(segments[l].phipeak) << "  phimax = " << segments[l].phipeak << "  ," << 
//"  x= " << segments[l].xpeak << "   slope = " << segments[l].slope <<
//endl;

        if (segments[l]->phipeak <= 0) continue;
        if (segments[l]->phimin >= lc) continue;

        double YbarmYc = 1.0;    
		vector<double> residuV, tangentV, phimaxV;
		unsigned iter_max = 20;
		unsigned limit = iter_max;
		unsigned count = 0;
		double err_tol = 1.e-6;
        while (err_crit > err_tol && nbiter[i] < iter_max) {
            nbiter[i]++;
			
			double residu_Y = 0.0;
			double tangent_Y = 0.0;
            double phimin = 0.0;
			double phimax = 0.0; 
            double phiminY = 0.0;
			double phimaxY = 0.0;
			double Ycavg = 0.0; 
            unsigned status = calculateYbar(pg,wg,Ycavg,YbarmYc,residu_Y,tangent_Y,phimin,phimax,phiminY,phimaxY,nbiter[i],sbegin,send,segments[l],segZero);
			
			if (status == 0) goto next;
			if (YbarmYc < 0 && nbiter[i] == 1) goto next;
			if (segments[l]->phimin >= lc) goto next;

            residu = residu_Y;
            err_crit = fabs(residu)/Yc/(dm.dval(phimax) - dm.dval(phimin)) ; //Ycavg;

            double tangent = tangent_Y;
//cout << "dphi = " << dphi;
            if (fabs(tangent) <= 1.e-10) {
                /*err_crit = 0.;*/ dphi = 0.;
            } else {
                dphi = - residu/tangent;
            }
			if (err_crit <= err_tol) dphi = 0.0;
            if (isnan(dphi)) {
                dphi = 0;
                assert(1==0);                
            }

			residuV.push_back(residu);
			tangentV.push_back(tangent);
			phimaxV.push_back(phimax);
            for (unsigned j = sbegin; j <=send; ++j) {
                phiNL[j] += dphi;//phiNL_before[j] + dphi;
                //enforcing limit of level-set motion
                //phi[j] = min(phi_1[j]+h,phi[j]);
            }
			segments[l]->phipeak += dphi;
			segments[l]->phimin += dphi;
			checkInTLS(segments,inTLS,inTLSnode);
        	//setPeak(x,phiNL,segments,l); //segments[l].phipeak += dphi; 
        } //endwhile

		//Bisection search to finish off convergence calculation
		bool hasPos;
		bool hasNeg;
		if (nbiter[i] >= limit) {
			hasPos = false;
			hasNeg = false;
			for (unsigned j = 0; j < residuV.size(); ++j) {
				if (residuV[j] > 0) hasPos = true;
				if (residuV[j] < 0) hasNeg = true;
				if (hasPos && hasNeg) break;
			}
        } else {
            hasNeg = false; hasPos = false;
        }
		if (nbiter[i] >= limit && hasPos && hasNeg) {
            double residu_Y = 0.0;
            double tangent_Y = 0.0;
            double phimin = 0.0;
            double phimax = 0.0;
            double phiminY = 0.0;
            double phimaxY = 0.0;
            double Ycavg = 0.0;
			while (count < iter_max) {
				count++;
				//find last positive
				double rPos = 0.0;
				double phiPos = 0.0;
				for (unsigned j = 0; j < residuV.size(); ++j) if (residuV[j] > 0) {rPos = residuV[j]; phiPos = phimaxV[j];}
				//find last negative	
				double rNeg = 0.0;
				double phiNeg = 0.0;
				for (unsigned j = 0; j < residuV.size(); ++j) if (residuV[j] < 0) {rNeg = residuV[j]; phiNeg = phimaxV[j];}
				assert(rPos > 0.0); assert(rNeg < 0.0);
				
				double phimaxMid = 0.5 * (phiPos + phiNeg);
				dphi = phimaxMid - segments[l]->phipeak; 
				segments[l]->phipeak += dphi;
				segments[l]->phimin += dphi;
   	         	for (unsigned j = sbegin; j <=send; ++j) phiNL[j] += dphi;
    	        unsigned status = calculateYbar(pg,wg,Ycavg,YbarmYc,residu_Y,tangent_Y,phimin,phimax,phiminY,phimaxY,nbiter[i],sbegin,send,segments[l],segZero);
				phimaxV.push_back(segments[l]->phipeak);
				residuV.push_back(residu_Y);
			}
		} //end bisection search


		//finish with linear interpolation
		if (nbiter[i] >= limit) {
            double residu_Y = 0.0;
            double tangent_Y = 0.0;
            double phimin = 0.0;
            double phimax = 0.0;
            double phiminY = 0.0;
            double phimaxY = 0.0;
            double Ycavg = 0.0;
			unsigned size = residuV.size();
			assert(size >= 2);
            double rPos = residuV[size-1];
            double phiPos = phimaxV[size-1];
            double rNeg = residuV[size-2];
            double phiNeg = phimaxV[size-2];

			if (phiPos - phiNeg != 0) {
				double m = (rPos - rNeg) / (phiPos - phiNeg);
				dphi = phiNeg - rNeg/m - segments[l]->phipeak;
                segments[l]->phipeak += dphi;
                segments[l]->phimin += dphi;
                for (unsigned j = sbegin; j <=send; ++j) phiNL[j] += dphi;
    	        unsigned status = calculateYbar(pg,wg,Ycavg,YbarmYc,residu_Y,tangent_Y,phimin,phimax,phiminY,phimaxY,nbiter[i],sbegin,send,segments[l],segZero);
				phimaxV.push_back(segments[l]->phipeak);
				residuV.push_back(residu_Y);
			}
		}

		assert(nbiter[i] < iter_max || count > 0);
		assert(YbarmYc/Yc <= 1.e-6);
	assert(YbarmYc/Yc <= 1.e-6);
            for (unsigned j = sbegin; j <=send; ++j) {
                phiNL[j] = max(phiNL[j],phiNL_1[j]); //constraint: dphi >= 0
            }
        next:
        err_crit = 0.0;
        //setPeak(phiNL,segments,l); //segments[l].phipeak += dphi; 

    } //for segments

    return;
}

void PotentialAvenger::setPeakAll(const vector<double>&phiIn, vector<Segment*>& segments) {
	for (unsigned l = 0; l < segments.size(); ++l) 	setPeak(phiIn,segments,l); //segments[l].phipeak += dphi; 
	return;
}

void PotentialAvenger::setPeak(const vector<double>& phiIn, vector<Segment*>& segments, const unsigned index) {
	unsigned sbegin = segments[index]->begin();
	unsigned send = segments[index]->end();	
	double slope = static_cast<double>(segments[index]->slope);
	double a1,a2,b1,b2,xint,phiint;

	//set peak	
	//find neighboring segment
	unsigned other = index;
	int dist = Nelt;
	double otherSlope = 0.0;
	if (slope == 1) {
		for (unsigned i = 0; i < segments.size(); ++i) {
			int qty = segments.at(i)->begin() - send;
			if (qty < dist && qty > 0) {
				dist = qty;
				other = i;
				otherSlope = static_cast<double>(segments[i]->slope);
			}
		}

		//if at right edge
		if (other == index && (send == Nnod - 1) ) {
			segments[index]->xpeak = x[send];	
			segments[index]->phipeak = phiIn[send];
			goto setMin;
		}

		//if (usually right after nucleation), the nearest neighbor has same slope
		//This is for the case when you have two consecutive segments with the same slope.
		//  The second segment isn't far enough the first to have indices in the opposite slope, so it was deleted.
		//  It sets the xmin/xpeak to be just the average of the two segment endpoints
		//   and the phimin/phipeak to be the extrapolation of the two segment endpoints & slope.
		if (otherSlope == slope && other != index) {
			double dist = x[segments[other]->begin()] - x[send];
			segments[index]->xpeak = x[send] + 0.5 * dist;
			segments[index]->phipeak = phiIn[send] + 0.5 * dist;
			goto setMin;
		}

		assert(other != index);
		assert(otherSlope != slope);
	} else {
        for (unsigned i = 0; i < segments.size(); ++i) {
			int qty = sbegin - segments.at(i)->end();
            if (qty < dist && qty > 0) {
                dist = qty;
                other = i;
				otherSlope = static_cast<double>(segments[i]->slope);
            }
        }

        //if at left edge
        if (other == index && (sbegin == 0) ) {
            segments[index]->xpeak = x[sbegin];    
            segments[index]->phipeak = phiIn[sbegin];
            goto setMin; 
        }

        //if (usually right after nucleation), the nearest neighbor has same slope
		//(same explanation)
        if (otherSlope == slope && other != index) {
            double dist = x[sbegin] - x[segments[other]->end()];
            segments[index]->xpeak = x[sbegin] - 0.5 * dist;
            segments[index]->phipeak = phiIn[sbegin] + 0.5 * dist;
            goto setMin;
        }

        assert(other != index);
        assert(otherSlope != slope);
	}

	//get slopes & intercepts: phi = a*x + b
	a1 = slope;
	a2 = otherSlope;
	b1 = phiIn[sbegin] - slope * x[sbegin]; 
	b2 = phiIn[segments[other]->begin()] - segments[other]->slope * x[segments[other]->begin()];;
	assert(a1 - a2 != 0.0);	

	//intersect
	xint = (b2 - b1) / (a1 - a2);
	phiint = (a1*b2 - b1*a2) / (a1 - a2);

	//save peaks
	segments[index]->xpeak = xint;	
	segments[index]->phipeak = phiint;	

	//check bounds -- don't set the max past the relevant boundary
	if (slope == 1) {
		segments[index]->xpeak = max(xint, x[sbegin]);
		if (segments[index]->xpeak == x[sbegin]) segments[index]->phipeak = phiNL[sbegin];
	} else if (slope == -1) {
		segments[index]->xpeak = min(xint, x[send]);
		if (segments[index]->xpeak == x[send]) segments[index]->phipeak = phiNL[send];
	}	
	setMin:
	//set minimum	
	//find neighboring segment
	other = index;
	dist = Nelt;
	otherSlope = 0.0;
	if (slope == 1) {
		for (unsigned i = 0; i < segments.size(); ++i) {
			int qty = sbegin - segments.at(i)->end();
			if (qty < dist && qty > 0) {
				dist = qty;
				other = i;
				otherSlope = static_cast<double>(segments[i]->slope);
			}
		}

		//if at left edge
		if (other == index && (sbegin == 0) ) {
			segments[index]->xmin = x[sbegin];	
			segments[index]->phimin = phiIn[sbegin];
			if (segments[index]->xpeak < x[0]) {
				segments[index]->phipeak -= segments[index]->xpeak;
				segments[index]->xpeak = 0.0;
			}
			goto end;
		}

        //if (usually right after nucleation), the nearest neighbor has same slope
		//(same explanation)
        if (otherSlope == slope && other != index) {
            double dist = x[sbegin] - x[segments[other]->end()];
            segments[index]->xmin = x[sbegin] - 0.5 * dist;
            segments[index]->phimin = phiIn[sbegin] - 0.5 * dist;
            goto end;
        }

		assert(other != index);
		assert(otherSlope != slope);
	} else {
        for (unsigned i = 0; i < segments.size(); ++i) {
			int qty = segments.at(i)->begin() - send;
            if (qty < dist && qty > 0) {
                dist = qty;
                other = i;
				otherSlope = static_cast<double>(segments[i]->slope);
            }
        }

        //if at right edge
        if (other == index && (send == Nnod - 1) ) {
            segments[index]->xmin = x[send];    
            segments[index]->phimin = phiIn[send];
            if (segments[index]->xpeak > x[Nelt]) {
                segments[index]->phipeak += segments[index]->xpeak - x[Nelt];
                segments[index]->xpeak = x[Nelt];
            }
            goto end; 
        }

        //if (usually right after nucleation), the nearest neighbor has same slope
		//(same explanation)
        if (otherSlope == slope && other != index) {
            double dist = x[segments[other]->begin()] - x[send];
            segments[index]->xmin = x[send] + 0.5 * dist;
            segments[index]->phimin = phiIn[send] - 0.5 * dist;
            goto end;
        }

        assert(other != index);
        assert(otherSlope != slope);
	}

	//get slopes & intercepts: phi = a*x + b
	a1 = slope;
	a2 = otherSlope;
	b1 = phiIn[sbegin] - slope * x[sbegin]; 
	b2 = phiIn[segments[other]->begin()] - segments[other]->slope * x[segments[other]->begin()];;
	assert(a1 - a2 != 0.0);

	//intersect
	xint = (b2 - b1) / (a1 - a2);
	phiint = (a1*b2 - b1*a2) / (a1 - a2);

	//save peaks
	segments[index]->xmin = xint;	
	segments[index]->phimin = phiint;	

	//check bounds -- don't set the min past the relevant boundary
	//min forced to abide by peak so that the element length (xpeak-xmin)*slope is >= 0
	if (slope == 1) {
    	segments[index]->xmin = min(segments[index]->xpeak, min(xint, x[send]));
	    if (segments[index]->xmin == x[send]) segments[index]->phimin = phiIn[send];
	    if (segments[index]->xmin == segments[index]->xpeak) segments[index]->phimin = segments[index]->phipeak;
	} else if (slope == -1) {
    	segments[index]->xmin = max(segments[index]->xpeak, max(xint, x[sbegin]));
    	if (segments[index]->xmin == x[sbegin]) segments[index]->phimin = phiNL[sbegin];
    	if (segments[index]->xmin == segments[index]->xpeak) segments[index]->phimin = segments[index]->phipeak;
	}

	end:
	
	//correct if needed
	if (segments[index]->xpeak < 0) {
		double qty = segments[index]->xpeak;
		segments[index]->xpeak = 0;
		segments[index]->phipeak -= slope * qty;
	}
    if (segments[index]->xpeak > L) {
        double qty = segments[index]->xpeak - L;
        segments[index]->xpeak = L;
        segments[index]->phipeak -= slope * qty;
    }
    if (segments[index]->xmin < 0) {
        double qty = segments[index]->xmin;
        segments[index]->xmin = 0;
        segments[index]->phimin -= slope * qty;
    }
    if (segments[index]->xmin > L) {
        double qty = segments[index]->xmin - L;
        segments[index]->xmin = 0;
        segments[index]->phimin -= slope * qty;
    }

    assert(segments[index]->xpeak <= L);
    assert(segments[index]->xpeak >= 0.0);
    assert(segments[index]->xmin <= L);
    assert(segments[index]->xmin >= 0.0);

	double qty = (segments[index]->phipeak-segments[index]->phimin)/(segments[index]->xpeak-segments[index]->xmin);

	assert( segments[index]->phipeak - segments[index]->phimin >= 0);
	assert( segments[index]->slope * (segments[index]->xpeak - segments[index]->xmin) >= 0);

	return;
}

double PotentialAvenger::calculateZero (Segment* segment, const vector<double>& phiIn) {
	//calculate where along this segment the zero is
	double slope = segment->slope;
	
	assert(fabs(slope) == 1.0);
	assert(segment->size() > 0);
	unsigned sbegin = segment->begin();

	double zero = x[sbegin] - phiIn[sbegin] / slope;
 
	return zero;
}

double PotentialAvenger::calculateTotal (Segment* segment, const vector<double>& phiIn) {
	//calculate where along this segment total damage (lc) is
    double slope = segment->slope;

    assert(fabs(slope) == 1.0);
    assert(segment->size() > 0);
    unsigned sbegin = segment->begin();

    double total = x[sbegin] - (phiIn[sbegin] - lc) / slope;

    return total;
}

template <typename T> bool contains (const vector<T>& v, const T& item) {
	if(std::find(v.begin(), v.end(), item) != v.end()) {
		return true;
	} else {
		return false;
	}
}

unsigned PotentialAvenger::calculateYbar(const vector<double>& pg, const vector<double>& wg, double& Ycavg, double& YbarmYc, double& residu_Y, double& tangent_Y, double& phimin, double& phimax, double& phiminY, double& phimaxY, unsigned& nbiter, const unsigned sbegin, const unsigned send, Segment* segment, const double& segZero) {
    residu_Y = 0; 
    tangent_Y = 0.0; 
    unsigned loop_residu = 0;
    unsigned loop_tangent = 0;

	double segLength = 0;
	Ycavg = 0.0;

    phimin = phiNL[sbegin];
    unsigned iphimin = sbegin;
	double slope = segment->slope;
    assert(pg.size() == wg.size());
    for (unsigned j = 0; j <= Nelt; ++j) {
//		if (x[j+1] < min(segment->xpeak,segment->xmin)) continue;
//		if (x[j] > max(segment->xpeak,segment->xmin)) continue;

		if (inTLSnode[j]+inTLSnode[j+1] == 0) continue;
	
		//determine endpoints to be integrated
		double xpeak = segment->xpeak;
		double xmin = segment->xmin;

		//default
		double begin = x[j];
		double phiB = phiNL[j];
		double end = x[j+1];
		double phiE = phiNL[j+1];

		//see if nodes are contained in indices
		unsigned node1 = contains(segment->indices, static_cast<int>(j) );	
		unsigned node2 = contains(segment->indices, static_cast<int>(j+1) );
		if (node1 + node2 == 0) continue;	
		assert(node1 + node2 > 0);

		//check peak
		if (slope == -1) {
			begin = max(begin, xpeak);
			if (begin == xpeak) phiB = segment->phipeak;
		}
		if (slope == 1) {
			end = min(end, xpeak);
			if (end == xpeak) phiE = segment->phipeak;
		}

		//check min
        if (slope == 1) {
            begin = max(begin, xmin);
            if (begin == xmin) phiB = segment->phimin;
        }
        if (slope == -1) {
            end = min(end, xmin);
            if (end == xmin) phiE = segment->phimin;
        }

		/*
		//check real zero -- no need!
		if (phiNL[j] * phiNL[j+1] < 0) {
			if (slope == 1) {
				assert(phiNL[j] < 0 && phiNL[j+1] > 0);
				assert(node2 == 1);
				double delta = h - phiNL[j+1];
				assert(delta >= 0); assert(delta <= h);

				begin = max(begin, delta);
				if (begin == delta) phiB = 0.0;
			}
			if (slope == -1) {
				assert(phiNL[j] > 0 && phiNL[j+1] < 0);
				assert(node1 == 1);
				double delta = phiNL[j];
				assert(delta >= 0); assert(delta <= h);

				end = min(end, delta);
				if (end == delta) phiE = 0.0;
			}
		}
		*/

		//check segzero
		if (slope == 1) {
			begin = max(begin, segZero);
			if (begin == segZero) {
				phiB = phiNL[j+1] - phiNL_1[j+1];
			}	
		}
		if (slope == -1) {
			end = min(end, segZero);
			if (end == segZero) {
				phiE = phiNL[j] - phiNL_1[j];
			}
		}
		
		double weight = max(min(end - begin, h), 0.0);
		assert(weight >= 0);
		assert(weight <= h);
	
        for (unsigned k = 0; k < pg.size(); ++k) {
               	
			//interpolate between begin and end
			double philoc = pg[k] * phiB + (1.0 - pg[k]) * phiE;

			residu_Y += weight * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dp(philoc);
          	tangent_Y += weight * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dpp(philoc)
	        			 - weight * wg[k] * d2H(j,dm.dval(philoc)) * pow(dm.dp(philoc),2);
        
           	loop_residu++;
           	loop_tangent++;
			Ycavg += Ycv[j] * weight/h;
			segLength += weight/h;
        
        }
     }//end loop-nodes
	Ycavg /= static_cast<double>(pg.size());
	segLength /= static_cast<double>(pg.size());

    phimax = phiNL[sbegin];
    unsigned iphimax = sbegin;
    for (unsigned k = sbegin; k <= send; ++k) {
       if (phiNL[k] > phimax) {
            phimax = phiNL[k];
            iphimax = k;
        }
        if (phiNL[k] < phimin) {
            phimin = phiNL[k];
            iphimin = k;
        }
    }
    phimax = max(phimax,segment->phipeak);// + dphi;//max(0.0,dphi);
    phimin = min(phimin,segment->phimin);
    if (dm.dval(phimin) == 1 && nbiter == 1) return 0;
    if (phimin == phimax) return 0;

    phimaxY = 0.0;
    if (iphimax == Nnod-1) phimaxY = 0.5*E*pow(e[Nelt-1],2) - dH(iphimax, dm.dval(phimax)); //1/2*s(i,Nelt)*e(i,Nelt);
    else {
        phimaxY = 0.5*E*pow(e[iphimax],2);// 1/2*s(i,iphimax)*e(i,iphimax);
        for (unsigned k = 0; k < d_quad_wt[iphimax].size(); ++k) {
	        phimaxY -= d_quad_wt[iphimax][k] * dH(iphimax,d_quad[iphimax][k]);
        }
    }

    phiminY = 0.0;
    if (iphimin == Nnod-1) phiminY = 0.5*E*pow(e[Nelt-1],2) - dH(iphimin, dm.dval(phimin)); //1/2*s(i,Nelt)*e(i,Nelt);
    else {
		phiminY = 0.5*E*pow(e[iphimin],2);// 1/2*s(i,iphimax)*e(i,iphimax);
        for (unsigned k = 0; k < d_quad_wt[iphimin].size(); ++k) {
            phiminY -= d_quad_wt[iphimin][k] * dH(iphimin,d_quad[iphimin][k]);
        }
    }

                    
    YbarmYc = residu_Y/(dm.dval(phimax)-dm.dval(phimin));
	if (segment->size() <= 1) YbarmYc = residu_Y/(dm.dval(phimax + 0.5*h)-dm.dval(phimin - 0.5*h));
    if (dm.dval(phimin) == 1 && dm.dval(phimax) == 1) YbarmYc = 0.0;
	if (residu_Y == 0.0) YbarmYc = 0.0;
//cout << "Ybar:   residuY = " << residu_Y << "   tangentY = " << tangent_Y << endl;
//    cout << "segment " <<  " begin = " << sbegin << "  end = " << send << "  |  YbarmYc = " << YbarmYc << "    Yc = " << Yc << "  -> ratio= " << YbarmYc/Yc << endl;
/*    if (YbarmYc/Yc > 0.001) {
    //cout << " YbarmYc = " << YbarmYc << "    Yc = " << Yc << "  -> ratio= " << YbarmYc/Yc << endl;
    cout << "residuY = " << residu_Y << endl;
    cout << " phimax = " << phimax << "   ( " << dm.dval(phimax) << endl;
    cout << " phimin = " << phimin << "   ( " << dm.dval(phimin) << endl;
    cout << " diff-d = " << dm.dval(phimax)-dm.dval(phimin) << endl;
    }				
*/
    segment->YbarmYc = YbarmYc;
if (segLength <= 0.0) {
//	cout << " begin-end = " << segment->begin() << "  - " << segment->end() << endl;
//    cout << "   YbarmYc = " << YbarmYc << "   saved as " << segment->YbarmYc << endl;
    cout << endl;
    cout << " residuY = " << residu_Y << "    Yc = " << Yc << endl;
    cout << " YbarmYc = " << YbarmYc << endl;
}
	assert(segLength <= fabs(segment->xpeak - segment->xmin)/h + 1.0e-6);
	assert(segLength > -EPS);
	Ycavg /= segLength;

    for (unsigned j = max(0,static_cast<int>(sbegin)-1); j <= min(send+1,Nelt-1); ++j) {
        if (j < 0) continue;
        if (inTLSnode[j]+inTLSnode[j+1] == 0) continue;
		Ybar[j] = YbarmYc/Ycavg+1.0;
	}

	return 1;
}

void PotentialAvenger::nucleate(const double t, const std::vector<double>& xnuc, const std::vector<double>& phinuc, std::vector<Segment*>& newSegment, const std::string& elemOrNodal){
    //t      -time
    //x      -mesh
    //phi    -level-set calculated at this time-step
    //xnuc   -location(s) of localizations to be nucleated
    //phinuc -amount of the level-set to be set at nucleated localizations

    assert(xnuc.size() == phinuc.size());
    assert(xnuc.size() > 0);

    for (unsigned j = 0; j < xnuc.size(); ++j) {
        int loc = -1;
        double delta = 0;
        nucleated++;
        for (unsigned i = 0; i < x.size()-1; ++i) {
            if ((xnuc[j] >= x[i]) && (xnuc[j] < x[i+1])) {
                loc = i;
                delta = (xnuc[j] - x[i])/h;
                break;
            }

        }
        if (loc == -1 && xnuc[j] == 1.0) {
			loc = Nnod - 1;
			delta = 0.0;
		}

        assert(loc != -1);
        double proposed1 = phinuc[j] - delta*h;
        double proposed2 = phinuc[j] - (1-delta)*h;
        if (elemOrNodal.compare("nodal") == 0) {
			assert(delta == 0.0);

            inTLSnode[loc] = 1;
            inTLS[loc] = 1;
            if (loc > 0) inTLS[loc-1] = 1;
            if (loc > 0) inTLSnode[loc-1] = 1;
            inTLSnode[loc+1] = 1;
        
            if (loc < static_cast<int>(Nnod)-1) inTLSnode[loc+1] = 1;
            double gradient = 0;
            if (loc >= 1) {
                if (d_1[loc] > d_1[loc-1]) gradient = 1.0; else gradient = -1.0;
                if (d_1[loc] < d_1[loc-1]) gradient = -1.0;
            } else gradient = -1.0;
			if (loc == static_cast<int>(Nnod)-1) gradient = 1.0;
            assert(gradient != 0);
	        if (gradient == 1.0) {
				assert(loc >= 1);
				double phicrit = phiNL[loc];
				if (loc > 0) phicrit = max(phicrit,phiL[loc-1]); 
				if (loc < static_cast<int>(Nnod)) phicrit = max(phicrit,phiL[loc]); 
				if (loc > 0) phiNL[loc-1] = max(max(phicrit-h,phiL[loc-1]),phiNL[loc-1]);
				phiNL[loc] = phicrit;
				if (loc+1 < static_cast<int>(Nnod)) phiNL[loc+1] = phicrit;
				if (loc+1 < static_cast<int>(Nelt)) phiNL[loc+1] = max(phicrit,phiL[loc+1]);
				if (loc+1 < static_cast<int>(Nnod)) delta = 0.5 * (h + phiNL[loc+1] - phiNL[loc]);
				else delta = 0.0;	
			assert(delta >= 0.0); assert(delta <= h);
    	    } else {
                assert(loc <= static_cast<int>(Nnod)-1);
                double phicrit = max(phiL[loc],phiNL[loc]);
				if (loc > 0) phicrit = max(phicrit, phiL[loc-1]);
                //phiNL[loc+1] = max(phicrit-h,phiNL[loc+1]); //max(max(phicrit-h,phiL[loc+1]),phiNL[loc+1]);
                if (loc + 1 < static_cast<int>(Nnod) ) phiNL[loc+1] = max(phicrit-h,phiNL[loc+1]);
                if (loc + 1 < static_cast<int>(Nelt) ) phiNL[loc+1] = max(phiL[loc+1],phiNL[loc+1]);
                phiNL[loc] = phicrit;
                if (loc-1 >= 0) phiNL[loc-1] = max(phicrit,phiL[loc-1]);
				if (loc-1 >= 0) delta = 0.5 * (-h + phiNL[loc] - phiNL[loc-1]);
				else delta = 0.0;
			assert(delta <= 0.0); assert(delta >= -h);
        	}
             //create two new segments
             if (xnuc[j] > x[0]) {
                 Segment* seg1 = new Segment(xnuc[j]+delta,phiNL[loc]+fabs(delta),-1);
                 seg1->indices.push_back(loc);
				 seg1->xpeak = xnuc[j] + delta;
				 seg1->phipeak = phiNL[loc]+fabs(delta);
                 newSegment.push_back(seg1);
             }
             if (xnuc[j] < x.back()) {
                 Segment* seg2 = new Segment(xnuc[j]+delta,phiNL[loc]+fabs(delta),1);
                 seg2->indices.push_back(loc+1);
				 seg2->xpeak = xnuc[j] + delta;
				 seg2->phipeak = phiNL[loc]+fabs(delta);
                 newSegment.push_back(seg2);
             }

        } else {
			//elem nucleation
			inTLSnode[loc] = 1;
			inTLSnode[loc+1] = 1;
			inTLS[loc] = 1;
			proposed1 = max(proposed1, dm.phi(d_1[loc]));	
			proposed2 = max(proposed2, dm.phi(d_1[loc]));
			if (loc > 0) proposed1 = max(proposed1, dm.phi(d_1[loc-1]));	
			if (loc > 0) proposed2 = max(proposed2, dm.phi(d_1[loc-1]));	
			if (loc < (int)Nnod-1) proposed1 = max(proposed1, dm.phi(d_1[loc+1]));	
			if (loc < (int)Nnod-1) proposed2 = max(proposed2, dm.phi(d_1[loc+1]));	
            phiNL[loc] = max(phiNL[loc], proposed1);
            phiNL[loc+1] = max(phiNL[loc+1], proposed2);

double zero = 0.0;
            //create two new segments
            if (xnuc[j] > x[0]) {
                 Segment* seg1 = new Segment(xnuc[j]-delta*h*zero,phinuc[j]-delta*h*zero,-1);
                 seg1->indices.push_back(loc);
                 newSegment.push_back(seg1);
             }
             if (xnuc[j] < x.back()) {
                 Segment* seg2 = new Segment(xnuc[j]+(1-delta)*h*zero,phinuc[j]-(1-delta)*h*zero,1);
                 seg2->indices.push_back(loc+1);
                 newSegment.push_back(seg2);
             }

        }
        printf("crack nucleated, t = %f, x = %f \n",t,xnuc[j]);
        
        //now that there has been nucleation, get rid of zero-slope segments
        vector<unsigned> delList;
        for (unsigned i = 0; i < newSegment.size(); ++i) {
            if (newSegment[i]->slope == 0 || newSegment[i]->phipeak == -1) delList.push_back(i);
        }
        while (delList.size() > 0) {
            unsigned index = delList.back(); 
            delete newSegment.at(index);
            newSegment.erase(newSegment.begin() + index);
            delList.pop_back();
        }

    }
};

vector<double> PotentialAvenger::findFragments(unsigned& nfrags, const vector<Segment*>& segments) {
    
    //calculate total number of fragments (removing symmetry simplification)
    vector<double> fragLength = fragmentLength(segments); 
    nfrags = fragLength.size();
    fragmentStats(fragLength);   

    return fragLength; 
};
	
vector<double> PotentialAvenger::fragmentLength(const vector<Segment*>& segments) {
	vector<Segment*> segmentList = segments; 
    vector<double> fragLength;
    double powderLength = 0.0;

	for (unsigned j = 0; j < phiL.size(); ++j) {
		if (phiL[j] > lc) assert(1 == 0); //this has not been implemented yet!
	}

	sort(segmentList.begin(), segmentList.end(), SegmentComparer());

	for (unsigned j = 0; j < segmentList.size(); ++j) {
		double segTotal = calculateTotal(segmentList[j], phiNL);
		if (j == 0) assert(segmentList[j]->begin() == 0);

		double xpeak = min(max(segmentList[j]->xpeak, 0.0), L);
		double xmin = min(max(segmentList[j]->xmin, 0.0), L);
		double rawLength = fabs(xpeak - xmin);

		if (fragLength.size() == 0) fragLength.push_back(0.0);

		if (segmentList[j]->slope == 1) {
			//only consider segtotal if is in the right place
			segTotal = max(segTotal, xmin);

			double solid = min(segTotal - xmin, xpeak - xmin); 
			double powder = max(xpeak - segTotal, 0.0);
            assert(fabs(solid + powder - rawLength) < EPS);
			assert(solid >= 0.0);
			assert(powder >= 0.0);
			fragLength.back() += solid;
			if (fragLength.back() > 0.0) fragLength.push_back(0.0);
			powderLength += powder;
		}
        if (segmentList[j]->slope == -1) {
			//only consider segtotal if is in the right place
			segTotal = min(segTotal, xmin);

            double solid = min(xmin - segTotal, xmin - xpeak);
            double powder = max(segTotal - xpeak, 0.0);
            assert(fabs(solid + powder - rawLength) < EPS);
			assert(solid >= 0.0);
			assert(powder >= 0.0);
			fragLength.back() += solid;
			powderLength += powder;
        }

	}

	//eliminate zero-length fragment due to lots of powder near right end
	if (fragLength.size() > 0) if (fragLength.back() == 0.0) fragLength.pop_back();
	
	//now account for symmetry
	powderLength *= 2.0;
	unsigned count = fragLength.size();
	for (unsigned j = 0; j < count; ++j) {
		if (j == 0) {
			//check to see if broken in middle
			if (phiNL[0] >= lc) fragLength.push_back(fragLength[j]);
			else 				fragLength[j] *= 2.0;
		} else {
			fragLength.push_back(fragLength[j]);
		}
	}


	if (segmentList.size() == 0) fragLength.push_back(2.0 * L);	

	//length check
    double sumfrag = 0.0;
	for (unsigned j = 0; j < fragLength.size(); ++j) 	sumfrag += fragLength[j];
	if (fabs(sumfrag + powderLength - L * 2.0) >= 0.001 * h) cout << " sumfrag = " << sumfrag << "     powder = " << powderLength << "    total = " << sumfrag + powderLength << "    diff = " << sumfrag+powderLength-2*L << endl;
	assert(fabs(sumfrag + powderLength - L * 2.0) < 0.001 * h );

	return fragLength;
};

unsigned PotentialAvenger::checkFailureCriteria(const unsigned ts, std::vector<double>& criterion, const std::string elemOrNodal, const std::vector<double>& qty, const bool absOrAsIs, const bool phiPos, const double failvalue, std::vector<Segment*>& newSegment, vector<unsigned>& nbiter, const vector<double>& pg, const vector<double>& wg){

    //x              -mesh
    //phi            -level-set calculated at this time-step
    //criterion      -criterion to compare against for failure
    //elemOrNodal    -either 'elem' or 'nodal' - is criterion elemental or nodal
    //qty            -the quantity to be compared to the criterion -e.g. s,Y
    //absOrAsIs      -whether to compare (0) qty or (1) abs(qty) to criterion
    //phiPos         -whether(1) or not(0) failure cannot occur depending on if phi>0
    //failvalue      -what to call phi at localization zone if created - e.g. h
    //failure if qty > criterion
	//return: xlist - number of nucleations performed

    vector<double> margin;
    vector<unsigned> index;

    assert(elemOrNodal.compare("elem") == 0 || elemOrNodal.compare("nodal") == 0);
    assert(absOrAsIs == false || absOrAsIs == true);
    if (elemOrNodal.compare("nodal") == 0) {
        assert(x.size() == qty.size());
    } else {
        assert(x.size() == qty.size()+1);
    }
    assert((qty.size() == criterion.size()) || (criterion.size() == 1));

    if (criterion.size() == 1) {
        double val = criterion[0];
        criterion.assign(qty.size(),val);
    }
    vector<double> xlist;
    for (unsigned i = 0; i < qty.size(); ++i) {
        if (phiPos == 0) {//can't fail if phi>0
            if (elemOrNodal.compare("nodal") == 0) {
                if (phiNL[i] > 0) continue;
            } else {
                if (phiNL[i]>0 || phiNL[i+1]>0) continue;
            }
        }
        double qtyc = qty[i];
		//can't fail if already nucleated
        double minOpen = max(h,minOpenDist);
        for (unsigned j = 0; j < newSegment.size(); ++j) {
            if (nucleated == 0) continue;	// the null level-set can't be an impediment to nucleation		
            
			if (elemOrNodal.compare("nodal") == 0) {
                if (fabs(newSegment[j]->xpeak-x[i]) < minOpen) goto nextLoop;
            } else {
                double xavg = 0.5*(x[i] + x[i+1]);
                if (fabs(newSegment[j]->xpeak - xavg) < minOpen) goto nextLoop;
            }
		}

		//compare against arelady accepted nucleation sites - xlist
        for (unsigned j = 0; j < xlist.size(); ++j) {
            if (elemOrNodal.compare("nodal") == 0) {
                if (fabs(xlist[j]-x[i]) < minOpen) goto nextLoop;
            } else {
                double xavg = 0.5*(x[i] + x[i+1]);
                if (fabs(xlist[j] - xavg) < minOpen) goto nextLoop;
            }
        }
		
		if (absOrAsIs) {
            qtyc = fabs(qtyc);
        }

        if (qtyc > criterion[i]) {
            if (elemOrNodal.compare("nodal") == 0) {
                xlist.push_back(x[i]);
            } else {
                //assume middle of element
                xlist.push_back(0.5*(x[i]+x[i+1]));
            }
            margin.push_back(qtyc/criterion[i]);
            index.push_back(i);
        }
        nextLoop: //jump to here if can't nucleate
        qtyc = 0;
    }


    //limited to one nucleation per timestep - IF OneAtATime=true
    if (oneAtATime) {
        double marmax = 0;
        unsigned index = 0;
        if (xlist.size() > 0){
            for (unsigned i = 0; i < xlist.size(); ++i) {
                if (margin[i] > marmax) {
                    marmax = margin[i];
                    index = i;
                }
            }
            double temp1 = xlist[index];
            xlist.clear(); xlist.push_back(temp1);
            margin.clear(); margin.push_back(marmax);
        }
        assert(xlist.size() <= 1);
    }
    
    if (elemOrNodal.compare("elem") == 0) {
	    for (unsigned i = 0; i < xlist.size(); ++i) {
    	    criterion[index[i]] *= (1-alfa);  //modify Yc at the location of nucleation by a factor alpha : TODO is this good???
	    }
    }

    //nucleate list
    if (xlist.size() > 0) {
        vector<double> failvalueList = vector<double>(xlist.size(),failvalue);
        nucleate(t[ts],xlist,failvalueList, newSegment, elemOrNodal);
    }
	return xlist.size();
};


void PotentialAvenger::analyzeDamage(vector<double>& phiV, const double h, vector<Segment*>& newSegment) {
    //produce:
    //new phi based on distances - maxima

    //if all negative one, skip
    unsigned sum = 0;
    for (unsigned i = 0; i < phiV.size(); ++i) {
        if (phiV[i] > -1) sum++;
    }
    if (sum == 0) return;
    if (nucleated == 0) return;

    vector<double> list_max;
    vector<double> value_max;
    vector<double> slope;
    vector<double> YbarmYc;
    sort(newSegment.begin(), newSegment.end());
   
    assert(x.size() >= 1);

    //simply use pre-defined segments
    if (newSegment.size() == 0) return;
    for (unsigned i = 0; i < newSegment.size(); ++i) {
        //assert(newSegment[i].size() > 0);
        list_max.push_back(newSegment[i]->xpeak);
        value_max.push_back(newSegment[i]->phipeak);
        slope.push_back(newSegment[i]->slope);
        YbarmYc.push_back(newSegment[i]->YbarmYc);
        newSegment[i]->indices.clear();
    }

    //delete segments, make new ones
    unsigned nSegs = newSegment.size();
	for (unsigned i = 0; i < nSegs; ++i) delete newSegment[i];
    newSegment.clear();
    newSegment.resize(nSegs*2);
	for (unsigned i = 0; i < nSegs*2; ++i) newSegment[i] = new Segment(); 
	for (unsigned i = 0; i < nSegs; ++i) {
		newSegment[2*i]->YbarmYc = YbarmYc[i];
		newSegment[2*i]->slope = 1;
		newSegment[2*i+1]->YbarmYc = YbarmYc[i];
		newSegment[2*i+1]->slope = -1;
	}

    //re-define segments.indices and phi
    vector<double> phinew = vector<double>(phiV.size(),-1);
    for (unsigned i = 0; i < phiV.size(); ++i) {
        
        int segphimin = -1;
        double min = 9999999999;
        for (unsigned k = 0; k < value_max.size(); ++k) {
            if (value_max.size() > 1 && value_max[k] == 0.0) continue;
            double qty = -value_max[k] + fabs(x[i] - list_max[k]);
            if (qty < min) {
                min = qty;
                segphimin = k;
            }
        }
        assert(segphimin > -1);

        phinew[i] = -min;
       	if (x[i] < list_max[segphimin])     newSegment[2*segphimin]->indices.push_back(i);
   	    if (x[i] > list_max[segphimin])     newSegment[2*segphimin+1]->indices.push_back(i);
        if (x[i] == list_max[segphimin]) {
			if (slope[segphimin] > 0) newSegment[2*segphimin]->indices.push_back(i);
			else newSegment[2*segphimin+1]->indices.push_back(i);
		}
        //assert(newSegment[segphimin].slope != 0);
  //      phinew[i] = max(phinew[i],phiV[i]);
    }

	//make sure segments don't overlap
	for (unsigned i = 0; i < newSegment.size(); ++i) {
		if (newSegment[i]->size() == 0) continue;
		for (unsigned j = i + 1; j < newSegment.size(); ++j) {
			if (newSegment[i]->size() == 0) continue;
			if (newSegment[j]->size() == 0) continue;
			vector<int> endpoints;
			endpoints.push_back(newSegment[i]->begin());
			endpoints.push_back(newSegment[i]->end());
			endpoints.push_back(newSegment[j]->begin());
			endpoints.push_back(newSegment[j]->end());
			sort(endpoints.begin(),endpoints.end());
			int L1 = abs(static_cast<int>(newSegment[i]->begin()) - static_cast<int>(newSegment[i]->end()));	
			int L2 = abs(static_cast<int>(newSegment[j]->begin()) - static_cast<int>(newSegment[j]->end()));
			int dist = endpoints.back() - endpoints.front();
			unsigned ii = (i - (i % 2))/2;
			unsigned jj = (j - (j % 2))/2;
			//if overlap, fold segments together
			//copy indices from shorter segment to taller segment
			if (dist <= L1 + L2) {
				unsigned more, less;
				if (newSegment[i]->slope == newSegment[j]->slope) {
					if (value_max[ii] > value_max[jj]) {
						more = i;
						less = j;
					} else {
						more = j;
						less = i;
					}
				} else if (newSegment[i]->size() == 1) {
					more = j; less = i;	
				} else if (newSegment[j]->size() == 1) {
					more = i; less = j;	
				} else assert(1 == 0);	
				while(!newSegment[less]->indices.empty()) {
					unsigned index = newSegment[less]->indices.back();
					newSegment[less]->indices.pop_back();
					newSegment[more]->indices.push_back(index);
				}	
			}
		}

	}//end overlap check

    //delete empty segments
    vector<unsigned> delList;
    for (unsigned i = 0; i < newSegment.size(); ++i) {
        if (newSegment[i]->size() == 0) {                            //delete empty
            delList.push_back(i);
            continue;
        }

        assert(newSegment[i]->slope != 0);
    }
    while (delList.size() > 0) {
        unsigned index = delList.back();
        delete newSegment.at(index);
        newSegment.erase(newSegment.begin() + index);
        delList.pop_back();
    }	

    unsigned tot_indices = 0;
    for (unsigned i = 0; i < newSegment.size(); ++i) {
        setPeak(phinew,newSegment,i);
        tot_indices += newSegment[i]->size();
        if (newSegment[i]->phipeak> 0 ) assert(newSegment[i]->indices.size() <= x.size());
    }

    assert(tot_indices == x.size());

    //return phinew as phi
    for (unsigned i = 0; i < phiV.size(); ++i) {
        phiV[i] = phinew[i];
    }

    if (nucleated == 0) assert(nSegs == newSegment.size());
    
};  

void PotentialAvenger::printRunInfo() {
    cout << endl;
    cout << "Run Info:" << endl;
    cout << "Strain rate = " << strain_rate << endl;
    cout << "# Elements = " << Nelt << endl;
    cout << "End Time (s) = " << end_t << endl;
    cout << "Time-step refinement ratio = " << ts_refine << endl;
    cout << "Damage gradient length (lc) = " << lc << endl;
    cout << "Beginning run... " << endl;
    cout << endl;

};

void PotentialAvenger::plotEnergies () {
    // Gnuplot file for energies
    FILE * pFileW;
    std::string stressFile = _path+"/gnuplot/plotEnrg.plt";		//../results
    pFileW = fopen( stressFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Global energies\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"energy (J)\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgSpr.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'Wspr' w l\n" );
    fprintf( pFileW, "set output './pngFiles/enrgDissip.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:3 ti 'Wdissip' w l, \\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:8 ti 'local' w l, \\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:9 ti 'non-local' w l \n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgExt.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:4 ti 'Wext' w l\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgKin.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:5 ti 'Wkin' w l\n\n" );
    fprintf( pFileW, "set ylabel \"Energy Balance Check\"\n" );
    fprintf( pFileW, "set output './pngFiles/enrgBalance.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:(abs($7)) ti 'Wsum' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:6 ti '0.01 * Wmax' w l\n\n" );
    fprintf( pFileW, "set ylabel \"J/s\"\n" );

    fprintf( pFileW, "set output './pngFiles/enrgAll.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'Wspr' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:3 ti 'Wdis' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:4 ti 'Wext' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:5 ti 'Wkin' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:(abs($2+$3+$5)) ti 'Wsum' w l\n\n");

	
    fprintf( pFileW, "set output './pngFiles/phidotC.svg'\n");
    fprintf( pFileW, "set ylabel \"damage front speed phidot/c\"\n" );
    fprintf( pFileW, "plot for [i=10:100] './datFiles/energies.dat' usi 1:i title \"Segment \".(i-9) w l \n");

    fclose( pFileW );

    // Prepare Gnuplot data file
    _EnrgFile = _path+"/datFiles/energies.dat";		//../results
    FILE * pFile;
    pFile = fopen( _EnrgFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Total energies for the system\n" );
    fprintf( pFile, "#       time        Wspr        Wdis        Wext");
    fprintf( pFile, "        Wkin   0.01*Wmax        Wsum     WdisLoc     WdisTLS" );
    for (unsigned i = 1; i <= 100; ++i) fprintf( pFile, "   Segment %u", i); 
    fprintf( pFile, "\n");
    fclose( pFile );
}

void PotentialAvenger::plotFrags (){
    // Gnuplot file for fragmentation
    FILE * pFileW;
    std::string fragFile = _path+"/gnuplot/plotFragInfo.plt";		//../results
    pFileW = fopen( fragFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Fragmentation Information\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"Number of Fragments\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/numFrag.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraginfo.dat' usi 1:3 ti 'Sum of Damage' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/fraginfo.dat' usi 1:2 ti '# Frags' w l\n\n" );

    fclose( pFileW );

    // Prepare Gnuplot data file
    _FragFile = _path+"/datFiles/fraginfo.dat";		//../results
    FILE * pFile;
    pFile = fopen( _FragFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#       time      #frags   DamageSum        Mean      Median         Max         Min");
    fprintf( pFile, "       StDev       Range        Skew    Ex. Kurt.");
    fprintf( pFile, "((R*L^2)/|L|) (Locations)\n");
    fclose( pFile );
}

void PotentialAvenger::plotHisto () {
    // Gnuplot file for fragmentation histogram
    FILE * pFileW;
    std::string histoFile = _path+"/gnuplot/plotHisto.plt";		//../results
    pFileW = fopen( histoFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "set title \"Fragment Length CDF Graph\"\n"); 
    fprintf( pFileW, "set xlabel \"Fragment Length, Lf (m)\"\n" );
    fprintf( pFileW, "set ylabel \"# ( Length > Lf )\"\n" );
    if (_numFrag > 0) fprintf( pFileW, "set yrange [0:%u]\n", _numFrag);
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/fraginvcdf.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' usi 1:2 ti '' w l;\n\n" );
    fprintf( pFileW, "set boxwidth 0.9 absolute\n" );
    fprintf( pFileW, "set style fill   solid 1.00 border -1\n" );
    fprintf( pFileW, "set title \"Fragmentation Histogram\"\n"); 
    fprintf( pFileW, "set xlabel \"Size Distribution Relative to Max. Frag. Size (Percent)\"\n" );
    fprintf( pFileW, "set ylabel \"Frequency\"\n" );
    fprintf( pFileW, "set xrange [0:100]\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/fragHisto.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' using 3:4:(4) ti '' with boxes;\n" );
    fclose( pFileW );

    // Prepare Gnuplot data file
    _HistoFile = _path+"/datFiles/fraghisto.dat";		//../results
    FILE * pFile;
    pFile = fopen( _HistoFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#Length, Lf   # With Length > Lf   Bin Center   Frequency\n" );
    fclose( pFile );
}

void PotentialAvenger::plotSTheta () {
	// Gnuplot file for fragmentation histogram
	FILE * pFileW;
	std::string sThetaFile = _path+"/gnuplot/plotSTheta.plt";	//../results/
	pFileW = fopen( sThetaFile.c_str(), "w" );
	fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
	fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
	fprintf( pFileW, " -- MH[DCML] (2010)\n");
	fprintf( pFileW, "datafile = './datFiles/stresstheta.dat'\n");
	fprintf( pFileW, "stats datafile;\n");
	fprintf( pFileW, "set title \"Cohesive Link Stress vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaCL.svg'\n");
	fprintf( pFileW, "plot for[i=1:1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 4:5 ti 'Link Stress' w l;\n\n" );
	fprintf( pFileW, "set title \"Spring Element Stress vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaSE.svg'\n");
	fprintf( pFileW, "plot for[i=1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 2:3 ti 'Spring Stress' w l;\n\n" );
	fprintf( pFileW, "set title \"Cohesive Link Damage vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Damage\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaCLD.svg'\n");
	fprintf( pFileW, "plot for[i=1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 4:6 ti 'Damage' w l;\n\n" );
	fclose( pFileW );

    // Prepare Gnuplot data file
	_SThetaFile = _path+"/datFiles/stresstheta.dat";		//../results

    FILE * pFile;
    pFile = fopen( _SThetaFile.c_str(), "w" );
    	fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#Time       SprTheta    SprStress   CohTheta    CohStress           i         _Nt\n" );
    fclose( pFile );
}

/*------------------------------ P R I V A T E -------------------------------*/


void PotentialAvenger::printVtk ( const unsigned timStepNum ) const {

    // Build a name for the vtk file
    std::string resuPath = _path+"/vtkFiles/";			//../results
    unsigned zeroNum = 6 - (unsigned) floor( log10( timStepNum ) );
    std::string baseName = "ring_";//+ convertInt(_myid) + "_";
    for ( unsigned i = 0; i < zeroNum; i++ ) {
        baseName += "0";
    }
    baseName += convertInt(timStepNum);
    std::string vtkFile = resuPath + baseName + ".vtk";

    // Print in the vtk file
    printHeader ( vtkFile );
    unsigned Ncell = printMesh ( vtkFile );
    printPointData ( vtkFile );
    printCellData ( vtkFile, Ncell );
}

void PotentialAvenger::printHeader ( const std::string& vtkFile ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "w" );
    fprintf ( pFile, "# vtk DataFile Version 2.0\n" );
    fprintf ( pFile, "Generated by <ring.h> -- MH [DCML] (2010)\n" );
    fprintf ( pFile, "ASCII\nDATASET UNSTRUCTURED_GRID\n\n" );
    fclose( pFile );
}

unsigned PotentialAvenger::printMesh ( const std::string& vtkFile ) const {
    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    fprintf ( pFile, "POINTS %d float\n", Nnod);
    for ( unsigned i = 0; i < Nnod; i++ ) {
        double xx = x[i];			//NodPos
        double y = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", xx, y, 0.0 );
    }

    unsigned Ncell = 0;
    if (visualizeCracks) {
        for ( unsigned i = 0; i < Nelt; i++ ) {
	    	if (d[i] < 1) Ncell++;
    	} 
    } else {
        Ncell = Nelt;
    }

    fprintf ( pFile, "\nCELLS %d %d\n", Ncell, 3*Ncell );
    for ( unsigned i = 0; i < Nelt; i++ ) {
        if (d[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12d %12d %12d\n", 2, i, i+1 );
    }
    fprintf ( pFile, "\nCELL_TYPES %d\n", Ncell );
    for ( unsigned i = 0; i < Nelt; i++ ) {
        if (d[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12d\n", 3 );
    }
    fprintf ( pFile, "\n" );
    fclose( pFile );

    return Ncell;
}

void PotentialAvenger::printPointData ( const std::string& vtkFile ) const {
    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    //int pointData = _NodPos.size();

    fprintf ( pFile, "POINT_DATA %d", Nnod);
    fprintf ( pFile, "\nVECTORS displacements float\n" );
    for ( unsigned i = 0; i < u.size(); i++ ) {
        double dx = printable(u[i]);	//Dis[i][0][0]
        double dy = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", dx, dy, 0.0 );
    }
    fprintf ( pFile, "\nVECTORS velocities float\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) {
        double vx = printable(v[i]);
        double vy = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", vx, vy, 0.0 );
    }
    fprintf ( pFile, "\n" );

    fprintf ( pFile, "\nSCALARS phiNL float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) fprintf ( pFile, " %12.3e \n", printable(phiNL[i]));
    fprintf ( pFile, "\n" );
    
    fprintf ( pFile, "\nSCALARS inTLSnode int\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) fprintf ( pFile, " %u \n", inTLSnode[i]);
    fprintf ( pFile, "\n" );
    
    fprintf ( pFile, "\nSCALARS absGradPhiL float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nnod; i++ ) fprintf ( pFile, " %12.3e \n", printable(fabs(gradPhiL[i])));
    fprintf ( pFile, "\n" );
    
    fprintf ( pFile, "\nSCALARS absGradPhiNL float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nnod; i++ ) fprintf ( pFile, " %12.3e \n", printable(fabs(gradPhiNL[i])));
    fprintf ( pFile, "\n" );
    
    fclose( pFile );
}

void PotentialAvenger::printCellData ( const std::string& vtkFile, const unsigned& Ncell ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    fprintf( pFile, "CELL_DATA %d", Ncell );

    fprintf ( pFile, "\nSCALARS absGradPhiNLelem float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) fprintf ( pFile, " %12.3e \n", printable(fabs(gradPhiNLelem[i])));
    fprintf ( pFile, "\n" );	

    fprintf ( pFile, "\nSCALARS phiL float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) fprintf ( pFile, " %12.3e \n", printable(phiL[i]));
    fprintf ( pFile, "\n" );
    
    fprintf( pFile, "\nSCALARS stress float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", printable(s[i]));
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS strain float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e\n", printable(e[i]));
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS Yraw/Yc float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", printable(e[i]*e[i]*E*0.5/Yc));
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS Y/Yc float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", printable(Y[i]/Yc));
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS Ybar/Yc float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", printable(Ybar[i]));
    fprintf( pFile, "\n" );

    fprintf ( pFile, "\nSCALARS damage float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12.3e \n", printable(d[i]));
    fprintf ( pFile, "\n" );

	
    fprintf ( pFile, "\nSCALARS damageRate float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12.3e \n", printable((d[i] - d_1[i]) / dt));
    fprintf ( pFile, "\n" );

    fprintf( pFile, "\nSCALARS inTLS int\n");
    fprintf( pFile, "LOOKUP_TABLE default\n");
    for ( unsigned i = 0; i < Nelt; i++) if (d[i] < 1 || visualizeCracks == 0) fprintf(pFile, "%u \n", inTLS[i]);
    fprintf( pFile, "\n");

    fclose( pFile );
}

void PotentialAvenger::printGlobalInfo () const {

    if ( _EnrgFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _EnrgFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", t[_Nt] );
        fprintf( pFile, "%12.3e", strain_energy );
        fprintf( pFile, "%12.3e", dissip_energy );
        fprintf( pFile, "%12.3e", ext_energy );
        fprintf( pFile, "%12.3e", kinetic_energy );
	fprintf( pFile, "%12.3e", max_energy * 0.01 );
	fprintf( pFile, "%12.3e", tot_energy );
	fprintf( pFile, "%12.3e", dissip_energy_local );
	fprintf( pFile, "%12.3e", dissip_energy_TLS );
	for (unsigned i = 0; i < phidot[_Nt].size(); ++i) fprintf( pFile, "%12.3e", phidot[_Nt].at(i)/sqrt(E/rho)  );
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::printFrags (const vector<double>& fragLength) {
    double DSum = 0.0;
    for (unsigned i = 0; i < d.size(); ++i) DSum += d[i];

    if ( _FragFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _FragFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", t[_Nt] );
        fprintf( pFile, "%12u", _numFrag );
        fprintf( pFile, "%12.3f", DSum );
        fprintf( pFile, "%12.3e", _fMean );
        fprintf( pFile, "%12.3e", _fMed );
        fprintf( pFile, "%12.3e", _fMax );
	fprintf( pFile, "%12.3e", _fMin );
	fprintf( pFile, "%12.3e", _fStDev );
	fprintf( pFile, "%12.3e", _fRange );
	fprintf( pFile, "%12.3f", _fSkew );
	fprintf( pFile, "%12.3f", _fExKurtosis );
	if (_numFrag <= 10){
	    for (unsigned i = 0; i < fragLength.size(); i++){
		fprintf( pFile, "%12f", fragLength[i] );
	    }
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::printSTheta () {
    if ( _SThetaFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _SThetaFile.c_str(), "a" );
        //fprintf( pFile, "%12.3e", _T );
	for (unsigned i = 0; i < Nelt; i++) {
	    double sprTheta = (double)(360*(i+0.5))/(double)(Nelt);
	    double cohTheta = (double)(360*(i+1))/(double)(Nelt);
	    fprintf( pFile, "%12.3e", t[_Nt] );
	    fprintf( pFile, "%12.3f", sprTheta );
        fprintf( pFile, "%12.3e", s[i] );
        fprintf( pFile, "%12.3f", cohTheta );
//        fprintf( pFile, "%12.3e", _sigCoh[i] );
        fprintf( pFile, "%12.3e", d[i] );
        fprintf( pFile, "%12.3f", (double)(i) );
        fprintf( pFile, "%12.3f", (double)(_Nt) );
	    fprintf( pFile, "\n" );
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::fragmentStats(const vector<double>& fragLength) {

    if (fragLength.size() == 0) return;

	//Initialize statistics of fragment length distribution
	_fMean = 0;
	_fMed = 0;
	_fMax = 0;
	_fMin = 0;
	_fStDev = 0;
	_fRange = 0;
	_fSkew = 0;
	_fExKurtosis = 0;

	//If there are any fragments...
	//Calculate Median
	// Sort the list in ascending order
	vector<double> fragLengthSort = fragLength;
    sort(fragLengthSort.begin(), fragLengthSort.end());

	if (fragLength.size() % 2 == 0) {
        	//If even number, take average of two middle values
		_fMed = ( fragLengthSort[ (unsigned)(fragLengthSort.size() * 0.5) ]
			+ fragLengthSort[ (unsigned)(fragLengthSort.size() * 0.5) -1 ] ) * 0.5;
	} else {
		//If odd number, take middle value
		_fMed = fragLengthSort[ (fragLengthSort.size() - 1) / 2 ];
	}
	//Calculate Max, Min, Range
	_fMax = fragLengthSort.back();
	_fMin = fragLengthSort.front();
	_fRange = _fMax - _fMin;

	//Calculate Mean
	for (unsigned k = 0; k < fragLengthSort.size(); k++){
		//Sum of lengths
		_fMean += fragLength[k];
	}
    //Mean = sum / number
	_fMean = _fMean / _numFrag;

	//Calculate Std. Deviation
	for (unsigned k = 0; k < fragLengthSort.size(); k++){
		//Sum of squared (lengths - means)
		_fStDev += pow( (fragLengthSort[k] - _fMean), 2);
	}
	_fStDev = sqrt( _fStDev / _numFrag ) ;

	//Calculate Skew
	for (unsigned k = 0; k < fragLengthSort.size(); k++){
		//Sum of squared (lengths - means)
		_fSkew += pow( (fragLengthSort[k] - _fMean), 3);
	}
	_fSkew = _fSkew / (_numFrag * pow(_fStDev,3) );

	//Calculate Kurtosis
	for (unsigned k = 0; k < fragLengthSort.size(); k++){
		//Sum of squared (lengths - means)
		_fExKurtosis += pow( (fragLengthSort[k] - _fMean), 4);
	}
	_fExKurtosis = _fExKurtosis / (_numFrag * pow(_fStDev,4) ) - 3.0;
    return;
}


void PotentialAvenger::printHisto(const std::vector<double>& fragLength) {
    // Prints Histogram and scaled 1-cdf figure
    vector<vector<double> > fragInvCDF;
    vector<unsigned> fHisto;
    vector<double> fragLengthSort = fragLength;

    if (_numFrag > 1) {

        sort(fragLengthSort.begin(), fragLengthSort.end());

		fragInvCDF.resize(2);
		fragInvCDF[0].resize(1000);	//a length, from zero to the max. fragment size
		fragInvCDF[1].resize(1000);	//number of fragments larger than this length
		fHisto.assign(25, 0);		//number of bins for the fragment histogram
	
		//Histogram - 25 bins
		 double max = _fMax;	//size
		//Step through fragment length list; increase count in the bin if fragment fits
		for (unsigned k = 0; k < fragLengthSort.size(); k++){
            double length = fragLengthSort[k];
//            if (fragment_list.size() % 2 == 1) length *= 2; //if not broken from wall, this segment has twice the length
			if (length < max * 0.04) fHisto[0]++;
			if ((length < max * 0.08) && (length >= max * 0.04)) fHisto[1]++;
			if ((length < max * 0.12) && (length >= max * 0.08)) fHisto[2]++;
			if ((length < max * 0.16) && (length >= max * 0.12)) fHisto[3]++;
			if ((length < max * 0.20) && (length >= max * 0.16)) fHisto[4]++;
			if ((length < max * 0.24) && (length >= max * 0.20)) fHisto[5]++;
			if ((length < max * 0.28) && (length >= max * 0.24)) fHisto[6]++;
			if ((length < max * 0.32) && (length >= max * 0.28)) fHisto[7]++;
			if ((length < max * 0.36) && (length >= max * 0.32)) fHisto[8]++;
			if ((length < max * 0.40) && (length >= max * 0.36)) fHisto[9]++;
			if ((length < max * 0.44) && (length >= max * 0.40)) fHisto[10]++;
			if ((length < max * 0.48) && (length >= max * 0.44)) fHisto[11]++;
			if ((length < max * 0.52) && (length >= max * 0.48)) fHisto[12]++;
			if ((length < max * 0.56) && (length >= max * 0.52)) fHisto[13]++;
			if ((length < max * 0.60) && (length >= max * 0.56)) fHisto[14]++;
			if ((length < max * 0.64) && (length >= max * 0.60)) fHisto[15]++;
			if ((length < max * 0.68) && (length >= max * 0.64)) fHisto[16]++;
			if ((length < max * 0.72) && (length >= max * 0.68)) fHisto[17]++;
			if ((length < max * 0.76) && (length >= max * 0.72)) fHisto[18]++;
			if ((length < max * 0.80) && (length >= max * 0.76)) fHisto[19]++;
			if ((length < max * 0.84) && (length >= max * 0.80)) fHisto[20]++;
			if ((length < max * 0.88) && (length >= max * 0.84)) fHisto[21]++;
			if ((length < max * 0.92) && (length >= max * 0.88)) fHisto[22]++;
			if ((length < max * 0.96) && (length >= max * 0.92)) fHisto[23]++;
			if ((length <= max) && (length >= max * 0.96)) fHisto[24]++;
		}

		//Open file to record histogram and 1-cdf data
		if ( _HistoFile.size() > 0 ) {
			FILE * pFile;
			pFile = fopen( _HistoFile.c_str(), "a" );
			double j = 0;
			for (unsigned i = 0; i < 1000; i++) {

				//grab the 1-cdf data; 
				unsigned count = 0;
				j = max * (static_cast<double>(i) / 1000.0);	//from 0 to max length, 1000 increments
				for (unsigned k = 0; k < fragLengthSort.size(); k++) {
                    double length = fragLengthSort[k];
					if (length > j) {		//if frag length greater than j, add to count
						count += 1;
					}
				}
		
				//save to vector
				fragInvCDF[0][i] = j;
				fragInvCDF[1][i] = (double)count;
				fprintf( pFile, "%6.3e %u", j, count);		//print to file

				//print histogram info to file - relative size (% of max frag length) & count
				if (i < 25) {	//piggybacking the for loop, only need the first 25
					fprintf( pFile, " %f %u", (double)(i*4+2), fHisto[i] );
				} else {
					fprintf( pFile, " 0 0");
				}
				fprintf( pFile, "\n" );
			}

			//print raw fragment sizes to file
			fprintf( pFile, "# Sizes: \n" );
			for (unsigned k = 0; k < fragLength.size(); k++){
                double length = fragLength[k];
				fprintf( pFile, "%12.3e \n", length );
			}

			fclose( pFile );
		}
    }
    return;
}


void PotentialAvenger::printClean () const {
    std::string cleanPath = _path+"/clean.sh";
    FILE * pFile;
    pFile = fopen( cleanPath.c_str(), "w" );
    fprintf( pFile, "#!/bin/bash\n\n" );
    fprintf( pFile, "# Go to results directory\n" );
    fprintf( pFile, "cd %s\n\n", _path.c_str() );
    fprintf( pFile, "# Remove the data files\n" );
    fprintf( pFile, "cd ./datFiles/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "cd ./automatedRuns/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "# Remove the gnuplot files\n" );
    fprintf( pFile, "cd ./gnuplot/ ; rm *.plt; cd -\n\n" );
    fprintf( pFile, "# Remove the png/svg files\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.png; cd -\n\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.svg; cd -\n\n" );
    fprintf( pFile, "# Remove the vtk files\n" );
    fprintf( pFile, "cd ./vtkFiles/; find . -name \"*.vtk\" -print0 | xargs -0 rm -f; cd -\n\n" );
    fprintf( pFile, "# Remove plot.sh\n" );
    fprintf( pFile, "rm plot.sh\n" );
    fclose( pFile );
    std::string shellCmd = "chmod u+x " + cleanPath;
    //int status = system( shellCmd.c_str() );
	system( shellCmd.c_str() );

    shellCmd = "./" + cleanPath;
	system( shellCmd.c_str() );

}

