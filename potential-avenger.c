//potential-avenger.c
//Andrew Stershic
//DCML, Duke University
//(c) 2013, 2014

#include <potential-avenger.h>
#include <math.h>
#include <sys/stat.h>

using namespace std;

int main(int argc, const char* argv[]) {
    assert(argc == 14);

    double strain_rate = atof(argv[1]);
    double ts_refine = atof(argv[2]);
    double end_t = atof(argv[3]);
    unsigned Nelt = atoi(argv[4]);
    double lc = atof(argv[5]);
    unsigned intOrder = atoi(argv[6]);
    unsigned printVTK = atoi(argv[7]);
    int oneAtATime = atoi(argv[8]);
    double minOpenDist = atof(argv[9]);
	double alpha = atof(argv[10]);
    unsigned localOnly = atoi(argv[11]);
    unsigned visualizeCracks = atoi(argv[12]);
    unsigned fullCompression = atoi(argv[13]);
    string path = ".";

    PotentialAvenger pa = PotentialAvenger(strain_rate, ts_refine, end_t, Nelt, lc, intOrder, printVTK, oneAtATime, minOpenDist, alpha, localOnly, visualizeCracks, fullCompression, path);
    pa.run();
}

PotentialAvenger::PotentialAvenger(double& in0, double& in1, double& in2, unsigned& in3, double& in4, unsigned& in5, unsigned& in6, int& in7, double& in8, double& in9, unsigned& in10, unsigned& in11, unsigned& in12, string& path){
    strain_rate = in0;
    ts_refine = in1;
    end_t = in2;
    Nelt = in3;
    lc = in4;
    intOrder = in5;
    printVTK = in6;
    oneAtATime = in7;
    minOpenDist = in8;
	alpha = in9;
    localOnly = in10;
    visualizeCracks = in11;
    fullCompression = in12;
    _path = path + "/results";

    //make plot files
    printClean();
	plotEnergies();
    plotFrags();
    plotHisto();
    plotSTheta();

};

PotentialAvenger::~PotentialAvenger(){
// create a plot file if necessary
    std::string plotFil = _path+"/plot.sh";		//"../results/plot.sh"
    FILE * pFileP;
    pFileP = fopen( plotFil.c_str(), "w" );
    fprintf( pFileP, "#!/bin/bash\n" );
    fprintf( pFileP, "# shell script generated by <ring.h>" );
    fprintf( pFileP, " -- MH [DCML] (2010)\n\n" );
    if ( _EnrgFile.size() != 0 ) {
        std::string enrgFil = "./gnuplot/plotEnrg.plt";
        fprintf( pFileP, "gnuplot %s\n", enrgFil.c_str() );
    }
    if ( _FragFile.size() != 0 ) {
        std::string fragFil = "./gnuplot/plotFragInfo.plt";
        fprintf( pFileP, "gnuplot %s\n", fragFil.c_str() );
    }
    if ( _HistoFile.size() != 0 ) {
        std::string histoFil = "./gnuplot/plotHisto.plt";
        fprintf( pFileP, "gnuplot %s\n", histoFil.c_str() );
    }
    if ( _SThetaFile.size() != 0 ) {
        std::string sThetaFil = "./gnuplot/plotSTheta.plt";
        fprintf( pFileP, "gnuplot %s\n", sThetaFil.c_str() );
    }
    fprintf( pFileP, "\n/usr/bin/open -a \"/Applications/Google Chrome.app\" ./pngFiles/*.svg &\n" );
    fclose( pFileP );
    chmod( plotFil.c_str(), 0775 );

};

unsigned min(const vector<unsigned> in) {
    assert(in.size() > 0);
    unsigned min = in[0];
    for (unsigned i = 1; i < in.size(); ++i) {
        if (in[i] < min) min = in[1];
    }
    return min;
}

unsigned max(const vector<unsigned> in) {
    assert(in.size() > 0);
    unsigned max = in[0];
    for (unsigned i = 1; i < in.size(); ++i) {
        if (in[i] > max) max = in[1];
    }
    return max;
}

double dotProduct(const vector<double> a, const vector<double> b) {
    double sum = 0;
    assert(a.size() == b.size() );
    for (unsigned i = 0; i < a.size(); ++i) sum+= a[i]*b[i];
    return sum;
}

unsigned median(const vector<unsigned> in) {
    return in[(in.size()-1)/2];
}

double sum(const vector<double> in) {
    return dotProduct(in,vector<double>(in.size(),1));
}


void PotentialAvenger::run() {

    printRunInfo();

    dm = DamageModel("Parabolic",lc);

    unsigned Ntim = Nelt*ts_refine*end_t;
    Nnod = Nelt+1;
    _Nt = 0;
    E = 1; //(beton)
    rho = 1; //(beton)
    A = 1; // barre de 10cm sur 10cm
    double c = sqrt(E/rho);
    L = 1;
    h = 1/static_cast<double>(Nelt); //
    double cfl = 1./ts_refine;
    dt = cfl * h/c;//
    Yc = E/10;
    ec = sqrt(2 * Yc / E);
    sigc = E * ec;

    // two gauss point on the element
    vector<double> pg(2);
    pg[0] = (1-sqrt(3)/3)/2;
    pg[1] = (1+sqrt(3)/3)/2;
    vector<double> wg(2);
    wg[0] = 0.5;
    wg[1] = 0.5;

    d = vector<double>(Nelt,0);
    d_1 = vector<double>(Nelt,0);
    d_max = vector<double>(Nelt,0);
    d_max_alt = vector<double>(Nelt,0);
    s = vector<double>(Nelt,0);
    e = vector<double>(Nelt,0);
    energy = vector<double>(Nelt,0);
    Y = vector<double>(Nelt,0);
    YmYc = vector<double>(Nelt,0);
    Ycv = vector<double>(Nelt,Yc);
    strain_energy = 0.0;
    kinetic_energy = 0.0;
    dissip_energy = 0.0;
    ext_energy = 0.0;
    tot_energy = 0.0;
    fragment_list.clear();

    //Matrix bpos = Matrix(Ntim, Nelt);
    //Matrix grad = Matrix(Ntim, Nelt);
    ustat = vector<double>(Nnod,0);
    Ystat = vector<double>(Nnod,0);
    u = vector<double>(Nnod,0);
    v = vector<double>(Nnod,0);
    a = vector<double>(Nnod,0);
    phi = vector<double>(Nnod,0);

    phi_1 = vector<double>(Nnod,0);
    phi_2 = vector<double>(Nnod,0);
    phi_3 = vector<double>(Nnod,0);
    phi_4 = vector<double>(Nnod,0);
    phi_5 = vector<double>(Nnod,0);
    phi_6 = vector<double>(Nnod,0);
    vector<double> phidot;
    //vector<double> ddotbar(Ntim,0);

    vector<unsigned> nbiter = vector<unsigned>(Ntim,0);
    nfrags = vector<unsigned>(Ntim,0);
    vector<Segment> segments;
    nucleated = 0;

    m.assign(Nnod,rho*h*A);
    m[0] = m[0]/2; m[Nnod-1] = m[Nnod-1]/2;

    //initialization
    x = vector<double>(Nnod,0);
    for (unsigned j = 0; j < Nnod; ++j) x[j] = j*h;

    xe = vector<double>(Nnod,0);
    for (unsigned j = 0; j < Nelt; ++j) xe[j] = 0.5*(x[j] + x[j+1]);

    t = vector<double>(Ntim,0);
    for (unsigned j = 0; j < Ntim; ++j) t[j] = j*dt;

    // Initially the bar is loaded and all elements are at Yc
    // A tls is placed on the first element, obviously it satifies
    //   Ybar = Yc
    // This extra damage will create new stress that are less than in the next element
    // and ill thus give an unloading wave.

    //constant strain rate applied
    double csr = strain_rate;
    bool vbc = true;
    for (unsigned j = 0; j < Nnod; ++j) v[j] = vbc*csr*x[j];

    for (unsigned j = 0; j < Nnod; ++j) {
        u[j] = x[j] * ec * L * 0.999*(1-vbc);
        ustat[j] = x[j] * ec * L * 0.999*(1-vbc);
        phi[j] = (2*h-x[j])*(1-vbc)-vbc;
    }

    Segment seg1 = Segment(x[0],phi[0],0);
    seg1.indices.push_back(0);
    segments.push_back(seg1);

    //check to see which elements are in TLS zones
    inTLS.assign(Nelt,0);
    inTLSnode.assign(Nnod,0);
    checkInTLS(segments,inTLS,inTLSnode);

    //calculate stresses
    calculateStresses(pg,wg);

    //acceleration
    a[0] = 0;
    a[Nnod-1] = 0;
    for (unsigned j = 1; j < Nnod-1; ++j)  a[j] = A*(s[j] - s[j-1]) /m[j];

    nbiter[0] = 0;
    analyzeDamage(x,phi,h,segments);
    unsigned len = 0;
    for (unsigned l = 0; l < segments.size(); ++l) {
        if (segments[l].size() == 0) continue;
        len++;
    }
    phidot.resize(len);

    //print data to file
    fragmentStats();
    calculateEnergies(0);
    if (printVTK != 0) printVtk(_Nt);
    printFrags();
    printGlobalInfo();

    //time-integration loop
    for (unsigned i = 1; i < Ntim; ++i){
        _Nt++;
//cout << "t = " << t[i] << endl;

        //Copy kinematic variables to "old"
        u_1 = vector<double>(Nnod,0); u_1 = u; u.assign(Nnod,0.0);
        vector<double> v_1 = vector<double>(Nnod,0); v_1 = v; v.assign(Nnod,0.0);
        vector<double> a_1 = vector<double>(Nnod,0); a_1 = a; a.assign(Nnod,0.0);
        d_1 = vector<double>(Nnod,0); d_1 = d; d.assign(Nnod,0.0);
        phi_6.clear(); if (i >= 6) phi_6 = phi_5;
        phi_5.clear(); if (i >= 5) phi_5 = phi_4;
        phi_4.clear(); if (i >= 4) phi_4 = phi_3;
        phi_3.clear(); if (i >= 3) phi_3 = phi_2;
        phi_2.clear(); if (i >= 2) phi_2 = phi_1;
        phi_1 = phi;


        //prediction
        for (unsigned j = 0; j < Nnod; ++j) {
            v[j]= v_1[j] + 0.5*dt*a_1[j];
            u[j]= u_1[j] + dt*v_1[j] + 0.5*dt*dt*a_1[j];
        }

        //def computation and Y update.
        for (unsigned j = 0; j < Nelt; ++j) {
            e[j] = (u[j+1] - u[j]) / h;
            //b=0.5*E*e(i,j)*e(i,j)-Yc;
        }

        // moving the localization front
        // we compute a = integral (Yn+1 - Yc) d' in the current non-local zone
        // then we compute b = (Yn+1-Yc) d' on the front
        // the shift in level set if the ratio of the two.
        if (localOnly == 0) updateLevelSet(i,nbiter,segments,pg,wg);

        //check for nucleation
        if (localOnly == 0) {
	    	if (alpha == 0) {
	    		//non-local-only model
    	        vector<double> Yin;
	            for (unsigned l = 0; l < Nelt; ++l)  Yin.push_back(0.5*E*e[l]*e[l]);
    	        string elemOrNodal="elem";
            	checkFailureCriteria(t[i],x,phi,Ycv,elemOrNodal,Yin,false,false,1.0*h,segments);//delete this 0.5*h rather than 2*h
    		} else {
		    	//local / non-local hybrid model
		    	vector<double> gradPhi(Nnod);
		    	calculateLevelSetGradient(d_1, gradPhi);
		    	string elemOrNodal = "nodal";
		    	vector<double> gradLimit(Nnod,1.0);
		    	checkFailureCriteria(t[i],x,phi,gradLimit,elemOrNodal,gradPhi,true,true, 1.0*h, segments);
		    }
        }

        //enforce phi constraints - update segments
        analyzeDamage(x,phi,h,segments);

        int index = -1;
        for (unsigned l = 0; l < segments.size(); ++l) {
            if (segments[l].size() == 0) continue;
            index++;
            //median(segments[l]);
            unsigned smid = median(segments[l].indices);

            len = 0;
            for (unsigned j = 0; j < segments.size(); ++j) {
                if (segments[j].size() == 0) continue;
                len++;
            }
            phidot.resize(len);
            phidot[index] = (phi[smid] - phi_1[smid])/dt;
            if (phidot[index] * dt > h*1.01 ) {
                printf("level-set front advancing more than one element per time-step: t=%f, segment %u , dphi/h = %f \n",t[i],l,phidot[index]*dt/h);
            }
        }


        //check to see which elements are in TLS zones
        checkInTLS(segments,inTLS,inTLSnode);
       
        calculateDmaxAlt(pg,wg); 

		//updating the stress
        calculateStresses(pg,wg);
        
    for (unsigned j = 1; j < Nnod-1; ++j)  phi[j] = max(phi[j], phi_1[j]);
		//acceleration
        if (phi[0] <= lc) a[0] = 0;
        else a[0] =  A*s[0]/m[0];
        a[Nnod-1] = 0; //note: this is a constraint which was hidden. if free, it would be -s(i,Nnod)/m(j);
        for (unsigned j = 1; j < Nnod - 1; ++j) a[j] = A*(s[j] - s[j-1]) /m[j];

        //correction
        for (unsigned j = 0; j < Nnod; ++j) v[j]= v[j] + 0.5*dt*a[j];

        //record number of fragments and quantities per fragment
        fragment_list.clear();
        findFragments(dm, segments,phi,nfrags[i],fragment_list);
        _numFrag = nfrags[i];

        //calculate energies
        calculateEnergies(i);

		//print the rest of the table/graph data
        if (printVTK != 0) if ( ( _Nt % printVTK) == 0 ) {printVtk(_Nt); cout << "*t = " << t[i] << endl;}
        fragmentStats();
        printFrags();
        printGlobalInfo();

    }//end time-loop


    double minfrag = _fMin;
    double sumfrag = 0;
    for (unsigned i = 0; i < fragment_list.size(); ++i) {
        double fragLen = fragment_list[i].length()*static_cast<double>(h) * 2.0;
        if (fragment_list[i].begin() == 0) fragLen -= h;
        if (fragment_list[i].end() == Nnod -1) fragLen -= h;
        if (((fragment_list.size() % 2) == 0) || (fragment_list[i].begin() != 0)) {
            fragLen /= 2.0;
            sumfrag += fragLen;
        }

        if (fragLen < minfrag) minfrag = fragLen;

        sumfrag += fragLen;
    }

    if (nfrags[Ntim-1] > 0) assert(fabs(sumfrag - L*2) < 0.5*h);
    printf("Final number of fragments: %i \nMinimum fragment length: %f \nFinal dissipated energy: %f \n",nfrags[Ntim-1],minfrag,dissip_energy);
    
    //print histogram
    printHisto();
    return;
};

void PotentialAvenger::calculateDmaxAlt(const vector<double>& pg, const vector<double>& wg) {
    //calculate d_max_alt
    for (unsigned j = 0; j < Nelt; ++j) {
         double prop = 0.0;
         vector<double> dloc = vector<double>(2); 
         for (unsigned k = 0; k < pg.size(); ++k) {
             double philoc1 = pg[k] * phi[j] + (1-pg[k]) * phi[j+1];
             dloc[k] = 0.5 * dm.dval(philoc1);
             prop += wg[k] * dloc[k];
         }
         d_max_alt[j] = max(d_max_alt[j],prop);
    }
    return;
}

void PotentialAvenger::calculateLevelSetGradient( const vector<double>& dV, vector<double>& gradPhi) {
	//calculate the gradient of the levelset (local model). This will be used to see if the |gradPhi| > 1,
	//in which case, a non-local zone will be inserted
	assert(gradPhi.size() == Nnod);
    gradPhi[0] = 0.0; //gradient between two elements middle
    gradPhi[Nnod-1] = 0.0; //gradient between two elements middle
	for (unsigned i = 1; i < Nnod-1; ++i) {
		double phiM = dm.phi(dV[i]);
        double phiM1 = dm.phi(dV[i-1]);
		gradPhi[i] = (phiM - phiM1) / h;
	}
    return;
}

void PotentialAvenger::checkInTLS(const vector<Segment>& segments, vector<unsigned>& elem, vector<unsigned>& nodes) {
	
	elem.assign(Nelt, 0);
	nodes.assign(Nnod,0);
    //check nodes; 1 = in TLS zone, 0 = not
    if (segments.size() > 1) {
    	for (unsigned k = 0; k < segments.size(); ++k) {
            if (segments[k].phipeak <= 0.0) continue;
            for (unsigned j = 0; j < segments[k].indices.size(); ++j) {
    			nodes[segments[k].indices[j]] = 1;
            }
    	}
    }
//assert(elem.size() == inTLS.size() );
    //check elements based on node results
    for (unsigned k = 0; k < Nelt; ++k) {
        //if both nodes are not in TLS zones, then element is not in TLS zone; if one or both are in, then element is in
        if (nodes[k] == 0 && nodes[k+1] == 0) elem[k] = 0;
        else elem[k] = 1;
    }
}

void PotentialAvenger::calculateStresses(const vector<double>& pg, const vector<double>& wg) {
	//if in local, clear phi (clear if not in TLS = clear all and copy if in TLS)
    for (unsigned j = 0; j < Nnod; ++j) {
        if (inTLSnode[j] == 0 && alpha > 0.0) phi[j] = 0;
    }
    for (unsigned j = 0; j < Nelt; ++j) {
   		if ((inTLS[j] == 1 && localOnly == 0) || alpha ==0.0 ) { 	//in TLS: use non-local damage model
	        assert(pg.size() == wg.size());
	
			phi[j] = max(phi[j],phi_1[j]);	
			phi[j+1] = max(phi[j+1],phi_1[j+1]);	
	        s[j] = 0;
	        e[j] = (u[j+1] - u[j])/h;
  	    	vector<double> dloc(pg.size(),0.0);
    	    if (phi[j] > 0  && phi[j+1] > 0) {
        	    for (unsigned k = 0; k < pg.size(); ++k) {
            	    if (fabs(phi[j] - phi[j+1]) < h) {
                	    //there's a peak/anti-peak inside!
                    	double delta = 0.5*(h + phi[j+1] - phi[j]);
	                    //subdivide interval into two: [x1, x1+delta] [x1+delta, x2], effectively double number of integration points
    	                double philoc1 = pg[k] * phi[j] + (1-pg[k]) * (phi[j] + delta);
        	            double philoc2 = pg[k] * (phi[j] + delta) + (1-pg[k]) * phi[j+1];
            	        dloc[k] = 0.5 * dm.dval(philoc1) + 0.5 * dm.dval(philoc2);
                	} else {
	                    double philoc = pg[k] * phi[j] + (1-pg[k]) * phi[j+1];
    	                dloc[k] = dm.dval(philoc);
        	        }
            	    s[j] += wg[k] * (1-dloc[k]) * E * e[j];
	            }
    	    } else if  (phi[j] <= 0 && phi[j+1] <= 0) {
        	    s[j] = E * e[j];
	        } else if  (phi[j] > 0 && phi[j+1] <= 0) {
    	        double delta = fabs(phi[j]) / (fabs(phi[j])+fabs(phi[j+1]));
        	    double sloc = 0;
            	for (unsigned k = 0; k < 2; ++k) {
                	double philoc = pg[k] * phi[j];
	                dloc[k] = dm.dval(philoc);
    	            sloc += wg[k] * (1-dloc[k]) * E * e[j];
        	    }
            	s[j] = delta *  sloc +  (1-delta) * E * e[j];
	        } else if (phi[j] <= 0 && phi[j+1] > 0) {
    	        double delta = fabs(phi[j+1]) / (fabs(phi[j])+fabs(phi[j+1]));
        	    double sloc = 0;
            	for (unsigned k = 0; k < 2; ++k) {
                	double philoc = pg[k] * phi[j+1];
	                dloc[k] = dm.dval(philoc);
    	            sloc += wg[k] * (1-dloc[k]) * E * e[j];
        	    }
            	s[j] = delta *  sloc +  (1-delta) * E * e[j];
	        }

    	    d[j] = 0;
	        for (unsigned k = 0; k < pg.size(); ++k) {
    	        d[j] += wg[k] * dloc[k];
        	}
            if (d[j] > d_max[j]) d_max[j] = d[j];		//update maximum damage

			if (inTLSnode[j] + inTLSnode[j+1] == 1) {
				if (d[j] < d_max[j]) d[j] = d_max[j];
			} else {
			    if (d[j] < d_max[j]) assert(d[j] >= d_max_alt[j]);
			}

            if (fullCompression) {
                //this makes compression fully in contact no matter what the damage
                if (e[j] < 0) s[j] = e[j] * E;
            }

		} else { 		//inTLS == 0 : local damage model
			double factor = sqrt(2.0 * Yc / (E * e[j] * e[j]) ); 
            //double factor = sqrt(8.0 * Yc * Yc - 2.0 * Yc * E * e[j] * e[j]) / (E * e[j] * e[j] - 4 * Yc);
			double dee = (1.0 - fabs(factor)) / alpha;
            if (dee < 0.0) //E * e[j] * e[j] < 2.0 * Yc) 
				dee = 0.0;			//not damaged if Y < Yc
            if (dee > 1.0)
                dee = 1.0;
            unsigned nodesInTLS = 0;
            if (inTLSnode[j]) nodesInTLS++;
            if (inTLSnode[j+1]) nodesInTLS++;
            assert(nodesInTLS < 2);
            d[j] = dee;
            if (dee > d_max[j]) d_max[j] = dee;		//update maximum damage
			if (dee < d_max[j]) {dee = d_max[j]; d[j] = d_max[j];}		//damage cannot decrease
            s[j] = E * (1.0 - dee) * e[j];
            if (fullCompression) {
                //this makes compression fully in contact no matter what the damage
                if (e[j] < 0) s[j] = e[j] * E;
            }
			phi[j]						+= 0.5 * dm.phi(dee);	//give half to left node
			phi[j+1]					+= 0.5 * dm.phi(dee);	//give half to right node
            if (j == 0)			phi[j]	+= 0.5 * dm.phi(dee);	//if end, give 2 halfs to left node
            if (j == Nelt - 1)	phi[j+1]+= 0.5 * dm.phi(dee);	//if end, give 2 halfs to right node
		}
    }
    return;
}

void PotentialAvenger::calculateEnergies(const unsigned& i) {
    double dissip = 0.0;
    kinetic_energy = 0.0;

    for (unsigned j = 0; j < Nelt; ++j) {
        Y[j] = 0.5 * E * e[j] * e[j];
        YmYc[j] = Y[j]/Yc - 1;
        if (i > 0) {
            dissip += h * A * Y[j] * (d[j] - d_1[j]);
            kinetic_energy += 0.5 * h * A * rho * 0.5 *
                                ( pow(u[j] - u_1[j],2) + pow(u[j+1] - u_1[j+1],2) ) / pow(dt,2);
            //ustat(i,j+1) = ustat(i,j) + h*s(0,Nelt)/(E*(1-d(i,j)));
        } else {
            kinetic_energy += 0.5 * h * A * rho * 0.5 * ( v[j] * v[j] + v[j+1] * v[j+1]);
        }
        energy[j] = h * A * Y[j] * (1.0 - d[j]);
    }
    //ustat(i,:) *= u(1,Nnod)/ustat(i,Nnod);
    for (unsigned j = 0; j < Nelt; ++j) Ystat[j] = 0.5 * E * pow((ustat[j+1] - ustat[j])/h,2);
    dissip_energy += dissip;

    if (localOnly) {
		dissip_energy -= dissip;
		double oldDE = dissip_energy;
		dissip_energy = 0;
		//dissip_energy = sum(H(d)), H(d) = Yc*alpha*d^2 / (1 - alpha*d)
		for (unsigned j = 0; j < Nelt; ++j) dissip_energy += H(j,d[j])  * h * A ; //TODO factor of 2 here works well for balance, but why?
		dissip = dissip_energy - oldDE;
	}

    strain_energy = sum (energy);
    if (i > 0) ext_energy += (a[Nnod-1] * m[Nnod-1] + s[Nnod-2] * A) * v[Nnod-1] * dt;
    else ext_energy = dissip + strain_energy + kinetic_energy;
    tot_energy = strain_energy + kinetic_energy + dissip_energy - ext_energy;
    max_energy = max(max(kinetic_energy,dissip_energy),strain_energy);
    return;
}

std::string convertInt(unsigned number) {
    if (number == 0)
        return "0";
    string temp="";
    string returnvalue="";
	//read from back
    while (number>0)
    {
        temp+=number%10+48;
        number/=10;
    }
    for (unsigned i=0;i<temp.length();i++)
        returnvalue+=temp[temp.length()-i-1];
    return returnvalue;
}

double PotentialAvenger::H (const unsigned j, const double dee) { 
    return (Ycv[j] * alpha * dee * dee)/(1.0 - alpha * dee);
}    

double PotentialAvenger::dH (const unsigned j, const double dee) { 
    return (Ycv[j] * alpha * dee) * (2.0 - alpha * dee)/pow(1.0 - alpha * dee,2);
}    

void PotentialAvenger::updateLevelSet( const unsigned& i, vector<unsigned>& nbiter, vector<Segment>& segments, const vector<double>& pg, const vector<double>& wg ) {
    
    for (unsigned l = 0; l < segments.size(); ++l) {
        if (segments[l].size()==0) continue;//segments.erase(segments.begin()+l);
        unsigned sbegin = segments[l].begin();
        unsigned send = segments[l].end();
        
        //skip if all negative
        bool allNeg = true;
        for (unsigned k = sbegin; k <= send; ++k) {
            if (phi[k] != -1) {
                allNeg = false;
                break;
            }
        }
        if (allNeg) continue;
        
        double err_crit = 1e15;
        double dphi = 0;
        nbiter[i] = 0;
        double residu = 0;
//cout << "int: [" << sbegin << "," << send<< "]  dmax = " << dm.dval(segments[l].phipeak) << "  phimax = " << segments[l].phipeak << "  ," << 
//"  x= " << segments[l].xpeak << "   slope = " << segments[l].slope <<
//endl;

        if (segments[l].phipeak <= 0) continue;

        while (err_crit > 1.e-6) {
            nbiter[i]++;
            double residu_Y = 0; double tangent_Y = 0;
            unsigned loop_residu = 0;
            unsigned loop_tangent = 0;
            for (unsigned j = max(0,static_cast<int>(sbegin)-1); j <= min(send,Nelt-2); ++j) {
                if (j < 0) continue;
                assert(pg.size() == wg.size());
                if (phi[j] > 0 && phi[j+1] > 0) {
                    for (unsigned k = 0; k < pg.size(); ++k) {
                        double philoc = 0;
                        if (segments[l].slope == 1 && x[j+1] > segments[l].xpeak && x[j] < segments[l].xpeak) {//if peak is within element, only integrate the side with the proper slope
                            double delta = segments[l].xpeak - x[j];
                            assert(delta > 0); assert( delta < h);
                            philoc = pg[k]*(phi[j] + delta) + (1-pg[k]) * phi[j+1];              //shift quadrature to interval of interest
                        } else if (segments[l].slope == -1 && x[j+1] > segments[l].xpeak && x[j] < segments[l].xpeak) { //if peak is within element, only integrate the side with the proper slope
                            double delta = segments[l].xpeak - x[j];
                            assert(delta > 0); assert( delta < h);
                            philoc = pg[k]*phi[j] + (1-pg[k]) * (phi[j] + delta);               //shift quadrature to interval of interest
                        } else {
                            philoc = pg[k]*phi[j] + (1-pg[k]) * phi[j+1];
                        }
                        residu_Y += h * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dp(philoc);
                        tangent_Y += h * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dpp(philoc);
                    }
                    loop_residu++;
                } else if  (phi[j] > 0 && phi[j+1] <= 0) {
                    double delta = h * fabs(phi[j]) / (fabs(phi[j])+fabs(phi[j+1])); //phi>0 portion
                    for (unsigned k = 0; k < pg.size(); ++k) {
                        double philoc = pg[k] * phi[j];
                        residu_Y += delta * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dp(philoc);
                        tangent_Y += delta * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dpp(philoc);
                    }
                    loop_residu++;
                    if (delta < h) tangent_Y += (0.5 * E * e[j] * e[j] - dH(j,0.0) - Ycv[j])* dm.dp(0.);
                    else tangent_Y += (0.5 * E * e[j+1] * e[j+1] - dH(j,0.0) - Ycv[j])  * dm.dp(0.);
                       
                    loop_tangent = loop_tangent + 1;
                } else if  (phi[j] <= 0 && phi[j+1] > 0) {
                    double delta = h * fabs(phi[j+1]) / (fabs(phi[j])+fabs(phi[j+1])); //phi>0 portion
                    for (unsigned k = 0; k < pg.size(); ++k) {
                        double philoc = pg[k] * phi[j+1];
                        residu_Y += delta * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dp(philoc);
                        tangent_Y += delta * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dpp(philoc);
                    }
                    loop_residu++;
                    if (delta < h) tangent_Y += (0.5 * E * e[j] * e[j] - dH(j,0.0) - Ycv[j])* dm.dp(0.); //%todo-doublecheck this  
                    else tangent_Y += (0.5 * E * e[j] * e[j] - dH(j,0.0) - Ycv[j])  * dm.dp(0.);   //%todo-doublecheck this
                    loop_tangent++;
                    
                }
            }

if (dm.dval(segments[l].phimin) == 1 && nbiter[i] == 1) goto next;
            
            // law Ybar = Yc
            if (1==1) {
                int flag = 1; //0 is exterior (damage centered on edge of domain); 1 is interior
                if (l == 1 && segments[l].begin() == 0) flag = 0;
                if (l == segments.size()-1 && segments[l].end() == Nnod-1) flag = 0;
                  
                double phimax = phi[sbegin];
                double phimin = phi[sbegin];
                unsigned iphimax = sbegin;
                unsigned iphimin = sbegin;
                for (unsigned k = sbegin; k <= send; ++k) {
                    if (phi[k] > phimax) {
                        phimax = phi[k];
                        iphimax = k;
                    }
                    if (phi[k] < phimax) {
                        phimin = phi[k];
                        iphimin = k;
                    }
                }
                phimax = segments[l].phipeak;// + dphi;//max(0.0,dphi);
                phimin = segments[l].phimin;
if (phimin == phimax) goto next;


                double phimaxY;
                if (iphimax == Nnod-1) phimaxY = 0.5*E*pow(e[Nelt-1],2) - dH(iphimax,dm.dval(phimax)); //1/2*s(i,Nelt)*e(i,Nelt);
                else phimaxY = 0.5*E*pow(e[iphimax],2) - dH(iphimax,dm.dval(phimax));// 1/2*s(i,iphimax)*e(i,iphimax);

                double phiminY;
                if (iphimin == Nnod-1) phiminY = 0.5*E*pow(e[Nelt-1],2) - dH(iphimin, dm.dval(phimin)); //1/2*s(i,Nelt)*e(i,Nelt);
                else phiminY = 0.5*E*pow(e[iphimin],2) - dH(iphimin,dm.dval(phimin));// 1/2*s(i,iphimax)*e(i,iphimax);
                    
                double YbarmYc = residu_Y/(dm.dval(phimax)-dm.dval(phimin));
                double oldresidu = residu;
                residu = YbarmYc/Yc;
                err_crit = fabs(residu-oldresidu);
                double tangent = (tangent_Y + (phiminY-Yc)*dm.dp(phimin) )/( Yc*( dm.dval(phimax)-dm.dval(phimin) ) ) - dm.dp(phimax)/pow(dm.dval(phimax)-dm.dval(phimin),2) * (YbarmYc/Yc);
                if (flag) tangent = (tangent_Y + 0.5*(phiminY-Yc)*dm.dp(phimin) - 0.5*(phimaxY-Yc)*dm.dp(phimax) )/( Yc*(dm.dval(phimax)-dm.dval(phimin)) ) - (dm.dp(phimax) - dm.dp(phimin) )/pow(dm.dval(phimax)-dm.dval(phimin),2) * (YbarmYc/Yc);
                //double tangent = (tangent_Y + static_cast<double>(flag)*(phimaxY-Yc[iphimax])*dm.dp(phimax)/2.0)/( Yc*(dm.dval(phimax)-dm.dval(phimin)) ) - ((1.0+static_cast<double>(flag)/2.0)*dm.dp(phimax)/pow(dm.dval(phimax)-dm.dval(phimin),2)) * (YbarmYc/Yc);
                if (fabs(tangent) <= 1.e-10) {
                    err_crit = 0.; dphi = 0.;
                } else {
                    dphi = - residu/tangent;
                }
            }

//cout << "dphi = " << dphi;
            if (nbiter[i] > 50) {
                dphi = 0;
                    //assert(1==0);
            }
            
            if (isnan(dphi)) {
                dphi = 0;
                assert(1==0);                
            }

            for (unsigned j = sbegin; j <=send; ++j) {
                if (i > 5 && intOrder >= 6) {
                    vector<double> w;
                    w.push_back(60./147); w.push_back(360./147); w.push_back(-450./147); w.push_back(400./147);
                    w.push_back(-225./147); w.push_back(72./147); w.push_back(-10./147); 
                    vector<double> phihist;
                    phihist.push_back(dphi); phihist.push_back(phi_1[j]); phihist.push_back(phi_2[j]);
                    phihist.push_back(phi_3[j]); phihist.push_back(phi_4[j]); phihist.push_back(phi_5[j]);
                    phihist.push_back(phi_6[j]);
                    phi[j] = dotProduct(phihist,w);
                } else if (i > 4 && intOrder >= 5) {
                    vector<double> w;
                    w.push_back(60./137); w.push_back(300./137); w.push_back(-300./137); w.push_back(200./137);
                    w.push_back(-75./137); w.push_back(12./137);
                    vector<double> phihist;
                    phihist.push_back(dphi); phihist.push_back(phi_1[j]); phihist.push_back(phi_2[j]);
                    phihist.push_back(phi_3[j]); phihist.push_back(phi_4[j]); phihist.push_back(phi_5[j]);
                    phi[j] = dotProduct(phihist,w);
                } else if (i > 3 && intOrder >= 4) {
                    vector<double> w;
                    w.push_back(12./25); w.push_back(48./25); w.push_back(-36./25); w.push_back(16./25);
                    w.push_back(-3./25);
                    vector<double> phihist;
                    phihist.push_back(dphi); phihist.push_back(phi_1[j]); phihist.push_back(phi_2[j]);
                    phihist.push_back(phi_3[j]); phihist.push_back(phi_4[j]);
                    phi[j] = dotProduct(phihist,w);
                } else if (i > 2 && intOrder >= 3) {
                    vector<double> w;
                    w.push_back(6./11); w.push_back(18./11); w.push_back(-9./11); w.push_back(2./11);
                    vector<double> phihist;
                    phihist.push_back(dphi); phihist.push_back(phi_1[j]); phihist.push_back(phi_2[j]);
                    phihist.push_back(phi_3[j]);
                    phi[j] = dotProduct(phihist,w);
                } else if (i > 1 && intOrder >= 2) {
                    vector<double> w;
                    w.push_back(2./3); w.push_back(4./3); w.push_back(-1./3);
                    vector<double> phihist;
                    phihist.push_back(dphi); phihist.push_back(phi_1[j]); phihist.push_back(phi_2[j]);
                    phi[j] = dotProduct(phihist,w);
                } else {
                    phi[j] = phi_1[j] + dphi;
                }
                phi[j] = max(phi[j],phi_1[j]); //constraint: dphi >= 0
                //enforcing limit of level-set motion
                //phi[j] = min(phi_1[j]+h,phi[j]);
            }
        } //while
        
        next:
        err_crit = 0.0;
        segments[l].setPeak(x,phi); //segments[l].phipeak += dphi; 

    } //for segments

    return;
}

void PotentialAvenger::nucleate(const double t, const std::vector<double>& x, std::vector<double>& phi, const std::vector<double>& xnuc, const std::vector<double>& phinuc, std::vector<Segment>& newSegment, const std::string& elemOrNodal){
    //t      -time
    //x      -mesh
    //phi    -level-set calculated at this time-step
    //xnuc   -location(s) of localizations to be nucleated
    //phinuc -amount of the level-set to be set at nucleated localizations

    assert(xnuc.size() == phinuc.size());
    assert(xnuc.size() > 0);

    for (unsigned j = 0; j < xnuc.size(); ++j) {
        double h = 0;
        int loc = -1;
        double delta = 0;
        nucleated++;
        
        for (unsigned i = 0; i < x.size()-1; ++i) {
            if ((xnuc[j] >= x[i]) && (xnuc[j] < x[i+1])) {
                loc = i;
                h = x[i+1] - x[i];                
                delta = (xnuc[j] - x[i])/h;
                break;
            }

        }
    
        assert(loc != -1);
        double proposed1 = phinuc[j] - delta*h;
        double proposed2 = phinuc[j] - (1-delta)*h;
        if (elemOrNodal.compare("nodal") == 0) {
			assert(delta == 0.0);

            inTLSnode[loc] = 1;
            inTLS[loc] = 1;
            if (loc > 0) inTLS[loc-1] = 1;
            if (loc > 0) inTLSnode[loc-1] = 1;
            inTLSnode[loc+1] = 1;
        
            double gradient = 0;
            assert(loc >= 1);
            if (d_1[loc] > d_1[loc-1]) gradient = 1.0;
            if (d_1[loc] < d_1[loc-1]) gradient = -1.0;
            assert(gradient != 0);
	        if (gradient == 1.0) {
				double dcrit = d_1[loc];
				phi[loc+1] = max(phi[loc+1], dm.phi(dcrit));
				phi[loc] = max(phi[loc], dm.phi(dcrit));
				phi[loc-1] = max(phi[loc-1], phi[loc] - h);
    	    } else {
				double dcrit = d_1[loc-1];
				phi[loc-1] = max(phi[loc-1], dm.phi(dcrit));
				phi[loc] = max(phi[loc], dm.phi(dcrit));
				phi[loc+1] = max(phi[loc+1], phi[loc] - h);
        	}

        } else {
			inTLSnode[loc] = 1;
			inTLSnode[loc+1] = 1;
			inTLS[loc] = 1;
			proposed1 = max(proposed1, dm.phi(d_1[loc]));	
			proposed2 = max(proposed2, dm.phi(d_1[loc]));
			if (loc > 0) proposed1 = max(proposed1, dm.phi(d_1[loc-1]));	
			if (loc > 0) proposed2 = max(proposed2, dm.phi(d_1[loc-1]));	
			if (loc < Nnod-1) proposed1 = max(proposed1, dm.phi(d_1[loc+1]));	
			if (loc < Nnod-1) proposed2 = max(proposed2, dm.phi(d_1[loc+1]));	
            phi[loc] = max(phi[loc], proposed1);
            phi[loc+1] = max(phi[loc+1], proposed2);
        }
        printf("crack nucleated, t = %f, x = %f \n",t,xnuc[j]);
        double zero = 0;
        
        //create two new segments
        if (xnuc[j] > x[0]) {
            Segment seg1 = Segment(xnuc[j]-delta*h*zero,phinuc[j]-delta*h*zero,-1);
            seg1.indices.push_back(loc);
            newSegment.push_back(seg1);
        }
        if (xnuc[j] < x[x.size()-1]) {
            Segment seg2 = Segment(xnuc[j]+(1-delta)*h*zero,phinuc[j]-(1-delta)*h*zero,1);
            seg2.indices.push_back(loc+1);
            newSegment.push_back(seg2);
        }
        //now that there has been nucleation, get rid of zero-slope segments
        vector<unsigned> delList;
        for (unsigned i = 0; i < newSegment.size(); ++i) {
            if (newSegment[i].slope == 0 || newSegment[i].phipeak == -1) delList.push_back(i);
        }
        while (delList.size() > 0) {
            unsigned index = delList[delList.size()-1]; 
            newSegment.erase(newSegment.begin() + index);
            delList.pop_back();
        }

    }
};

void PotentialAvenger::findFragments(DamageModel& dm, std::vector<Segment>& newSegment, const std::vector<double>& phi, unsigned& nfrags, std::vector<Fragment>& fragment_list) {

    fragment_list.clear();

    sort(newSegment.begin(),newSegment.end());

    Fragment f = Fragment();
    for (unsigned i = 0; i < newSegment.size(); ++i) {

        if (newSegment[i].size() == 0) continue;
        f.add(&newSegment[i]);
        double phimax = newSegment[i].phipeak;
        double slope = newSegment[i].slope;
//    cout << "i = " << i << " [" << newSegment[i].begin() << "," << newSegment[i].end() << "]  slope = " << slope << " dval_max = " << dm.dval(phimax) << endl;
        if ((slope == 1 && phimax >= lc-h) || newSegment[i].end()  == Nnod - 1) {
            fragment_list.push_back(f);
            f.clear(); f = Fragment();
        } else {}
            //cout << slope << " , " << dm.dval(phimax) << endl;
    }
    
    //calculate total number of fragments (removing symmetry simplification)
    if (fragment_list.size() == 0) {nfrags = 0; return;};
    nfrags = fragment_list.size()*2;
    if (dm.dval(phi[0]) < 1.0) {
        nfrags = nfrags - 1;
    }

    if (localOnly) {
        nfrags = 1;
        for (unsigned i = 0; i < Nelt; ++i) {
			if (d[i] >= 1.0) {
				nfrags += 2;
				if (i == 0) nfrags -= 1;
			}
        }
    }
};

void PotentialAvenger::checkFailureCriteria(const double t, const std::vector<double>& x, std::vector<double>& phi, std::vector<double>& criterion, const std::string elemOrNodal, const std::vector<double>& qty, const bool absOrAsIs, const bool phiPos, const double failvalue, std::vector<Segment>& newSegment){

    //x              -mesh
    //phi            -level-set calculated at this time-step
    //criterion      -criterion to compare against for failure
    //elemOrNodal    -either 'elem' or 'nodal' - is criterion elemental or nodal
    //qty            -the quantity to be compared to the criterion -e.g. s,Y
    //absOrAsIs      -whether to compare (0) qty or (1) abs(qty) to criterion
    //phiPos         -whether(1) or not(0) failure cannot occur depending on if phi>0
    //failvalue      -what to call phi at localization zone if created - e.g. h
    //failure if qty > criterion

    vector<double> margin;
    vector<unsigned> index;

    assert(elemOrNodal.compare("elem") == 0 || elemOrNodal.compare("nodal") == 0);
    assert(absOrAsIs == false || absOrAsIs == true);
    if (elemOrNodal.compare("nodal") == 0) {
        assert(x.size() == qty.size());
    } else {
        assert(x.size() == qty.size()+1);
    }
    assert((qty.size() == criterion.size()) || (criterion.size() == 1));

    if (criterion.size() == 1) {
        double val = criterion[0];
        criterion.assign(qty.size(),val);
    }
    vector<double> xlist;
    for (unsigned i = 0; i < qty.size(); ++i) {
        if (phiPos == 0) {//can't fail if phi>0
            if (elemOrNodal.compare("nodal") == 0) {
                if (phi[i] > 0) continue;
            } else {
                if (phi[i]>0 || phi[i+1]>0) continue;
            }
        }
        double qtyc = qty[i];
        
		//can't fail if already nucleated
        double h = x[i+1]-x[i];
        double minOpen = max(h,minOpenDist);
        for (unsigned j = 0; j < newSegment.size(); ++j) {
            if (newSegment[j].phipeak < 0) continue; 	//the null level-set can't be an impediment to nucleation
            
			if (elemOrNodal.compare("nodal") == 0) {
                if (fabs(newSegment[j].xpeak-x[i]) < minOpen) goto nextLoop;
            } else {
                double xavg = 0.5*(x[i] + x[i+1]);
                if (fabs(newSegment[j].xpeak - xavg) < minOpen) goto nextLoop;
            }
		}

		//compare against arelady accepted nucleation sites - xlist
        for (unsigned j = 0; j < xlist.size(); ++j) {
            if (elemOrNodal.compare("nodal") == 0) {
                if (fabs(xlist[j]-x[i]) < minOpen) goto nextLoop;
            } else {
                double xavg = 0.5*(x[i] + x[i+1]);
                if (fabs(xlist[j] - xavg) < minOpen) goto nextLoop;
            }
        }
		
		if (absOrAsIs) {
            qtyc = fabs(qtyc);
        }

        if (qtyc > criterion[i]) {
            if (elemOrNodal.compare("nodal") == 0) {
                xlist.push_back(x[i]);
            } else {
                //assume middle of element
                xlist.push_back(0.5*(x[i]+x[i+1]));
            }
            margin.push_back(qtyc/criterion[i]);
            index.push_back(i);
        }
        nextLoop: //jump to here if can't nucleate
        qtyc = 0;
    }


    //limited to one nucleation per timestep - IF OneAtATime=true
    if (oneAtATime) {
        double marmax = 0;
        unsigned index = 0;
        if (xlist.size() > 0){
            for (unsigned i = 0; i < xlist.size(); ++i) {
                if (margin[i] > marmax) {
                    marmax = margin[i];
                    index = i;
                }
            }
            double temp1 = xlist[index];
            xlist.clear(); xlist.push_back(temp1);
            margin.clear(); margin.push_back(marmax);
        }
        assert(xlist.size() <= 1);
    }
    
    if (elemOrNodal.compare("elem") == 0) {
	    for (unsigned i = 0; i < xlist.size(); ++i) {
    	    criterion[index[i]] *= (1-h*1.0*sqrt(1/0.2))*(1-h*1.0*sqrt(1/0.2));  //modify Yc at the location of nucleation by a factor alpha : TODO is this good???
	    }
    }

    //nucleate list
    if (xlist.size() > 0) {
        vector<double> failvalueList = vector<double>(xlist.size(),failvalue);
        nucleate(t,x,phi,xlist,failvalueList, newSegment, elemOrNodal);
    }
};

void PotentialAvenger::analyzeDamage(const vector<double>& x, vector<double>& phiV, const double h, vector<Segment>& newSegment) {

    //produce:
    //new phi based on distances - maxima

    //if all negative one, skip
    unsigned sum = 0;
    for (unsigned i = 0; i < phiV.size(); ++i) {
        if (phiV[i] > -1) sum++;
    }
    if (sum == 0) return;
    if (nucleated == 0) return;

    vector<double> list_max;
    vector<double> value_max;
    vector<double> slope;
    sort(newSegment.begin(), newSegment.end());
   
    assert(x.size() >= 1);

    //simply use pre-defined segments
    if (newSegment.size() == 0) return;
    for (unsigned i = 0; i < newSegment.size(); ++i) {
        //assert(newSegment[i].size() > 0);
        list_max.push_back(newSegment[i].xpeak);
        value_max.push_back(newSegment[i].phipeak);
        slope.push_back(newSegment[i].slope);
        newSegment[i].indices.clear();
    }

    //delete segments, make new ones
    unsigned nSegs = newSegment.size();
    newSegment.clear();
    newSegment.resize(nSegs*2);
    vector<unsigned> removeList;

    //re-define segments.indices and phi
    vector<double> phinew = vector<double>(phi.size(),-1);
    for (unsigned i = 0; i < phi.size(); ++i) {
        
        int segphimin = -1;
        double min = 9999999999;
        for (unsigned k = 0; k < value_max.size(); ++k) {
            if (value_max.size() > 1 && value_max[k] == 0.0) continue;
            double qty = -value_max[k] + fabs(x[i] - list_max[k]);
            if (qty < min) {
                min = qty;
                segphimin = k;
            }
        }
        assert(segphimin > -1);

        phinew[i] = -min;
        if (x[i] < list_max[segphimin])     newSegment[2*segphimin].indices.push_back(i);
        if (x[i] >= list_max[segphimin])     newSegment[2*segphimin+1].indices.push_back(i);
        //assert(newSegment[segphimin].slope != 0);
        if (phiV[i] > phinew[i] && inTLSnode[i] == 0) {
//            cout << "i = " << i << " shouldn't be in TLS: phi = " << phiV[i] << " , phinew = " << phinew[i] << endl;
            removeList.push_back(i);
        }
        phinew[i] = max(phinew[i],phiV[i]);
    }

    //delete empty segments; set slope
    vector<unsigned> delList;
    for (unsigned i = 0; i < newSegment.size(); ++i) {
        if (newSegment[i].size() == 0) {                            //delete empty
            delList.push_back(i);        
            continue;
        }
        if (newSegment[i].size() == 1) {                            //delete size-1 if possible, copy index to neighbor
            unsigned index = newSegment[i].indices[0];
            unsigned mod =  2*(i % 2) - 1;
            if (newSegment[i-mod].size() > 0 )  {
                newSegment[i - mod].indices.push_back(index);
                delList.push_back(i);
                continue;
            }
        } 
        if (phinew[newSegment[i].begin()] < phinew[newSegment[i].end()]) newSegment[i].slope = 1;
        else newSegment[i].slope = -1;
    }
    while (delList.size() > 0) {
        unsigned index = delList[delList.size()-1]; 
        newSegment.erase(newSegment.begin() + index);
        delList.pop_back();
    }

    unsigned tot_indices = 0;
    for (unsigned i = 0; i < newSegment.size(); ++i) {
        newSegment[i].setPeak(x,phinew);
        tot_indices += newSegment[i].size();
        if (newSegment[i].phipeak> 0 ) assert(newSegment[i].indices.size() <= x.size());
    }

    assert(tot_indices == x.size());

    //return phinew as phi
    for (unsigned i = 0; i < phi.size(); ++i) {
        phiV[i] = phinew[i];
    }
if (nucleated == 0) assert(nSegs == newSegment.size());

   // need to remove not-in-TLS from segments 
    for (unsigned i = 0; i < removeList.size(); ++i) {
        unsigned index = removeList[i];
        for (unsigned j = 0; j < newSegment.size(); ++j) {
            for (unsigned k = 0; k < newSegment[j].indices.size(); ++k) {
				if (newSegment[j].indices[k] == index) {
					newSegment[j].indices.erase(newSegment[j].indices.begin() + k);
//					cout << "  removed index " << index << " from segment " << j << endl;
					break;
				}
            }
        }
    } 
};  

void PotentialAvenger::printRunInfo() {
    cout << endl;
    cout << "Run Info:" << endl;
    cout << "Strain rate = " << strain_rate << endl;
    cout << "# Elements = " << Nelt << endl;
    cout << "End Time (s) = " << end_t << endl;
    cout << "Time-step refinement ratio = " << ts_refine << endl;
    cout << "Damage gradient length (lc) = " << lc << endl;
    cout << "Integration Order = " << intOrder << endl;
    cout << "Beginning run... " << endl;
    cout << endl;

};

void PotentialAvenger::plotEnergies () {
    // Gnuplot file for energies
    FILE * pFileW;
    std::string stressFile = _path+"/gnuplot/plotEnrg.plt";		//../results
    pFileW = fopen( stressFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Global energies\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"energy (J)\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgSpr.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'Wspr' w l\n" );
    fprintf( pFileW, "set output './pngFiles/enrgDissip.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:3 ti 'Wdissip' w l\n" );
    fprintf( pFileW, "set output './pngFiles/enrgExt.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:4 ti 'Wext' w l\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgKin.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:5 ti 'Wkin' w l\n\n" );
    fprintf( pFileW, "set ylabel \"Energy Balance Check\"\n" );
    fprintf( pFileW, "set output './pngFiles/enrgBalance.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:(abs($7)) ti 'Wsum' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:6 ti '0.01 * Wmax' w l\n\n" );
    fprintf( pFileW, "set ylabel \"J/s\"\n" );

    fprintf( pFileW, "set output './pngFiles/enrgAll.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'Wspr' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:3 ti 'Wdis' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:4 ti 'Wext' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:5 ti 'Wkin' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:(abs($2+$3+$5)) ti 'Wsum' w l\n\n");

    fclose( pFileW );

    // Prepare Gnuplot data file
    _EnrgFile = _path+"/datFiles/energies.dat";		//../results
    FILE * pFile;
    pFile = fopen( _EnrgFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Total energies for the system\n" );
    fprintf( pFile, "#       time        Wspr        Wdis        Wext");
    fprintf( pFile, "        Wkin   0.01*Wmax        Wsum\n" );
    fclose( pFile );
}

void PotentialAvenger::plotFrags (){
    // Gnuplot file for fragmentation
    FILE * pFileW;
    std::string fragFile = _path+"/gnuplot/plotFragInfo.plt";		//../results
    pFileW = fopen( fragFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Fragmentation Information\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"Number of Fragments\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/numFrag.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraginfo.dat' usi 1:3 ti 'Sum of Damage' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/fraginfo.dat' usi 1:2 ti '# Frags' w l\n\n" );

    fclose( pFileW );

    // Prepare Gnuplot data file
    _FragFile = _path+"/datFiles/fraginfo.dat";		//../results
    FILE * pFile;
    pFile = fopen( _FragFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#       time      #frags   DamageSum        Mean      Median         Max         Min");
    fprintf( pFile, "       StDev       Range        Skew    Ex. Kurt.");
    fprintf( pFile, "((R*L^2)/|L|) (Locations)\n");
    fclose( pFile );
}

void PotentialAvenger::plotHisto () {
    // Gnuplot file for fragmentation histogram
    FILE * pFileW;
    std::string histoFile = _path+"/gnuplot/plotHisto.plt";		//../results
    pFileW = fopen( histoFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "set title \"Fragment Length CDF Graph\"\n"); 
    fprintf( pFileW, "set xlabel \"Fragment Length, Lf (m)\"\n" );
    fprintf( pFileW, "set ylabel \"# ( Length > Lf )\"\n" );
    if (_numFrag > 0) fprintf( pFileW, "set yrange [0:%u]\n", _numFrag);
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/fraginvcdf.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' usi 1:2 ti '' w l;\n\n" );
    fprintf( pFileW, "set boxwidth 0.9 absolute\n" );
    fprintf( pFileW, "set style fill   solid 1.00 border -1\n" );
    fprintf( pFileW, "set title \"Fragmentation Histogram\"\n"); 
    fprintf( pFileW, "set xlabel \"Size Distribution Relative to Max. Frag. Size (Percent)\"\n" );
    fprintf( pFileW, "set ylabel \"Frequency\"\n" );
    fprintf( pFileW, "set xrange [0:100]\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/fragHisto.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' using 3:4:(4) ti '' with boxes;\n" );
    fclose( pFileW );

    // Prepare Gnuplot data file
    _HistoFile = _path+"/datFiles/fraghisto.dat";		//../results
    FILE * pFile;
    pFile = fopen( _HistoFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#Length, Lf   # With Length > Lf   Bin Center   Frequency\n" );
    fclose( pFile );
}

void PotentialAvenger::plotSTheta () {
	// Gnuplot file for fragmentation histogram
	FILE * pFileW;
	std::string sThetaFile = _path+"/gnuplot/plotSTheta.plt";	//../results/
	pFileW = fopen( sThetaFile.c_str(), "w" );
	fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
	fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
	fprintf( pFileW, " -- MH[DCML] (2010)\n");
	fprintf( pFileW, "datafile = './datFiles/stresstheta.dat'\n");
	fprintf( pFileW, "stats datafile;\n");
	fprintf( pFileW, "set title \"Cohesive Link Stress vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaCL.svg'\n");
	fprintf( pFileW, "plot for[i=1:1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 4:5 ti 'Link Stress' w l;\n\n" );
	fprintf( pFileW, "set title \"Spring Element Stress vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaSE.svg'\n");
	fprintf( pFileW, "plot for[i=1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 2:3 ti 'Spring Stress' w l;\n\n" );
	fprintf( pFileW, "set title \"Cohesive Link Damage vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Damage\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaCLD.svg'\n");
	fprintf( pFileW, "plot for[i=1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 4:6 ti 'Damage' w l;\n\n" );
	fclose( pFileW );

    // Prepare Gnuplot data file
	_SThetaFile = _path+"/datFiles/stresstheta.dat";		//../results

    FILE * pFile;
    pFile = fopen( _SThetaFile.c_str(), "w" );
    	fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#Time       SprTheta    SprStress   CohTheta    CohStress           i         _Nt\n" );
    fclose( pFile );
}

/*------------------------------ P R I V A T E -------------------------------*/


void PotentialAvenger::printVtk ( const unsigned timStepNum ) const {

    // Build a name for the vtk file
    std::string resuPath = _path+"/vtkFiles/";			//../results
    unsigned zeroNum = 6 - (unsigned) floor( log10( timStepNum ) );
    std::string baseName = "ring_";//+ convertInt(_myid) + "_";
    for ( unsigned i = 0; i < zeroNum; i++ ) {
        baseName += "0";
    }
    baseName += convertInt(timStepNum);
    std::string vtkFile = resuPath + baseName + ".vtk";

    // Print in the vtk file
    printHeader ( vtkFile );
    unsigned Ncell = printMesh ( vtkFile );
    printPointData ( vtkFile );
    printCellData ( vtkFile, Ncell );
}

void PotentialAvenger::printHeader ( const std::string& vtkFile ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "w" );
    fprintf ( pFile, "# vtk DataFile Version 2.0\n" );
    fprintf ( pFile, "Generated by <ring.h> -- MH [DCML] (2010)\n" );
    fprintf ( pFile, "ASCII\nDATASET UNSTRUCTURED_GRID\n\n" );
    fclose( pFile );
}

unsigned PotentialAvenger::printMesh ( const std::string& vtkFile ) const {
    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    fprintf ( pFile, "POINTS %d float\n", Nnod);
    for ( unsigned i = 0; i < Nnod; i++ ) {
        double xx = x[i];			//NodPos
        double y = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", xx, y, 0.0 );
    }

    unsigned Ncell = 0;
    if (visualizeCracks) {
        for ( unsigned i = 0; i < Nelt; i++ ) {
	    	if (d[i] < 1) Ncell++;
    	} 
    } else {
        Ncell = Nelt;
    }

    fprintf ( pFile, "\nCELLS %d %d\n", Ncell, 3*Ncell );
    for ( unsigned i = 0; i < Nelt; i++ ) {
        if (d[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12d %12d %12d\n", 2, i, i+1 );
    }
    fprintf ( pFile, "\nCELL_TYPES %d\n", Ncell );
    for ( unsigned i = 0; i < Nelt; i++ ) {
        if (d[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12d\n", 3 );
    }
    fprintf ( pFile, "\n" );
    fclose( pFile );

    return Ncell;
}

void PotentialAvenger::printPointData ( const std::string& vtkFile ) const {
    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    //int pointData = _NodPos.size();
    fprintf ( pFile, "POINT_DATA %d", Nnod);
    fprintf ( pFile, "\nVECTORS displacements float\n" );
    for ( unsigned i = 0; i < u.size(); i++ ) {
        double dx = u[i];	//Dis[i][0][0]
        double dy = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", dx, dy, 0.0 );
    }
    fprintf ( pFile, "\nVECTORS velocities float\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) {
        double vx = v[i];
        double vy = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", vx, vy, 0.0 );
    }
    fprintf ( pFile, "\n" );

    fprintf ( pFile, "\nSCALARS phi float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) fprintf ( pFile, " %12.3e \n", phi[i]);
    fprintf ( pFile, "\n" );
    
    fprintf ( pFile, "\nSCALARS inTLSnode int\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) fprintf ( pFile, " %u \n", inTLSnode[i]);
    fprintf ( pFile, "\n" );
    
    fclose( pFile );
}

void PotentialAvenger::printCellData ( const std::string& vtkFile, const unsigned& Ncell ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    fprintf( pFile, "CELL_DATA %d", Ncell );
    fprintf( pFile, "\nSCALARS stress float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", s[i]);
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS strain float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e\n", e[i]);
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS Y/Yc float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", e[i]*s[i]*0.5/Yc);
    fprintf( pFile, "\n" );

    fprintf ( pFile, "\nSCALARS damage float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12.3e \n", d[i]);
    fprintf ( pFile, "\n" );

	
    fprintf ( pFile, "\nSCALARS damageRate float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12.3e \n", (d[i] - d_1[i]) / dt);
    fprintf ( pFile, "\n" );

    fprintf( pFile, "\nSCALARS inTLS int\n");
    fprintf( pFile, "LOOKUP_TABLE default\n");
    for ( unsigned i = 0; i < Nelt; i++) if (d[i] < 1 || visualizeCracks == 0) fprintf(pFile, "%u \n", inTLS[i]);
    fprintf( pFile, "\n");

    fclose( pFile );
}

void PotentialAvenger::printGlobalInfo () const {

    if ( _EnrgFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _EnrgFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", t[_Nt] );
        fprintf( pFile, "%12.3e", strain_energy );
        fprintf( pFile, "%12.3e", dissip_energy );
        fprintf( pFile, "%12.3e", ext_energy );
        fprintf( pFile, "%12.3e", kinetic_energy );
	fprintf( pFile, "%12.3e", max_energy * 0.01 );
	fprintf( pFile, "%12.3e", tot_energy );
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::printFrags () {
    double DSum = 0.0;
    for (unsigned i = 0; i < d.size(); ++i) DSum += d[i];

    if ( _FragFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _FragFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", t[_Nt] );
        fprintf( pFile, "%12u", _numFrag );
        fprintf( pFile, "%12.3f", DSum );
        fprintf( pFile, "%12.3e", _fMean );
        fprintf( pFile, "%12.3e", _fMed );
        fprintf( pFile, "%12.3e", _fMax );
	fprintf( pFile, "%12.3e", _fMin );
	fprintf( pFile, "%12.3e", _fStDev );
	fprintf( pFile, "%12.3e", _fRange );
	fprintf( pFile, "%12.3f", _fSkew );
	fprintf( pFile, "%12.3f", _fExKurtosis );
	if (_numFrag <= 10){
	    for (unsigned i = 0; i < fragment_list.size(); i++){
		fprintf( pFile, "%12f", fragment_list[i].length() );
	    }
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::printSTheta () {
    if ( _SThetaFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _SThetaFile.c_str(), "a" );
        //fprintf( pFile, "%12.3e", _T );
	for (unsigned i = 0; i < Nelt; i++) {
	    double sprTheta = (double)(360*(i+0.5))/(double)(Nelt);
	    double cohTheta = (double)(360*(i+1))/(double)(Nelt);
	    fprintf( pFile, "%12.3e", t[_Nt] );
	    fprintf( pFile, "%12.3f", sprTheta );
        fprintf( pFile, "%12.3e", s[i] );
        fprintf( pFile, "%12.3f", cohTheta );
//        fprintf( pFile, "%12.3e", _sigCoh[i] );
        fprintf( pFile, "%12.3e", dm.dval(phi[i]) );
        fprintf( pFile, "%12.3f", (double)(i) );
        fprintf( pFile, "%12.3f", (double)(_Nt) );
	    fprintf( pFile, "\n" );
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::fragmentStats() {

    if (fragment_list.size() == 0) return;

	//Initialize statistics of fragment length distribution
	_fMean = 0;
	_fMed = 0;
	_fMax = 0;
	_fMin = 0;
	_fStDev = 0;
	_fRange = 0;
	_fSkew = 0;
	_fExKurtosis = 0;

	//If there are any fragments...
	//Calculate Median
	// Sort the list in ascending order
    vector<double> fragLength(0);
    if (localOnly) {
		double xbegin = 0;
		bool firstElem = 0;
		for (unsigned i = 0; i < Nelt; ++i) {
         	if (d[i] >= 1.0) {
				double xfrac = 0.5*(x[i]+x[i+1]);
				if (xfrac - xbegin >= h)	{
					if (xbegin == 0 && firstElem == false) {
						fragLength.push_back(xfrac * 2.0);
					} else {
						firstElem = false;
						fragLength.push_back(xfrac-xbegin);
						fragLength.push_back(xfrac-xbegin);
					}
					xbegin = xfrac;
				} else {
					assert(i == 0);
					firstElem = 1;
				}
			}

		}
		if (fragLength.size() == 0) {
			fragLength.push_back(2.0);
		} else {
			fragLength.push_back(1.0 - xbegin);
			fragLength.push_back(1.0 - xbegin);
		} 	
		double sum = 0;
		for ( unsigned i = 0; i < fragLength.size(); ++i) sum += fragLength[i];
    	assert(fabs(sum - 2.0) < 0.5 * h);

	} else {
	    for (unsigned i = 0; i < fragment_list.size(); ++i) {
        	double fragLen = fragment_list[i].length()*static_cast<double>(h) * 2.0;
    	    if (fragment_list[i].begin() == 0) fragLen -= h;
	        if (fragment_list[i].end() == Nnod -1) fragLen -= h;
        	if (((fragment_list.size() % 2) == 0) || (fragment_list[i].begin() != 0)) {
    	        fragLen /= 2.0;
 	           fragLength.push_back(fragLen);
        	}
    	    fragLength.push_back(fragLen);
	    }
	}
	sort(fragLength.begin(), fragLength.end());

	if (fragLength.size() % 2 == 0) {
        	//If even number, take average of two middle values
		_fMed = ( fragLength[ (unsigned)(fragLength.size() * 0.5) ]
			+ fragLength[ (unsigned)(fragLength.size() * 0.5) -1 ] ) * 0.5;
	} else {
		//If odd number, take middle value
		_fMed = fragLength[ (fragLength.size() - 1) / 2 ];
	}
	//Calculate Max, Min, Range
	_fMax = fragLength.back();
	_fMin = fragLength.front();
	_fRange = _fMax - _fMin;

	//Calculate Mean
	for (unsigned k = 0; k < fragLength.size(); k++){
		//Sum of lengths
		_fMean += fragLength[k];
	}
    //Mean = sum / number
	_fMean = _fMean / _numFrag;

	//Calculate Std. Deviation
	for (unsigned k = 0; k < fragLength.size(); k++){
		//Sum of squared (lengths - means)
		_fStDev += pow( (fragLength[k] - _fMean), 2);
	}
	_fStDev = sqrt( _fStDev / _numFrag ) ;

	//Calculate Skew
	for (unsigned k = 0; k < fragLength.size(); k++){
		//Sum of squared (lengths - means)
		_fSkew += pow( (fragLength[k] - _fMean), 3);
	}
	_fSkew = _fSkew / (_numFrag * pow(_fStDev,3) );

	//Calculate Kurtosis
	for (unsigned k = 0; k < fragLength.size(); k++){
		//Sum of squared (lengths - means)
		_fExKurtosis += pow( (fragLength[k] - _fMean), 4);
	}
	_fExKurtosis = _fExKurtosis / (_numFrag * pow(_fStDev,4) ) - 3.0;
    return;
}


void PotentialAvenger::printHisto() {
    // Prints Histogram and scaled 1-cdf figure
    vector<vector<double> > fragInvCDF;
    vector<unsigned> fHisto;

    if (_numFrag > 1) {

        vector<double> fragLength(0);
        if (localOnly) {
            double xbegin = 0;
            bool firstElem = 0;
            for (unsigned i = 0; i < Nelt; ++i) {
                if (d[i] >= 1.0) {
                    double xfrac = 0.5*(x[i]+x[i+1]);
                    if (xfrac - xbegin >= h)    {
                        if (xbegin == 0 && firstElem == false) {
                            fragLength.push_back(xfrac * 2.0);
                        } else {
                            firstElem = false;
                            fragLength.push_back(xfrac-xbegin);
                            fragLength.push_back(xfrac-xbegin);
                        }
                        xbegin = xfrac;
                    } else {
                        assert(i == 0);
                        firstElem = 1;
                    }
                }
    
            }
            if (fragLength.size() == 0) {
                fragLength.push_back(2.0);
            } else {
                fragLength.push_back(1.0 - xbegin);
                fragLength.push_back(1.0 - xbegin);
            }
            double sum = 0;
            for ( unsigned i = 0; i < fragLength.size(); ++i) sum += fragLength[i];
            assert(fabs(sum - 2.0) < 0.5 * h);
    	} else {
            for (unsigned i = 0; i < fragment_list.size(); ++i) {
                double fragLen = fragment_list[i].length()*static_cast<double>(h);
                if (((fragment_list.size() % 2) == 1) && (fragment_list[i].begin() == 0)) fragLen *= 2;
                fragLength.push_back(fragLen);
            }
		}
        sort(fragLength.begin(), fragLength.end());

		fragInvCDF.resize(2);
		fragInvCDF[0].resize(1000);	//a length, from zero to the max. fragment size
		fragInvCDF[1].resize(1000);	//number of fragments larger than this length
		fHisto.assign(25, 0);		//number of bins for the fragment histogram
	
		//Histogram - 25 bins
		 double max = _fMax;	//size
		//Step through fragment length list; increase count in the bin if fragment fits
		for (unsigned k = 0; k < fragLength.size(); k++){
            double length = fragLength[k];
//            if (fragment_list.size() % 2 == 1) length *= 2; //if not broken from wall, this segment has twice the length
			if (length < max * 0.04) fHisto[0]++;
			if ((length < max * 0.08) && (length >= max * 0.04)) fHisto[1]++;
			if ((length < max * 0.12) && (length >= max * 0.08)) fHisto[2]++;
			if ((length < max * 0.16) && (length >= max * 0.12)) fHisto[3]++;
			if ((length < max * 0.20) && (length >= max * 0.16)) fHisto[4]++;
			if ((length < max * 0.24) && (length >= max * 0.20)) fHisto[5]++;
			if ((length < max * 0.28) && (length >= max * 0.24)) fHisto[6]++;
			if ((length < max * 0.32) && (length >= max * 0.28)) fHisto[7]++;
			if ((length < max * 0.36) && (length >= max * 0.32)) fHisto[8]++;
			if ((length < max * 0.40) && (length >= max * 0.36)) fHisto[9]++;
			if ((length < max * 0.44) && (length >= max * 0.40)) fHisto[10]++;
			if ((length < max * 0.48) && (length >= max * 0.44)) fHisto[11]++;
			if ((length < max * 0.52) && (length >= max * 0.48)) fHisto[12]++;
			if ((length < max * 0.56) && (length >= max * 0.52)) fHisto[13]++;
			if ((length < max * 0.60) && (length >= max * 0.56)) fHisto[14]++;
			if ((length < max * 0.64) && (length >= max * 0.60)) fHisto[15]++;
			if ((length < max * 0.68) && (length >= max * 0.64)) fHisto[16]++;
			if ((length < max * 0.72) && (length >= max * 0.68)) fHisto[17]++;
			if ((length < max * 0.76) && (length >= max * 0.72)) fHisto[18]++;
			if ((length < max * 0.80) && (length >= max * 0.76)) fHisto[19]++;
			if ((length < max * 0.84) && (length >= max * 0.80)) fHisto[20]++;
			if ((length < max * 0.88) && (length >= max * 0.84)) fHisto[21]++;
			if ((length < max * 0.92) && (length >= max * 0.88)) fHisto[22]++;
			if ((length < max * 0.96) && (length >= max * 0.92)) fHisto[23]++;
			if ((length <= max) && (length >= max * 0.96)) fHisto[24]++;
		}

		//Open file to record histogram and 1-cdf data
		if ( _HistoFile.size() > 0 ) {
			FILE * pFile;
			pFile = fopen( _HistoFile.c_str(), "a" );
			double j = 0;
			for (unsigned i = 0; i < 1000; i++) {

				//grab the 1-cdf data; 
				unsigned count = 0;
				j = max * (static_cast<double>(i) / 1000.0);	//from 0 to max length, 1000 increments
				for (unsigned k = 0; k < fragLength.size(); k++) {
                    double length = fragLength[k];
					if (length > j) {		//if frag length greater than j, add to count
						count += 1;
					}
				}
		
				//save to vector
				fragInvCDF[0][i] = j;
				fragInvCDF[1][i] = (double)count;
				fprintf( pFile, "%6.3e %u", j, count);		//print to file

				//print histogram info to file - relative size (% of max frag length) & count
				if (i < 25) {	//piggybacking the for loop, only need the first 25
					fprintf( pFile, " %f %u", (double)(i*4+2), fHisto[i] );
				} else {
					fprintf( pFile, " 0 0");
				}
				fprintf( pFile, "\n" );
			}

			//print raw fragment sizes to file
			fprintf( pFile, "# Sizes: \n" );
			for (unsigned k = 0; k < fragment_list.size(); k++){
                double length = fragment_list[k].length();
                if (fragment_list.size() % 2 == 1) length *= 2; //if not broken from wall, this segment has twice the length
				fprintf( pFile, "%12.3e \n", length );
			}

			fclose( pFile );
		}
    }
    return;
}


void PotentialAvenger::printClean () const {
    std::string cleanPath = _path+"/clean.sh";
    FILE * pFile;
    pFile = fopen( cleanPath.c_str(), "w" );
    fprintf( pFile, "#!/bin/bash\n\n" );
    fprintf( pFile, "# Go to results directory\n" );
    fprintf( pFile, "cd %s\n\n", _path.c_str() );
    fprintf( pFile, "# Remove the data files\n" );
    fprintf( pFile, "cd ./datFiles/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "cd ./automatedRuns/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "# Remove the gnuplot files\n" );
    fprintf( pFile, "cd ./gnuplot/ ; rm *.plt; cd -\n\n" );
    fprintf( pFile, "# Remove the png/svg files\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.png; cd -\n\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.svg; cd -\n\n" );
    fprintf( pFile, "# Remove the vtk files\n" );
    fprintf( pFile, "cd ./vtkFiles/; find . -name \"*.vtk\" -print0 | xargs -0 rm -f; cd -\n\n" );
    fprintf( pFile, "# Remove plot.sh\n" );
    fprintf( pFile, "rm plot.sh\n" );
    fclose( pFile );
    std::string shellCmd = "chmod u+x " + cleanPath;
    //int status = system( shellCmd.c_str() );
	system( shellCmd.c_str() );

    shellCmd = "./" + cleanPath;
	system( shellCmd.c_str() );

}

