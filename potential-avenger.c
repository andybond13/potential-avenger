//potential-avenger.c
//Andrew Stershic
//DCML, Duke University
//(c) 2013, 2014

#include <potential-avenger.h>
#include <limits>
#include <math.h>
#include <sys/stat.h>

using namespace std;

int main(int argc, const char* argv[]) {
    assert(argc == 14);

    double strain_rate = atof(argv[1]);
    double ts_refine = atof(argv[2]);
    double end_t = atof(argv[3]);
    unsigned Nelt = atoi(argv[4]);
    double lc = atof(argv[5]);
    unsigned startWithLoad = atoi(argv[6]);
    unsigned printVTK = atoi(argv[7]);
    int oneAtATime = atoi(argv[8]);
    double minOpenDist = atof(argv[9]);
	double alpha = atof(argv[10]);
    unsigned localOnly = atoi(argv[11]);
    unsigned visualizeCracks = atoi(argv[12]);
    unsigned fullCompression = atoi(argv[13]);
    string path = ".";

    PotentialAvenger pa = PotentialAvenger(strain_rate, ts_refine, end_t, Nelt, lc, startWithLoad, printVTK, oneAtATime, minOpenDist, alpha, localOnly, visualizeCracks, fullCompression, path);
    pa.run();
}

PotentialAvenger::PotentialAvenger(double& in0, double& in1, double& in2, unsigned& in3, double& in4, unsigned& in5, unsigned& in6, int& in7, double& in8, double& in9, unsigned& in10, unsigned& in11, unsigned& in12, string& path){
    strain_rate = in0;
    ts_refine = in1;
    end_t = in2;
    Nelt = in3;
    lc = in4;
    startWithLoad = in5;
    printVTK = in6;
    oneAtATime = in7;
    minOpenDist = in8;
	alpha = in9;
    localOnly = in10;
    visualizeCracks = in11;
    fullCompression = in12;
    _path = path + "/results";

    _numFrag = 0;    

    //make plot files
    printClean();
	plotEnergies();
    plotFrags();
    plotHisto();
    plotSTheta();

};

PotentialAvenger::~PotentialAvenger(){
// create a plot file if necessary
    std::string plotFil = _path+"/plot.sh";		//"../results/plot.sh"
    FILE * pFileP;
    pFileP = fopen( plotFil.c_str(), "w" );
    fprintf( pFileP, "#!/bin/bash\n" );
    fprintf( pFileP, "# shell script generated by <ring.h>" );
    fprintf( pFileP, " -- MH [DCML] (2010)\n\n" );
    if ( _EnrgFile.size() != 0 ) {
        std::string enrgFil = "./gnuplot/plotEnrg.plt";
        fprintf( pFileP, "gnuplot %s\n", enrgFil.c_str() );
    }
    if ( _FragFile.size() != 0 ) {
        std::string fragFil = "./gnuplot/plotFragInfo.plt";
        fprintf( pFileP, "gnuplot %s\n", fragFil.c_str() );
    }
    if ( _HistoFile.size() != 0 ) {
        std::string histoFil = "./gnuplot/plotHisto.plt";
        fprintf( pFileP, "gnuplot %s\n", histoFil.c_str() );
    }
    if ( _SThetaFile.size() != 0 ) {
        std::string sThetaFil = "./gnuplot/plotSTheta.plt";
        fprintf( pFileP, "gnuplot %s\n", sThetaFil.c_str() );
    }
    fprintf( pFileP, "\n/usr/bin/open -a \"/Applications/Google Chrome.app\" ./pngFiles/*.svg &\n" );
    fclose( pFileP );
    chmod( plotFil.c_str(), 0775 );

};

unsigned min(const vector<unsigned> in) {
    assert(in.size() > 0);
    unsigned min = in[0];
    for (unsigned i = 1; i < in.size(); ++i) {
        if (in[i] < min) min = in[1];
    }
    return min;
}

unsigned max(const vector<unsigned> in) {
    assert(in.size() > 0);
    unsigned max = in[0];
    for (unsigned i = 1; i < in.size(); ++i) {
        if (in[i] > max) max = in[1];
    }
    return max;
}

double dotProduct(const vector<double> a, const vector<double> b) {
    double sum = 0;
    assert(a.size() == b.size() );
    for (unsigned i = 0; i < a.size(); ++i) sum+= a[i]*b[i];
    return sum;
}

int median(const vector<int> in) {
    return in[(in.size()-1)/2];
}

double sum(const vector<double> in) {
    return dotProduct(in,vector<double>(in.size(),1));
}

double sum(const vector<unsigned> in) {
    unsigned result = 0;
    for (unsigned i = 0; i < in.size(); ++i) result += in[i];
    return result;
}

template <typename T> double sgn(T val) {
    return (T(0) < val) - (val < T(0));
}

double printable (double in) {
    double limit = numeric_limits<double>::epsilon();
	if (fabs(in) < limit) return 0.0;
    else return in;
}

void PotentialAvenger::run() {

    printRunInfo();

    dm = DamageModel("Parabolic",lc);

    Nnod = Nelt+1;
    _Nt = 0;
    E = 610.0; //(beton)
    rho = 3.9e-6; //(beton)
    A = 0.2; // barre de 10cm sur 10cm
    double c = sqrt(E/rho);
    L = 1.0;
    h = 1/static_cast<double>(Nelt); //
    double cfl = 1./ts_refine;
    dt = cfl * h/c;//
    unsigned Ntim = Nelt*ts_refine*end_t*c;
    Yc = 8.1967e-4;//E/10;
    ec = sqrt(2 * Yc / E);
    sigc = E * ec;

    // two gauss point on the element
    vector<double> pg(2);
    pg[0] = (1-sqrt(3)/3)/2;
    pg[1] = (1+sqrt(3)/3)/2;
    vector<double> wg(2);
    wg[0] = 0.5;
    wg[1] = 0.5;

    d = vector<double>(Nelt,0);
    d_type = vector<unsigned>(Nelt,0); //0-local, 0-NL: (the type of model used the last time d was computed)
    d_quad = vector<vector<double> >(Nelt);
    d_quad_wt = vector<vector<double> >(Nelt);
    d_1 = vector<double>(Nelt,0);
    d_max = vector<double>(Nelt,0);
    s = vector<double>(Nelt,0.0);
    energy = vector<double>(Nelt,0);
    Y = vector<double>(Nelt,0);
    Ycv = vector<double>(Nelt,Yc);
    strain_energy = 0.0;
    kinetic_energy = 0.0;
    dissip_energy = 0.0;
    dissip_energy_local = 0.0;
    dissip_energy_TLS = 0.0;
    ext_energy = 0.0;
    tot_energy = 0.0;
    vector<Fragment*> fragment_list;

    ustat = vector<double>(Nnod,0);
    Ystat = vector<double>(Nnod,0);
    u = vector<double>(Nnod,0);
    v = vector<double>(Nnod,0);
    a = vector<double>(Nnod,0);
    phiL = vector<double>(Nelt,0);
    phiNL = vector<double>(Nnod,0);

    phiNL_1 = vector<double>(Nnod,0);
    vector<double> phidot;
    gradPhiL = vector<double>(Nnod,0.0);
    gradPhiNL = vector<double>(Nnod,0.0);

    vector<unsigned> nbiter = vector<unsigned>(Ntim,0);
    nfrags = vector<unsigned>(Ntim,0);
    _numFrag = 0;
    vector<Segment*> segments;
    nucleated = 0;

    m.assign(Nnod,rho*h*A);
    m[0] = m[0]/2; m[Nnod-1] = m[Nnod-1]/2;

    //initialization
	double qty = (ec - strain_rate * dt * 10.0) * static_cast<double>(startWithLoad);
	double e0 = max(qty - fmod(qty, (strain_rate * dt)), 0.0);
    e = vector<double>(Nelt,e0);
    x = vector<double>(Nnod,0);
    for (unsigned j = 0; j < Nnod; ++j) x[j] = static_cast<double>(j)*h;

    xe = vector<double>(Nnod,0);
    for (unsigned j = 0; j < Nelt; ++j) xe[j] = 0.5*(x[j] + x[j+1]);

    t = vector<double>(Ntim,0);
    for (unsigned j = 0; j < Ntim; ++j) t[j] = static_cast<double>(j)*dt;

    // Initially the bar is loaded and all elements are at Yc
    // A tls is placed on the first element, obviously it satifies
    //   Ybar = Yc
    // This extra damage will create new stress that are less than in the next element
    // and ill thus give an unloading wave.

    //constant strain rate applied
    double csr = strain_rate;
    bool vbc = true;
    for (unsigned j = 0; j < Nnod; ++j) v[j] = static_cast<double>(vbc)*csr*x[j];
    v[Nnod-1] = csr;

    for (unsigned j = 0; j < Nnod; ++j) {
        u[j] = x[j] * e0;//x[j] * ec * L * 0.999*(1-vbc);
        ustat[j] = 0.0;//x[j] * ec * L * 0.999*(1-vbc);
        phiL[j] = -1;//(2*h-x[j])*(1-vbc)-vbc;
        phiNL[j] = -1;//(2*h-x[j])*(1-vbc)-vbc;
    }

    /*
    Segment* seg1 = new Segment(x[0],phi[0],0);
    seg1->indices.push_back(-1);
    segments.push_back(seg1);
    */

    //check to see which elements are in TLS zones
    inTLS.assign(Nelt,0);
    inTLSnode.assign(Nnod,0);
    checkInTLS(segments,inTLS,inTLSnode);

    //calculate stresses
    calculateStressesL(pg,wg);
    calculateStressesNL(pg,wg,segments);

    //acceleration
    a[0] = 0;
    a[Nnod-1] = 0;
    for (unsigned j = 1; j < Nnod-1; ++j)  a[j] = A*(s[j] - s[j-1]) /m[j];

    nbiter[0] = 0;
    analyzeDamage(x,phiNL,h,segments);
    unsigned len = 0;
    for (unsigned l = 0; l < segments.size(); ++l) {
        if (segments[l]->size() == 0) continue;
        len++;
    }
    phidot.resize(len);

    //print data to file
    vector<double>fragLength = findFragments(dm, phiL, phiNL,nfrags[0],segments);
    calculateEnergies(0,pg,wg);
    if (printVTK != 0) printVtk(_Nt);
    printFrags(fragLength);
    printGlobalInfo();

    //time-integration loop
    for (unsigned i = 1; i < Ntim; ++i){
        _Nt++;
//cout << "t = " << t[i] << endl;

        //Copy kinematic variables to "old"
        u_1 = vector<double>(Nnod,0); u_1 = u; u.assign(Nnod,0.0);
        vector<double> v_1 = vector<double>(Nnod,0); v_1 = v; v.assign(Nnod,0.0);
        vector<double> a_1 = vector<double>(Nnod,0); a_1 = a; a.assign(Nnod,0.0);
        d_1 = vector<double>(Nnod,0); d_1 = d; d.assign(Nnod,0.0);
        phiNL_1 = phiNL;


        //prediction
        for (unsigned j = 0; j < Nnod; ++j) {
            v[j]= v_1[j] + 0.5*dt*a_1[j];
            u[j]= u_1[j] + dt*v_1[j] + 0.5*dt*dt*a_1[j];
        }

        //def computation and Y update.
        for (unsigned j = 0; j < Nelt; ++j) {
            e[j] = (u[j+1] - u[j]) / h;
            //b=0.5*E*e(i,j)*e(i,j)-Yc;
        }

        //updating the stress and level-set fields
		//local
        calculateStressesL(pg,wg); 
        updateLevelSetL(i,nbiter,segments,pg,wg);
		//non-local / TLS
		if (localOnly == 0) {
        	updateLevelSetNL(i,nbiter,segments,pg,wg);
        	for (unsigned j = 0; j < Nnod; ++j)  phiNL[j] = max(phiNL[j], phiNL_1[j]);
        	calculateStressesNL(pg,wg,segments);
		} 
        // moving the localization front
        // we compute a = integral (Yn+1 - Yc) d' in the current non-local zone
        // then we compute b = (Yn+1-Yc) d' on the front
        // the shift in level set if the ratio of the two.


                calculateLevelSetGradientL(d, gradPhiL);
                calculateLevelSetGradientNL(d, gradPhiNL);
        //check for nucleation
		unsigned numNuc = 0;
        if (localOnly == 0) {
	    	if (alpha == 0) {
	    		//non-local-only model
    	        vector<double> Yin;
	            for (unsigned l = 0; l < Nelt; ++l)  Yin.push_back(0.5*E*e[l]*e[l]);
    	        string elemOrNodal="elem";
            	numNuc = checkFailureCriteria(i,Ycv,elemOrNodal,Yin,false,false,1.0*h,segments, nbiter, pg, wg);//delete this 0.5*h rather than 2*h
    		} else {
		    	//local / non-local hybrid model
		    	calculateLevelSetGradientL(d, gradPhiL);
		    	calculateLevelSetGradientNL(d, gradPhiNL);
		    	string elemOrNodal = "nodal";
		    	vector<double> gradLimit(Nnod,1.0);
		    	numNuc = checkFailureCriteria(i,gradLimit,elemOrNodal,gradPhiL,true,true, 1.0*h, segments, nbiter, pg, wg);
		    }
        }

        //enforce phi constraints - update segments
        analyzeDamage(x,phiNL,h,segments);

		if (numNuc > 0) {
            updateLevelSetNL(i,nbiter,segments,pg,wg);
        	for (unsigned j = 0; j < Nnod; ++j)  phiNL[j] = max(phiNL[j], phiNL_1[j]);
            checkInTLS(segments,inTLS,inTLSnode);
            calculateStressesNL(pg,wg,segments);
		}
        int index = -1;
        for (unsigned l = 0; l < segments.size(); ++l) {
            if (segments[l]->size() == 0) continue;
            index++;
            //median(segments[l]);
            int smid = median(segments[l]->indices);

            len = 0;
            for (unsigned j = 0; j < segments.size(); ++j) {
                if (segments[j]->size() == 0) continue;
                len++;
            }
            phidot.resize(len);
            phidot[index] = (phiNL[smid] - phiNL_1[smid])/dt;
            if (phidot[index] * dt > h*1.01 ) {
                printf("level-set front advancing more than one element per time-step: t=%f, segment %u , dphi/h = %f \n",t[i],l,phidot[index]*dt/h);
            }
        }


        //check to see which elements are in TLS zones
        checkInTLS(segments,inTLS,inTLSnode);
       

        for (unsigned j = 1; j < Nnod-1; ++j)  phiNL[j] = max(phiNL[j], phiNL_1[j]);

		//acceleration
        if (max(phiL[0],phiNL[0]) <= lc) a[0] = 0;
        else a[0] =  A*s[0]/m[0];
        a[Nnod-1] = 0; //note: this is a constraint which was hidden. if free, it would be -s(i,Nnod)/m(j);
        for (unsigned j = 1; j < Nnod - 1; ++j) a[j] = A*(s[j] - s[j-1]) /m[j];

        //correction
        for (unsigned j = 0; j < Nnod; ++j) v[j]= v[j] + 0.5*dt*a[j];

        //record number of fragments and quantities per fragment
        fragLength.clear();
        fragLength = findFragments(dm, phiL, phiNL, nfrags[i],segments);
        _numFrag = nfrags[i];

        //calculate energies
        calculateEnergies(i,pg,wg);

        //update gradient for printing
		calculateLevelSetGradientL(d, gradPhiL);
		calculateLevelSetGradientNL(d, gradPhiNL);

		//update Ybar after segments redefined
        for (unsigned l = 0; l < segments.size(); ++l) {
            if (segments[l]->size()==0) continue;//segments.erase(segments.begin()+l);
            unsigned sbegin = segments[l]->begin();
            unsigned send = segments[l]->end();
            //clear Ybar
            segments[l]->YbarmYc = 0.0; 
            double YbarmYc = 0.0; double Ycavg = 0.0;
            double tangent_Y = 0.0;
            double phimin = 0.0;  double phimax = 0.0;
       		double phiminY = 0.0; double phimaxY = 0.0;
        	unsigned status = calculateYbar(pg,wg,Ycavg,YbarmYc,tangent_Y,phimin,phimax,phiminY,phimaxY,nbiter[i],sbegin,send,segments[l]);
		}

        //check enforcement of constraints
        checkConstraints(gradPhiL,gradPhiNL,segments);

		//print the rest of the table/graph data
        if (printVTK != 0) if ( ( _Nt % printVTK) == 0 ) {printVtk(_Nt); cout << "*t = " << t[i] << endl;}
        printFrags(fragLength);
        printGlobalInfo();

    }//end time-loop

    //find fragment length total & minimum
    cout << " fragment lengths:" << endl;
    double minfrag = _fMin; 
	double sumfrag = 0.0;
    for (unsigned i = 0; i < fragLength.size(); ++i) {
        cout << fragLength[i] << endl;
		if (minfrag > fragLength[i] ) minfrag = fragLength[i];
		sumfrag += fragLength[i];
	}
     nfrags[Ntim-1] = fragLength.size(); 

    printf("Final number of fragments: %i \nMinimum fragment length: %f    avg = %f\nFinal dissipated energy: %3.3e   = local %3.3e + TLS %3.3e  (%f/%f)\n",nfrags[Ntim-1],minfrag,sumfrag*L/static_cast<double>(nfrags[Ntim-1]),dissip_energy,dissip_energy_local,dissip_energy_TLS,dissip_energy_local/dissip_energy,dissip_energy_TLS/dissip_energy);
    double alt_dissip_energy = 0.0 + ext_energy - strain_energy - kinetic_energy; 
    printf("alt. dissipated energy: %3.3e \n",alt_dissip_energy); 
   cout << " fragment total length " << sumfrag << "     powder length = " << 2.0*L - sumfrag << endl;
    
    //print histogram
    printHisto(fragLength);

    //kill all segments and fragments
    killSegments(segments);
    killFragments(fragment_list);
    return;
};

void PotentialAvenger::killSegments(vector<Segment*>& seg) {
    for (unsigned i = 0; i < seg.size(); ++i) delete seg[i];
    seg.clear();
    return;
}

void PotentialAvenger::killFragments(vector<Fragment*>& frag) {
    for (unsigned i = 0; i < frag.size(); ++i) delete frag[i];
    frag.clear();
    return;
}

void PotentialAvenger::calculateLevelSetGradientL( const vector<double>& dV, vector<double>& gradientPhi) {
	//calculate the gradient of the levelset (local model). This will be used to see if the |gradPhi| > 1,
	//in which case, a non-local zone will be inserted
	assert(gradientPhi.size() == Nnod);
    assert(gradientPhi.size() > 4);
	for (unsigned i = 1; i < Nnod-1; ++i) {
		double phiM = phiL[i];
        double phiM1 = phiL[i-1];
		gradientPhi[i] = (phiM - phiM1) / h;
	}
    gradientPhi[0] = gradientPhi[1]; 
    gradientPhi[Nnod-1] = gradientPhi[Nnod-2];

	for (unsigned i = 0; i < Nnod; ++i) if (inTLS[i]) gradientPhi[i] = 0.0; 
    return;
}

void PotentialAvenger::calculateLevelSetGradientNL( const vector<double>& dV, vector<double>& gradientPhi) {
    //calculate the gradient of the levelset (non-local model). This will be used to see if the |gradPhi| > 1,
    //in which case, a non-local zone will be inserted
    assert(gradientPhi.size() == Nnod);
    assert(gradientPhi.size() > 4);
    //gradientPhi[0] = (phiNL[1]-phiNL[0])/(h); //first-order boundary difference
    gradientPhi[0] = (-phiNL[2]+4*phiNL[1]-3*phiNL[0])/(2*h); //second-order boundary difference
    //gradientPhi[Nnod-1] = (phiNL[Nnod-1]-phiNL[Nnod-2])/(h); //first-order boundary difference
    gradientPhi[Nnod-1] = (3*phiNL[Nnod-1]-4*phiNL[Nnod-2]+phiNL[Nnod-3])/(2*h); //second-order boundary difference
    for (unsigned i = 1; i < Nnod-1; ++i) {
       double phiM = 0.5 * (phiNL[i] + phiNL[i+1]); 
       double phiM1 = 0.5* (phiNL[i] + phiNL[i-1]);
       gradientPhi[i] = (phiM - phiM1) / h;
    }
    return;
}

void PotentialAvenger::checkInTLS(const vector<Segment*>& segments, vector<unsigned>& elem, vector<unsigned>& nodes) {
	
	elem.assign(Nelt, 0);
	nodes.assign(Nnod,0);
    //check nodes; 1 = in TLS zone, 0 = not
    if (nucleated > 0) {
        for (unsigned index = 0; index < Nnod; ++index) {
			//compare to phiL on both sides (if possible). inTLS if phiNL > max(phiL)
			double phiLocal = 0.0;
			if (index > 0) phiLocal = max(phiLocal, phiL[index]);
			if (index < Nnod-1) phiLocal = max(phiLocal, phiL[index+1]);
			if (phiNL[index] >= phiLocal) nodes[index] = 1;
    	}
    }
//assert(elem.size() == inTLS.size() );
    //check elements based on node results
    for (unsigned k = 0; k < Nelt; ++k) {
        //if both nodes are not in TLS zones, then element is not in TLS zone; if one or both are in, then element is in
        if (nodes[k] == 0 && nodes[k+1] == 0) elem[k] = 0;
        else elem[k] = 1;
    }
    return;
}

void PotentialAvenger::checkConstraints(const vector<double>& gradientPhiL, const vector<double>& gradientPhiNL, const vector<Segment*>& segments) {

	//check gradient of level-set
	assert(gradientPhiL.size() == Nnod);
	assert(gradientPhiNL.size() == Nnod);
   
	if (localOnly == 0) for (unsigned j = 0; j < Nnod; ++j) assert(fabs(gradientPhiL[j]) <= 1.0001);
    if (localOnly == 0) for (unsigned j = 0; j < Nnod; ++j) assert(fabs(gradientPhiNL[j]) <= 1.0001);

    //for local: check that Y <= Yc
    for (unsigned j = 0; j < Nelt; ++j) if (inTLS[j] == 0 && d[j] < 1.0) assert( Y[j]/Ycv[j] < 1.0001);

	//for non-local: check that Ybar <= Yc
    for (unsigned j = 0; j < segments.size(); ++j) assert( (segments[j]->YbarmYc)/Yc <= 0.0001);


	//for non-local: check that gradient of phi is 1 on all elements
	if (nucleated > 0) {
        for (unsigned l = 0; l < segments.size(); ++l) {
			for (unsigned j = segments[l]->begin()+1; j < segments[l]->end(); ++j) {
				
				assert( fabs(fabs(phiNL[j] - phiNL[j+1]) - h) < 0.01*h ); 
			}
		}
	}

	return;
}

void PotentialAvenger::calculateStressesNL(const vector<double>& pg, const vector<double>& wg, vector<Segment*>& segments) {
    
	vector<double> dLocal = d;

    for (unsigned j = 0; j < Nelt; ++j) {

		if (inTLS[j] == 0) continue; //skip if local!
		
        d_quad[j].clear();
		d_quad_wt[j].clear();
	    s[j] = 0;
	    d[j] = 0;
   		if ((inTLS[j] == 1 && localOnly == 0) || alpha ==0.0 ) { 	//in TLS: use non-local damage model
	        assert(pg.size() == wg.size());
	
			if (inTLSnode[j]) phiNL[j] = max(phiNL[j],phiNL_1[j]);	
			if (inTLSnode[j+1]) phiNL[j+1] = max(phiNL[j+1],phiNL_1[j+1]);	
	        e[j] = (u[j+1] - u[j])/h;
  	    	vector<double> dloc(pg.size(),0.0);
			if (inTLSnode[j] == 1 && inTLSnode[j+1] == 0) {
				//element at transition: left in, right out
				double phiLocal = phiL[j+1];
				double delta = fabs(phiNL[j] - phiLocal); 
                delta = max(delta, 0.0); delta = min(delta, h);
        	    for (unsigned k = 0; k < pg.size(); ++k) {
					double philoc1 = pg[k] * phiNL[j] + (1-pg[k]) * (phiLocal);
					d_quad[j].push_back(dm.dval(philoc1));
					d_quad_wt[j].push_back(wg[k] * delta/h);
					dloc[k] = dm.dval(philoc1);
					d[j] += wg[k] * dloc[k] * delta/h;
            	    s[j] += wg[k] * (1.0-dloc[k]) * E * e[j] * delta/h;
                }
				d[j] += (h-delta)/h * dm.dval(phiLocal);
				s[j] += (h-delta)/h * (1.0-dm.dval(phiLocal)) * E * e[j];
				d_quad[j].push_back(dm.dval(phiLocal)); 
				d_quad_wt[j].push_back(1.0 * (h-delta)/h );
                

			} else if (inTLSnode[j] == 0 && inTLSnode[j+1] == 1) {
				//element at transition: left out, right in
				double phiLocal = phiL[j];
                double delta = h - fabs(phiLocal - phiNL[j+1]);
                delta = max(delta, 0.0); delta = min(delta, h);
                for (unsigned k = 0; k < pg.size(); ++k) {
                    double philoc1 = pg[k] * phiLocal + (1-pg[k]) * (phiNL[j+1]);
                    d_quad[j].push_back(dm.dval(philoc1));
                    d_quad_wt[j].push_back(wg[k] * (h-delta)/h);
                    dloc[k] = dm.dval(philoc1);
                    d[j] += wg[k] * dloc[k] * (h-delta)/h;
                    s[j] += wg[k] * (1.0-dloc[k]) * E * e[j] * (h-delta)/h;
//cout << " added 0 " << dm.dval(philoc1) << " ( " << wg[k] * delta/h << " )" <<endl;
                }   
				d[j] += delta/h * dm.dval(phiLocal);
				s[j] += delta/h * (1.0 - dm.dval(phiLocal)) * E * e[j];
                d_quad[j].push_back(dm.dval(phiLocal));
                d_quad_wt[j].push_back(1.0 * delta/h );
//cout << " added 0 " << dm.dval(phiLocal) <<  " ( " << (h-delta)/h << " ) " << endl;

    	    } else if (phiNL[j] > 0  && phiNL[j+1] > 0) {
				//both sides positive
        	    for (unsigned k = 0; k < pg.size(); ++k) {
            	    if (fabs(fabs(phiNL[j] - phiNL[j+1])-h) > h * 0.0001) {
                	    //there's a peak/anti-peak inside!
                    	double delta = 0.5*(h - phiNL[j+1] + phiNL[j]); //delta computed for anti-peak

						//see if any peaks are within element -> reverse delta
						bool flag = false;
						for (unsigned ii = 0; ii < segments.size(); ++ii) {
							if (segments[ii]->xpeak >= x[j] && segments[ii]->xpeak <= x[j+1]) flag = true;
						}
						if (flag == true)  delta = h - delta;

	                    //subdivide interval into two: [x1, x1+delta] [x1+delta, x2], effectively double number of integration points
    	                double philoc1 = pg[k] * phiNL[j] + (1-pg[k]) * (phiNL[j] - delta);
    	                if (flag) philoc1 = pg[k] * phiNL[j] + (1-pg[k]) * (phiNL[j] + delta);
        	            double philoc2 = pg[k] * (phiNL[j] - delta) + (1-pg[k]) * phiNL[j+1];
        	            if (flag) philoc2 = pg[k] * (phiNL[j] + delta) + (1-pg[k]) * phiNL[j+1];
						d_quad[j].push_back(dm.dval(philoc1));
						d_quad[j].push_back(dm.dval(philoc2));
						d_quad_wt[j].push_back(delta/h * wg[k]);
						d_quad_wt[j].push_back((h-delta)/h * wg[k]);
            	        dloc[k] = delta/h * dm.dval(philoc1) + (h-delta)/h * dm.dval(philoc2);
                	} else {
	                    double philoc = pg[k] * phiNL[j] + (1-pg[k]) * phiNL[j+1];
						d_quad[j].push_back(dm.dval(philoc));
						d_quad_wt[j].push_back(wg[k]);
    	                dloc[k] = dm.dval(philoc);
        	        }
            	    s[j] += wg[k] * (1-dloc[k]) * E * e[j];
					d[j] += wg[k] * dloc[k];
	            }
    	    } else if  (phiNL[j] <= 0 && phiNL[j+1] <= 0) {
				//both sides negative
        	    s[j] = E * e[j];
			    d_quad[j].push_back(0.0);
				d_quad_wt[j].push_back(1.0); 
	        } else if  (phiNL[j] > 0 && phiNL[j+1] <= 0) {
				//left side positive, right side negative
    	        double delta = fabs(phiNL[j]) / (fabs(phiNL[j])+fabs(phiNL[j+1]));
        	    double sloc = 0;
            	for (unsigned k = 0; k < pg.size(); ++k) {
                	double philoc = pg[k] * phiNL[j];
	                dloc[k] = dm.dval(philoc);
    	            sloc += wg[k] * (1-dloc[k]) * E * e[j];
			        d[j] += wg[k] * dloc[k] * delta; //+ ( 1-delta) * 0.0
					d_quad[j].push_back(dm.dval(philoc));
					d_quad_wt[j].push_back(wg[k] * delta);
        	    }
				d_quad[j].push_back(0.0);
				d_quad_wt[j].push_back( 1-delta );
            	s[j] = delta *  sloc +  (1-delta) * E * e[j];
	        } else if (phiNL[j] <= 0 && phiNL[j+1] > 0) {
				//left side negative, right side positive
    	        double delta = fabs(phiNL[j+1]) / (fabs(phiNL[j])+fabs(phiNL[j+1]));
        	    double sloc = 0;
            	for (unsigned k = 0; k < pg.size(); ++k) {
                	double philoc = pg[k] * phiNL[j+1];
	                dloc[k] = dm.dval(philoc);
    	            sloc += wg[k] * (1-dloc[k]) * E * e[j];
			        d[j] += wg[k] * dloc[k] * delta; //+ ( 1-delta) * 0.0
					d_quad[j].push_back(dm.dval(philoc));
					d_quad_wt[j].push_back(wg[k] * delta); 
        	    }
				d_quad[j].push_back(0.0);
				d_quad_wt[j].push_back( 1-delta );
            	s[j] = delta *  sloc +  (1-delta) * E * e[j];
	        }

            if (d[j] > d_max[j]) d_max[j] = d[j];		//update maximum damage

			if (inTLSnode[j] + inTLSnode[j+1] == 1) {
				//if (d[j] < d_max[j]) d[j] = d_max[j];
			}

            if (fullCompression) {
                //this makes compression fully in contact no matter what the damage
                if (e[j] < 0) s[j] = e[j] * E;
            }
			d_type[j] = 1;
		}

        assert(d_quad[j].size() == d_quad_wt[j].size());
        assert(fabs(sum(d_quad_wt[j]) - 1.0) < 0.0001);
        assert(d_quad[j].size() == d_quad_wt[j].size());
	}

	return;
}
void PotentialAvenger::calculateStressesL(const vector<double>& pg, const vector<double>& wg) {

	for (unsigned j = 0; j < Nelt; ++j) {
	    //inTLS == 0 : local damage model

        unsigned nodesInTLS = 0;
        if (inTLSnode[j]) nodesInTLS++;
        if (inTLSnode[j+1]) nodesInTLS++;
        if (nodesInTLS >= 2) continue;


		d[j] = 0.0;
        s[j] = 0.0;
		double dee = d_1[j];
		//check to see if damage needs to be recalculated; (local model so no need to use quadrature for dH)
		if (0.5 * E * e[j] * e[j] > dH(j,d_1[j]) + Ycv[j]) 	{
			double factor = sqrt(2.0 * Ycv[j] / (E * e[j] * e[j]) ); 
			dee = (1.0 - fabs(factor)) / alpha;
            if (dee < 0.0) //E * e[j] * e[j] < 2.0 * Yc) 
				dee = 0.0;			//not damaged if Y < Yc
            if (dee > 1.0)
                dee = 1.0;
            assert(nodesInTLS < 2);
		}
        if (dee > d_max[j]) d_max[j] = dee;		//update maximum damage
		d[j] = dee;
        s[j] = E * (1.0 - dee) * e[j];
		assert(d[j] >= d_1[j]);
		if (d[j] < 1.0) assert(0.5 * E * e[j] * e[j] - dH(j,d[j]) <= Ycv[j] * 1.0001);
		
        if (fullCompression) {
            //this makes compression fully in contact no matter what the damage
            if (e[j] < 0) s[j] = e[j] * E;
        }

		d_quad[j].clear();
		d_quad_wt[j].clear();

		d_quad[j].push_back(d[j]);
        d_quad_wt[j].push_back(1.0);
		d_type[j] = 0;
		
		assert(d_quad[j].size() == d_quad_wt[j].size());
		assert(fabs(sum(d_quad_wt[j]) - 1.0) < 0.0001);
		assert(d_quad[j].size() == d_quad_wt[j].size());
    }
    return;
}

void PotentialAvenger::calculateEnergies(const unsigned& i, const vector<double>& pg, const vector<double>& wg) {
    dissip_energy = 0.0;
    kinetic_energy = 0.0;

    for (unsigned j = 0; j < Nelt; ++j) {
        Y[j] = 0.5 * E * e[j] * e[j];
        for (unsigned k = 0; k < d_quad_wt[j].size(); ++k) {
            double dloc = d_quad[j][k];
            Y[j] -= d_quad_wt[j][k] * dH(j,dloc);
        }

        if (inTLS[j] == 1) dissip_energy_TLS += h * A * Y[j] * (d[j] - d_1[j]); //global dissipation = int: Y dd/dt dV
        if (inTLS[j] == 0) dissip_energy_local += h * A * Y[j] * (d[j] - d_1[j]); //global dissipation = int: Y dd/dt dV
        if (i > 0) {
            kinetic_energy += 0.5 * h * A * rho * 0.5 *
                                ( pow(u[j] - u_1[j],2) + pow(u[j+1] - u_1[j+1],2) ) / pow(dt,2);
            //ustat(i,j+1) = ustat(i,j) + h*s(0,Nelt)/(E*(1-d(i,j)));
        } else {
            kinetic_energy += 0.5 * h * A * rho * 0.5 * ( v[j] * v[j] + v[j+1] * v[j+1]);
        }
        energy[j] = h * A * 0.5 * E * e[j] * e[j] * (1.0 - d[j]);
    }
    //ustat(i,:) *= u(1,Nnod)/ustat(i,Nnod);
    for (unsigned j = 0; j < Nelt; ++j) Ystat[j] = 0.5 * E * pow((ustat[j+1] - ustat[j])/h,2);

	dissip_energy = dissip_energy_local + dissip_energy_TLS;

    strain_energy = sum (energy);
    if (i > 0) ext_energy += (a[Nnod-1] * m[Nnod-1] + s[Nnod-2] * A) * v[Nnod-1] * dt;
    else ext_energy = dissip_energy + strain_energy + kinetic_energy;
    tot_energy = strain_energy + kinetic_energy + dissip_energy - ext_energy;
    max_energy = max(max(kinetic_energy,dissip_energy),strain_energy);
    return;
}

std::string convertInt(unsigned number) {
    if (number == 0)
        return "0";
    string temp="";
    string returnvalue="";
	//read from back
    while (number>0)
    {
        temp+=number%10+48;
        number/=10;
    }
    for (unsigned i=0;i<temp.length();i++)
        returnvalue+=temp[temp.length()-i-1];
    return returnvalue;
}

double PotentialAvenger::H (const unsigned j, const double dee) { 
    return (Ycv[j] * alpha * dee * dee)/(1.0 - alpha * dee);
}    

double PotentialAvenger::dH (const unsigned j, const double dee) const { 
    return (Ycv[j] * alpha * dee) * (2.0 - alpha * dee)/pow(1.0 - alpha * dee,2);
}    

void PotentialAvenger::updateLevelSetL( const unsigned& i, vector<unsigned>& nbiter, vector<Segment*>& segments, const vector<double>& pg, const vector<double>& wg ) {

     for (unsigned j = 0; j < Nelt; ++j) {
        unsigned nodesInTLS = 0;
        if (inTLSnode[j]) nodesInTLS++;
        if (inTLSnode[j+1]) nodesInTLS++;
		double dee = d[j];
        if (nodesInTLS < 2) 	phiL[j] = dm.phi(dee);
		else 				phiL[j] = 0.0;
     }
	 return;
}

void PotentialAvenger::updateLevelSetNL( const unsigned& i, vector<unsigned>& nbiter, vector<Segment*>& segments, const vector<double>& pg, const vector<double>& wg ) {
	//non-local nodes   

	//save phiNL beforehand
	vector<double> phiNL_before = phiNL;
 
    for (unsigned l = 0; l < segments.size(); ++l) {
        if (segments[l]->size()==0) continue;//segments.erase(segments.begin()+l);
        unsigned sbegin = segments[l]->begin();
        unsigned send = segments[l]->end();
        
		//clear Ybar
		segments[l]->YbarmYc = 0.0;
 
        //skip if all negative
        bool allNeg = true;
        for (unsigned k = sbegin; k <= send; ++k) {
            if (phiNL[k] != -1) {
                allNeg = false;
                break;
            }
        }
        if (allNeg) continue;
        
        double err_crit = 1e15;
        double dphi = 0;
        nbiter[i] = 0;
        double residu = 0;
//cout << "int: [" << sbegin << "," << send<< "]  dmax = " << dm.dval(segments[l].phipeak) << "  phimax = " << segments[l].phipeak << "  ," << 
//"  x= " << segments[l].xpeak << "   slope = " << segments[l].slope <<
//endl;

        if (segments[l]->phipeak <= 0) continue;

        double YbarmYc = 1.0;           
        while (err_crit > 1.e-6 && nbiter[i] < 50) {
            nbiter[i]++;

			double tangent_Y = 0.0;
            double phimin = 0.0;
			double phimax = 0.0; 
            double phiminY = 0.0;
			double phimaxY = 0.0;
			double Ycavg = 0.0; 
            unsigned status = calculateYbar(pg,wg,Ycavg,YbarmYc,tangent_Y,phimin,phimax,phiminY,phimaxY,nbiter[i],sbegin,send,segments[l]);
			if (status == 0) goto next;
			if (YbarmYc < 0 && nbiter[i] == 1) cout << YbarmYc << "  skipped!" << endl;
			if (YbarmYc < 0 && nbiter[i] == 1) goto next;

            int flag = 1; //0 is exterior (damage centered on edge of domain); 1 is interior
            if (l == 1 && segments[l]->begin() == 0) flag = 0;
            if (l == segments.size()-1 && segments[l]->end() == Nnod-1) flag = 0;

            residu = YbarmYc;
            err_crit = fabs(residu)/Ycavg;

//            double tangent = (tangent_Y + 0*(phiminY-Ycavg)*dm.dp(phimin) )/( dm.dval(phimax)-0*dm.dval(phimin) ) - residu * dm.dp(phimax)/dm.dval(phimax);
            double tangent = (tangent_Y + (phiminY-Ycavg)*dm.dp(phimin) )/( dm.dval(phimax)-dm.dval(phimin)) - dm.dp(phimax)/pow(dm.dval(phimax)-dm.dval(phimin),1) * residu;
            if (flag) tangent = (tangent_Y + 0.5*(phiminY-Ycavg)*dm.dp(phimin) - 0.5*(phimaxY-Ycavg)*dm.dp(phimax) )/( Ycavg*(dm.dval(phimax)-dm.dval(phimin)) ) - (dm.dp(phimax) - dm.dp(phimin) )/pow(dm.dval(phimax)-dm.dval(phimin),1) * (YbarmYc/Ycavg);
                //double tangent = (tangent_Y + static_cast<double>(flag)*(phimaxY-Yc[iphimax])*dm.dp(phimax)/2.0)/( Yc*(dm.dval(phimax)-dm.dval(phimin)) ) - ((1.0+static_cast<double>(flag)/2.0)*dm.dp(phimax)/pow(dm.dval(phimax)-dm.dval(phimin),2)) * (YbarmYc/Yc);
//cout << "dphi = " << dphi;
            if (fabs(tangent) <= 1.e-10) {
                /*err_crit = 0.;*/ dphi = 0.;
            } else {
                dphi = - residu/tangent;
            }
			if (err_crit <= 1.e-6) dphi = 0.0;
            if (isnan(dphi)) {
                dphi = 0;
                assert(1==0);                
            }

            for (unsigned j = sbegin; j <=send; ++j) {
                phiNL[j] += dphi;//phiNL_before[j] + dphi;
                //phiNL[j] = max(phiNL[j],phiNL_1[j]); //constraint: dphi >= 0
                //enforcing limit of level-set motion
                //phi[j] = min(phi_1[j]+h,phi[j]);
            }
        } //while
		assert(YbarmYc/Yc <= 1.e-6);
            for (unsigned j = sbegin; j <=send; ++j) {
                phiNL[j] = max(phiNL[j],phiNL_1[j]); //constraint: dphi >= 0
            }
        next:
        err_crit = 0.0;
        segments[l]->setPeak(x,phiNL); //segments[l].phipeak += dphi; 

    } //for segments

    return;
}

unsigned PotentialAvenger::calculateYbar(const vector<double>& pg, const vector<double>& wg, double& Ycavg, double& YbarmYc, double& tangent_Y, double& phimin, double& phimax, double& phiminY, double& phimaxY, unsigned& nbiter, const unsigned sbegin, const unsigned send, Segment* segment) {
    double residu_Y = 0; 
    tangent_Y = 0.0; 
    unsigned loop_residu = 0;
    unsigned loop_tangent = 0;

	double segLength = 0;
	Ycavg = 0.0;

    phimin = phiNL[sbegin];
    unsigned iphimin = sbegin;

    for (unsigned j = max(0,static_cast<int>(sbegin)-1); j <= min(send+1,Nelt-1); ++j) {
        if (j < 0) continue;

		if (inTLSnode[j] == 0) continue;

        assert(pg.size() == wg.size());

        if (phiNL[j] > 0 && phiNL[j+1] > 0) {
            for (unsigned k = 0; k < pg.size(); ++k) {
                double philoc = 0;
                if (segment->slope == 1 && x[j+1] > segment->xpeak && x[j] < segment->xpeak) {//if peak is within element, only integrate the side with the proper slope
                    double delta = segment->xpeak - x[j];
                    assert(delta > 0); assert( delta < h);
                    philoc = pg[k]*(phiNL[j] + delta) + (1-pg[k]) * phiNL[j+1];              //shift quadrature to interval of interest
                } else if (segment->slope == -1 && x[j+1] > segment->xpeak && x[j] < segment->xpeak) { //if peak is within element, only integrate the side with the proper slope
                    double delta = segment->xpeak - x[j];
                    assert(delta > 0); assert( delta < h);
                    philoc = pg[k]*phiNL[j] + (1-pg[k]) * (phiNL[j] + delta);               //shift quadrature to interval of interest
                } else {
                    philoc = pg[k]*phiNL[j] + (1-pg[k]) * phiNL[j+1];
                }
                residu_Y += h * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dp(philoc);
                tangent_Y += h * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dpp(philoc);
            }
            loop_residu++;
			segLength += 1.0;
			Ycavg += Ycv[j];

        } else if  (phiNL[j] > 0 && phiNL[j+1] <= 0) {
            double delta = h * fabs(phiNL[j]) / (fabs(phiNL[j])+fabs(phiNL[j+1])); //phi>0 portion
            for (unsigned k = 0; k < pg.size(); ++k) {
                double philoc = pg[k] * phiNL[j];
               residu_Y += delta * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dp(philoc);
                tangent_Y += delta * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dpp(philoc);
            }
            loop_residu++;
			segLength += delta/h;
			Ycavg += Ycv[j]*delta/h;
			phimin = 0.0;
			iphimin = j;
            if (fabs(delta-h) > h*0.0001) tangent_Y += (0.5 * E * e[j] * e[j] - dH(j,0.0) - Ycv[j])* dm.dp(0.);
            else tangent_Y += (0.5 * E * e[j+1] * e[j+1] - dH(j,0.0) - Ycv[j])  * dm.dp(0.);
            loop_tangent = loop_tangent + 1;
        } else if  (phiNL[j] <= 0 && phiNL[j+1] > 0) {
            double delta = h * fabs(phiNL[j+1]) / (fabs(phiNL[j])+fabs(phiNL[j+1])); //phi>0 portion
            for (unsigned k = 0; k < pg.size(); ++k) {
                double philoc = pg[k] * phiNL[j+1];
                residu_Y += delta * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dp(philoc);
                tangent_Y += delta * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dpp(philoc);
           }
           loop_residu++;
			segLength += delta/h;
			Ycavg += Ycv[j]*delta/h;
			phimin = 0.0;
			iphimin = j;

           if (delta < h) tangent_Y += (0.5 * E * e[j] * e[j] - dH(j,0.0) - Ycv[j])* dm.dp(0.); //%todo-doublecheck this  
           else tangent_Y += (0.5 * E * e[j] * e[j] - dH(j,0.0) - Ycv[j])  * dm.dp(0.);   //%todo-doublecheck this
           loop_tangent++;
                    
        }
     }//end loop-nodes

    phimax = phiNL[sbegin];
    unsigned iphimax = sbegin;
    for (unsigned k = sbegin; k <= send; ++k) {
       if (phiNL[k] > phimax) {
            phimax = phiNL[k];
            iphimax = k;
        }
        if (phiNL[k] < phimin && phiNL[k] >= 0) {
            phimin = phiNL[k];
            iphimin = k;
        }
    }
    if (dm.dval(phimin) == 1 && nbiter == 1) return 0;
    if (phimin == phimax) return 0;

    phimaxY = 0.0;
    if (iphimax == Nnod-1) phimaxY = 0.5*E*pow(e[Nelt-1],2) - dH(iphimax, dm.dval(phimax)); //1/2*s(i,Nelt)*e(i,Nelt);
    else {
        phimaxY = 0.5*E*pow(e[iphimax],2);// 1/2*s(i,iphimax)*e(i,iphimax);
        for (unsigned k = 0; k < d_quad_wt[iphimax].size(); ++k) {
	        phimaxY -= d_quad_wt[iphimax][k] * dH(iphimax,d_quad[iphimax][k]);
        }
    }

    phiminY = 0.0;
    if (iphimin == Nnod-1) phiminY = 0.5*E*pow(e[Nelt-1],2) - dH(iphimin, dm.dval(phimin)); //1/2*s(i,Nelt)*e(i,Nelt);
    else {
		phiminY = 0.5*E*pow(e[iphimin],2);// 1/2*s(i,iphimax)*e(i,iphimax);
        for (unsigned k = 0; k < d_quad_wt[iphimin].size(); ++k) {
            phiminY -= d_quad_wt[iphimin][k] * dH(iphimin,d_quad[iphimin][k]);
        }
    }

                    
    YbarmYc = residu_Y/(dm.dval(phimax)-dm.dval(phimin));
    segment->YbarmYc = YbarmYc;
	assert(segLength > 0.0);
	Ycavg /= segLength;

	return 1;
}

void PotentialAvenger::nucleate(const double t, const std::vector<double>& xnuc, const std::vector<double>& phinuc, std::vector<Segment*>& newSegment, const std::string& elemOrNodal){
    //t      -time
    //x      -mesh
    //phi    -level-set calculated at this time-step
    //xnuc   -location(s) of localizations to be nucleated
    //phinuc -amount of the level-set to be set at nucleated localizations

    assert(xnuc.size() == phinuc.size());
    assert(xnuc.size() > 0);

    for (unsigned j = 0; j < xnuc.size(); ++j) {
        int loc = -1;
        double delta = 0;
        nucleated++;
        for (unsigned i = 0; i < x.size()-1; ++i) {
            if ((xnuc[j] >= x[i]) && (xnuc[j] < x[i+1])) {
                loc = i;
                delta = (xnuc[j] - x[i])/h;
                break;
            }

        }
        if (loc == -1 && xnuc[j] == 1.0) {
			loc = Nnod - 1;
			delta = 0.0;
		}

        assert(loc != -1);
        double proposed1 = phinuc[j] - delta*h;
        double proposed2 = phinuc[j] - (1-delta)*h;
        if (elemOrNodal.compare("nodal") == 0) {
			assert(delta == 0.0);

            inTLSnode[loc] = 1;
            inTLS[loc] = 1;
            if (loc > 0) inTLS[loc-1] = 1;
            if (loc > 0) inTLSnode[loc-1] = 1;
            inTLSnode[loc+1] = 1;
        
            double gradient = 0;
            if (loc >= 1) {
                if (d_1[loc] > d_1[loc-1]) gradient = 1.0; else gradient = -1.0;
                if (d_1[loc] < d_1[loc-1]) gradient = -1.0;
            } else gradient = -1.0;
            assert(gradient != 0);
	        if (gradient == 1.0) {
				assert(loc >= 1);
				double phicrit = max(max(phiL[loc-1],phiL[loc]),phiNL[loc]);
				phiNL[loc-1] = max(max(phicrit-h,phiL[loc-1]),phiNL[loc-1]);
				phiNL[loc] = phicrit;
				if (loc+1 < static_cast<int>(Nnod)) phiNL[loc+1] = max(phicrit,phiL[loc+1]);
				if (loc+1 < static_cast<int>(Nnod)) delta = 0.5 * (h + phiNL[loc+1] - phiNL[loc]);
    	    } else {
                assert(loc <= static_cast<int>(Nnod)-1);
                double phicrit = max(max(phiL[loc-1],phiL[loc]),phiNL[loc]);
                //phiNL[loc+1] = max(phicrit-h,phiNL[loc+1]); //max(max(phicrit-h,phiL[loc+1]),phiNL[loc+1]);
                phiNL[loc+1] = max(max(phicrit-h,phiL[loc+1]),phiNL[loc+1]);
                phiNL[loc] = phicrit;
                if (loc-1 >= 0) phiNL[loc-1] = max(phicrit,phiL[loc-1]);
				if (loc-1 >= 0) delta = 0.5 * (-h + phiNL[loc] - phiNL[loc-1]);

        	}
             //create two new segments
             if (xnuc[j] > x[0]) {
                 Segment* seg1 = new Segment(xnuc[j]+delta,phiNL[loc]+fabs(delta),-1);
                 seg1->indices.push_back(loc);
                 newSegment.push_back(seg1);
             }
             if (xnuc[j] < x.back()) {
                 Segment* seg2 = new Segment(xnuc[j]+delta,phiNL[loc]+fabs(delta),1);
                 seg2->indices.push_back(loc+1);
                 newSegment.push_back(seg2);
             }

        } else {
			//elem nucleation
			inTLSnode[loc] = 1;
			inTLSnode[loc+1] = 1;
			inTLS[loc] = 1;
			proposed1 = max(proposed1, dm.phi(d_1[loc]));	
			proposed2 = max(proposed2, dm.phi(d_1[loc]));
			if (loc > 0) proposed1 = max(proposed1, dm.phi(d_1[loc-1]));	
			if (loc > 0) proposed2 = max(proposed2, dm.phi(d_1[loc-1]));	
			if (loc < (int)Nnod-1) proposed1 = max(proposed1, dm.phi(d_1[loc+1]));	
			if (loc < (int)Nnod-1) proposed2 = max(proposed2, dm.phi(d_1[loc+1]));	
            phiNL[loc] = max(phiNL[loc], proposed1);
            phiNL[loc+1] = max(phiNL[loc+1], proposed2);

double zero = 0.0;
            //create two new segments
            if (xnuc[j] > x[0]) {
                 Segment* seg1 = new Segment(xnuc[j]-delta*h*zero,phinuc[j]-delta*h*zero,-1);
                 seg1->indices.push_back(loc);
                 newSegment.push_back(seg1);
             }
             if (xnuc[j] < x.back()) {
                 Segment* seg2 = new Segment(xnuc[j]+(1-delta)*h*zero,phinuc[j]-(1-delta)*h*zero,1);
                 seg2->indices.push_back(loc+1);
                 newSegment.push_back(seg2);
             }

        }
        printf("crack nucleated, t = %f, x = %f \n",t,xnuc[j]);
        
        //now that there has been nucleation, get rid of zero-slope segments
        vector<unsigned> delList;
        for (unsigned i = 0; i < newSegment.size(); ++i) {
            if (newSegment[i]->slope == 0 || newSegment[i]->phipeak == -1) delList.push_back(i);
        }
        while (delList.size() > 0) {
            unsigned index = delList.back(); 
            newSegment.erase(newSegment.begin() + index);
            delList.pop_back();
        }

    }
};

vector<double> PotentialAvenger::findFragments(DamageModel& dm, const std::vector<double>& phiLocal, const std::vector<double>& phiNonLocal, unsigned& nfrags, const vector<Segment*>& segments) {
    
    //calculate total number of fragments (removing symmetry simplification)
    vector<double> fragLength = fragmentLength(segments); 
    nfrags = fragLength.size();
    fragmentStats(fragLength);   

    return fragLength; 
};


vector<double> PotentialAvenger::fragmentLength(const vector<Segment*>& segments) { 
	
    vector<double> fragLength;
    double powderLength = 0.0;

	//assign indices to fragments
    int begin = -1;
    int firstbegin = -1;
    for (unsigned j = 0; j < Nelt; ++j) {
		//don't add damage if whole element is damaged, either local or nonlocal
        if ( (phiL[j] >= lc) || (phiNL[j] >= lc && phiNL[j+1] >= lc && fabs(phiNL[j]-phiNL[j+1]) == h) ) {
			begin = -1;
			powderLength += h;
            continue;
		}

	    double solidLength = h;	
		
		//element partially failing (simple)
		if ( (phiNL[j] >= lc || phiNL[j+1] >= lc) && ( fabs(phiNL[j]-phiNL[j+1]) == h) ) {
			if (phiNL[j] < phiNL[j+1]) {
				double delta = lc - phiNL[j];
				assert(delta >= 0); assert(delta <= h);
			    fragLength.back() += delta;	
			    powderLength += (h - delta);
			    
			    solidLength = 0.0;
			    begin = -1;
			} else if (phiNL[j] > phiNL[j+1]) {
                double delta = phiNL[j] - lc;
                assert(delta >= 0); assert(delta <= h);
                powderLength += delta;
                
                fragLength.push_back(0.0); //end old fragment, find length for new one
                solidLength = h - delta;
                begin = j;
			} else {
				assert(1==0);
			}
		}

		//element partially failing (hat)
		if ( (fabs(phiNL[j]-phiNL[j+1]) < h) && (phiNL[j] >= lc-h && phiNL[j+1] >= lc-h) ) {

			bool hasPeak = false;
			//check for peaks -> hasPeak (false = antipeak, true = peak)
			for (unsigned l = 0; l < segments.size(); ++l) {
				if ( (segments[l]->xpeak >= x[j]) && (segments[l]->xpeak <= x[j+1]) ) hasPeak = true;
			}

            if (hasPeak) {
				//peak
				solidLength = 0.0;
				double delta = 0.5 * (phiNL[j+1] - phiNL[j] + h);
				assert(delta >= 0); assert(delta <= h);
				assert(phiNL[j] + delta >= lc);
				//check for & deal with intersection on first slope
				double s  = lc - phiNL[j];
                assert(s <= delta);
				if (s > 0) {
					fragLength.back() += s;
					powderLength += (delta - s);
				} else {
					powderLength += delta;
				}
				begin = -1;

				//check for & deal with intersection on second slope
                 s  = phiNL[j] + delta - lc;
                assert(s >= 0);
                if (s < (h-delta)) {
                    powderLength += s;
			        fragLength.push_back(0.0);
					begin = j;
					solidLength = (h-delta)-s;
                } else {
                    powderLength += h-delta;
                }


			} else {
				//anti-peak
				double delta = 0.5 * (phiNL[j] - phiNL[j-1] + h);
				if (fabs(delta) < 0.0001) delta = 0.0; if (fabs(delta)-h < 0.0001) delta = h;
				assert(delta >= 0); assert(delta <= h);
				solidLength = 0.0;
                if (phiNL[j] - delta <= lc) {
        	        assert(phiNL[j] >= lc || phiNL[j+1] >= lc);
    	            //check for & deal with intersection on first slope
	                double s  = phiNL[j] - lc;
                	assert(s <= delta);
            	    if (s > 0) {
        	            powderLength += s;
						begin = -1;
	                    solidLength = (delta - s);
                	} else {
            	        fragLength.back() += delta;
        	        }
                
    	            //check for & deal with intersection on second slope
	                s  = lc - phiNL[j] + delta;
                	assert(s >= 0);
            	    if (s < (h-delta)) {
						solidLength += s;
						fragLength.push_back(solidLength);
						solidLength = 0.0;
						powderLength += (h-delta) - s;
						begin = -1;
            	    } else {
        	            solidLength += (h-delta);
						begin = j;
	                }
				} else {
					//whole thing failed
					powderLength += h;
					begin = -1;		
				}
			}//end peak/antipeak
		} //end hat
		
		if (firstbegin == -1) firstbegin = j;
		if (begin == -1) {
			begin = j;
			fragLength.push_back(0.0);
		}
		assert(solidLength <= h); assert(solidLength >= 0.0);
		fragLength.back() += solidLength;
	
    }

	//copy for negative side
    unsigned numFL = fragLength.size();
	//double length of first fragment if it was intact (firstbegin)
    if (firstbegin == 0 && numFL > 0) fragLength[0] *= 2.0;
	else fragLength.push_back(fragLength[0]);
    for (unsigned j = 1; j < numFL; ++j) fragLength.push_back(fragLength[j]);
	powderLength *= 2;

	assert( (fragLength.size() == numFL*2 && firstbegin != 0) || (fragLength.size() == numFL*2-1 && firstbegin == 0) );

	//length check
    double sumfrag = 0.0;
	for (unsigned j = 0; j < fragLength.size(); ++j) 	sumfrag += fragLength[j];
cout << "   sumfrag = " << sumfrag << "      powderfrag = " << powderLength << "    = " << sumfrag+powderLength << endl;
    assert(fabs(sumfrag + powderLength - L * 2.0) < h * 0.5);

	return fragLength;
};

unsigned PotentialAvenger::checkFailureCriteria(const unsigned ts, std::vector<double>& criterion, const std::string elemOrNodal, const std::vector<double>& qty, const bool absOrAsIs, const bool phiPos, const double failvalue, std::vector<Segment*>& newSegment, vector<unsigned>& nbiter, const vector<double>& pg, const vector<double>& wg){

    //x              -mesh
    //phi            -level-set calculated at this time-step
    //criterion      -criterion to compare against for failure
    //elemOrNodal    -either 'elem' or 'nodal' - is criterion elemental or nodal
    //qty            -the quantity to be compared to the criterion -e.g. s,Y
    //absOrAsIs      -whether to compare (0) qty or (1) abs(qty) to criterion
    //phiPos         -whether(1) or not(0) failure cannot occur depending on if phi>0
    //failvalue      -what to call phi at localization zone if created - e.g. h
    //failure if qty > criterion
	//return: xlist - number of nucleations performed

    vector<double> margin;
    vector<unsigned> index;

    assert(elemOrNodal.compare("elem") == 0 || elemOrNodal.compare("nodal") == 0);
    assert(absOrAsIs == false || absOrAsIs == true);
    if (elemOrNodal.compare("nodal") == 0) {
        assert(x.size() == qty.size());
    } else {
        assert(x.size() == qty.size()+1);
    }
    assert((qty.size() == criterion.size()) || (criterion.size() == 1));

    if (criterion.size() == 1) {
        double val = criterion[0];
        criterion.assign(qty.size(),val);
    }
    vector<double> xlist;
    for (unsigned i = 0; i < qty.size(); ++i) {
        if (phiPos == 0) {//can't fail if phi>0
            if (elemOrNodal.compare("nodal") == 0) {
                if (phi[i] > 0) continue;
            } else {
                if (phi[i]>0 || phi[i+1]>0) continue;
            }
        }
        double qtyc = qty[i];
		//can't fail if already nucleated
        double minOpen = max(h,minOpenDist);
        for (unsigned j = 0; j < newSegment.size(); ++j) {
            if (nucleated == 0) continue;	// the null level-set can't be an impediment to nucleation		
            
			if (elemOrNodal.compare("nodal") == 0) {
                if (fabs(newSegment[j]->xpeak-x[i]) < minOpen) goto nextLoop;
            } else {
                double xavg = 0.5*(x[i] + x[i+1]);
                if (fabs(newSegment[j]->xpeak - xavg) < minOpen) goto nextLoop;
            }
		}

		//compare against arelady accepted nucleation sites - xlist
        for (unsigned j = 0; j < xlist.size(); ++j) {
            if (elemOrNodal.compare("nodal") == 0) {
                if (fabs(xlist[j]-x[i]) < minOpen) goto nextLoop;
            } else {
                double xavg = 0.5*(x[i] + x[i+1]);
                if (fabs(xlist[j] - xavg) < minOpen) goto nextLoop;
            }
        }
		
		if (absOrAsIs) {
            qtyc = fabs(qtyc);
        }

        if (qtyc > criterion[i]) {
            if (elemOrNodal.compare("nodal") == 0) {
                xlist.push_back(x[i]);
            } else {
                //assume middle of element
                xlist.push_back(0.5*(x[i]+x[i+1]));
            }
            margin.push_back(qtyc/criterion[i]);
            index.push_back(i);
        }
        nextLoop: //jump to here if can't nucleate
        qtyc = 0;
    }


    //limited to one nucleation per timestep - IF OneAtATime=true
    if (oneAtATime) {
        double marmax = 0;
        unsigned index = 0;
        if (xlist.size() > 0){
            for (unsigned i = 0; i < xlist.size(); ++i) {
                if (margin[i] > marmax) {
                    marmax = margin[i];
                    index = i;
                }
            }
            double temp1 = xlist[index];
            xlist.clear(); xlist.push_back(temp1);
            margin.clear(); margin.push_back(marmax);
        }
        assert(xlist.size() <= 1);
    }
    
    if (elemOrNodal.compare("elem") == 0) {
	    for (unsigned i = 0; i < xlist.size(); ++i) {
    	    criterion[index[i]] *= (1-h*1.0*sqrt(1/0.2))*(1-h*1.0*sqrt(1/0.2));  //modify Yc at the location of nucleation by a factor alpha : TODO is this good???
	    }
    }

    //nucleate list
    if (xlist.size() > 0) {
        vector<double> failvalueList = vector<double>(xlist.size(),failvalue);
        nucleate(t[ts],xlist,failvalueList, newSegment, elemOrNodal);
    }
	return xlist.size();
};

void PotentialAvenger::analyzeDamage(const vector<double>& x, vector<double>& phiV, const double h, vector<Segment*>& newSegment) {

    //produce:
    //new phi based on distances - maxima

    //if all negative one, skip
    unsigned sum = 0;
    for (unsigned i = 0; i < phiV.size(); ++i) {
        if (phiV[i] > -1) sum++;
    }
    if (sum == 0) return;
    if (nucleated == 0) return;

    vector<double> list_max;
    vector<double> value_max;
    vector<double> slope;
    sort(newSegment.begin(), newSegment.end());
   
    assert(x.size() >= 1);

    //simply use pre-defined segments
    if (newSegment.size() == 0) return;
    for (unsigned i = 0; i < newSegment.size(); ++i) {
        //assert(newSegment[i].size() > 0);
        list_max.push_back(newSegment[i]->xpeak);
        value_max.push_back(newSegment[i]->phipeak);
        slope.push_back(newSegment[i]->slope);
        newSegment[i]->indices.clear();
    }

    //delete segments, make new ones
    unsigned nSegs = newSegment.size();
	for (unsigned i = 0; i < nSegs; ++i) delete newSegment[i];
    newSegment.clear();
    newSegment.resize(nSegs*2);
	for (unsigned i = 0; i < nSegs*2; ++i) newSegment[i] = new Segment(); 
    vector<unsigned> removeList;

    //re-define segments.indices and phi
    vector<double> phinew = vector<double>(phiV.size(),-1);
    for (unsigned i = 0; i < phiV.size(); ++i) {
        
        int segphimin = -1;
        double min = 9999999999;
        for (unsigned k = 0; k < value_max.size(); ++k) {
            if (value_max.size() > 1 && value_max[k] == 0.0) continue;
            double qty = -value_max[k] + fabs(x[i] - list_max[k]);
            if (qty < min) {
                min = qty;
                segphimin = k;
            }
        }
        assert(segphimin > -1);

        phinew[i] = -min;
        if (x[i] < list_max[segphimin])     newSegment[2*segphimin]->indices.push_back(i);
        if (x[i] >= list_max[segphimin])     newSegment[2*segphimin+1]->indices.push_back(i);
        //assert(newSegment[segphimin].slope != 0);
        if (phiV[i] > phinew[i] && inTLSnode[i] == 0) {
//            cout << "i = " << i << " shouldn't be in TLS: phi = " << phiV[i] << " , phinew = " << phinew[i] << endl;
            removeList.push_back(i);
        }
        phinew[i] = max(phinew[i],phiV[i]);
    }

    // need to remove not-in-TLS from segments 
    for (unsigned i = 0; i < removeList.size(); ++i) {
        int index = removeList[i];
        for (unsigned j = 0; j < newSegment.size(); ++j) {
            for (unsigned k = 0; k < newSegment[j]->indices.size(); ++k) {
                if (newSegment[j]->indices[k] == index) {
                    newSegment[j]->indices.erase(newSegment[j]->indices.begin() + k);
//                  cout << "  removed index " << index << " from segment " << j << endl;
                    break;
                }
            }
        }
    }


    //delete empty segments; set slope
    vector<unsigned> delList;
    for (unsigned i = 0; i < newSegment.size(); ++i) {
        if (newSegment[i]->size() == 0) {                            //delete empty
            delList.push_back(i);        
            continue;
        }

        if (phinew[newSegment[i]->begin()] < phinew[newSegment[i]->end()]) newSegment[i]->slope = 1;
        else if (phinew[newSegment[i]->begin()] > phinew[newSegment[i]->end()]) newSegment[i]->slope = -1;
        else newSegment[i]->slope = 0;
    }
    while (delList.size() > 0) {
        unsigned index = delList.back(); 
        newSegment.erase(newSegment.begin() + index);
        delList.pop_back();
    }

    unsigned tot_indices = 0;
    for (unsigned i = 0; i < newSegment.size(); ++i) {
        newSegment[i]->setPeak(x,phinew);
        tot_indices += newSegment[i]->size();
        if (newSegment[i]->phipeak> 0 ) assert(newSegment[i]->indices.size() <= x.size());
    }

    assert(tot_indices + removeList.size() == x.size());

    //return phinew as phi
    for (unsigned i = 0; i < phiV.size(); ++i) {
        phiV[i] = phinew[i];
    }

    if (nucleated == 0) assert(nSegs == newSegment.size());
    
    //ensure that segment indices are contiguous
    bool flag = true;
    while (flag == true) {
    flag = false;
        for (unsigned j = 0; j < newSegment.size(); ++j) {
            if (newSegment[j]->indices.size() <= 1) continue;
            // if not contiguous, split
            if (newSegment[j]->end() != newSegment[j]->begin() + newSegment[j]->indices.size() - 1) {
				flag = true;
                int loca = -1;
                for (unsigned k = 1; k < newSegment[j]->indices.size(); ++k) {
                    if (newSegment[j]->indices[k] != newSegment[j]->indices[k-1] + 1) {
						loca = k;
						break;
					}
                }
				assert(loca > -1);
				//move loca & later to new segment, erase from original
				//Segment seg = Segment();
				//newSegment.push_back(seg);
				newSegment.push_back(new Segment());
				for (unsigned k = loca; k < newSegment[j]->indices.size(); ++k) newSegment.back()->indices.push_back(newSegment[j]->indices[k]);
				newSegment.back()->setPeak(x,phinew);
				newSegment.back()->slope = newSegment[j]->slope;
				newSegment[j]->indices.resize(loca);
            }
            assert(newSegment[j]->end() == newSegment[j]->begin() + newSegment[j]->indices.size() - 1);
        }
    }

};  

void PotentialAvenger::printRunInfo() {
    cout << endl;
    cout << "Run Info:" << endl;
    cout << "Strain rate = " << strain_rate << endl;
    cout << "# Elements = " << Nelt << endl;
    cout << "End Time (s) = " << end_t << endl;
    cout << "Time-step refinement ratio = " << ts_refine << endl;
    cout << "Damage gradient length (lc) = " << lc << endl;
    cout << "Beginning run... " << endl;
    cout << endl;

};

void PotentialAvenger::plotEnergies () {
    // Gnuplot file for energies
    FILE * pFileW;
    std::string stressFile = _path+"/gnuplot/plotEnrg.plt";		//../results
    pFileW = fopen( stressFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Global energies\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"energy (J)\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgSpr.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'Wspr' w l\n" );
    fprintf( pFileW, "set output './pngFiles/enrgDissip.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:3 ti 'Wdissip' w l, \\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:8 ti 'local' w l, \\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:9 ti 'non-local' w l \n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgExt.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:4 ti 'Wext' w l\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgKin.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:5 ti 'Wkin' w l\n\n" );
    fprintf( pFileW, "set ylabel \"Energy Balance Check\"\n" );
    fprintf( pFileW, "set output './pngFiles/enrgBalance.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:(abs($7)) ti 'Wsum' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:6 ti '0.01 * Wmax' w l\n\n" );
    fprintf( pFileW, "set ylabel \"J/s\"\n" );

    fprintf( pFileW, "set output './pngFiles/enrgAll.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'Wspr' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:3 ti 'Wdis' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:4 ti 'Wext' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:5 ti 'Wkin' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:(abs($2+$3+$5)) ti 'Wsum' w l\n\n");

    fclose( pFileW );

    // Prepare Gnuplot data file
    _EnrgFile = _path+"/datFiles/energies.dat";		//../results
    FILE * pFile;
    pFile = fopen( _EnrgFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Total energies for the system\n" );
    fprintf( pFile, "#       time        Wspr        Wdis        Wext");
    fprintf( pFile, "        Wkin   0.01*Wmax        Wsum\n" );
    fclose( pFile );
}

void PotentialAvenger::plotFrags (){
    // Gnuplot file for fragmentation
    FILE * pFileW;
    std::string fragFile = _path+"/gnuplot/plotFragInfo.plt";		//../results
    pFileW = fopen( fragFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Fragmentation Information\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"Number of Fragments\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/numFrag.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraginfo.dat' usi 1:3 ti 'Sum of Damage' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/fraginfo.dat' usi 1:2 ti '# Frags' w l\n\n" );

    fclose( pFileW );

    // Prepare Gnuplot data file
    _FragFile = _path+"/datFiles/fraginfo.dat";		//../results
    FILE * pFile;
    pFile = fopen( _FragFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#       time      #frags   DamageSum        Mean      Median         Max         Min");
    fprintf( pFile, "       StDev       Range        Skew    Ex. Kurt.");
    fprintf( pFile, "((R*L^2)/|L|) (Locations)\n");
    fclose( pFile );
}

void PotentialAvenger::plotHisto () {
    // Gnuplot file for fragmentation histogram
    FILE * pFileW;
    std::string histoFile = _path+"/gnuplot/plotHisto.plt";		//../results
    pFileW = fopen( histoFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "set title \"Fragment Length CDF Graph\"\n"); 
    fprintf( pFileW, "set xlabel \"Fragment Length, Lf (m)\"\n" );
    fprintf( pFileW, "set ylabel \"# ( Length > Lf )\"\n" );
    if (_numFrag > 0) fprintf( pFileW, "set yrange [0:%u]\n", _numFrag);
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/fraginvcdf.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' usi 1:2 ti '' w l;\n\n" );
    fprintf( pFileW, "set boxwidth 0.9 absolute\n" );
    fprintf( pFileW, "set style fill   solid 1.00 border -1\n" );
    fprintf( pFileW, "set title \"Fragmentation Histogram\"\n"); 
    fprintf( pFileW, "set xlabel \"Size Distribution Relative to Max. Frag. Size (Percent)\"\n" );
    fprintf( pFileW, "set ylabel \"Frequency\"\n" );
    fprintf( pFileW, "set xrange [0:100]\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/fragHisto.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' using 3:4:(4) ti '' with boxes;\n" );
    fclose( pFileW );

    // Prepare Gnuplot data file
    _HistoFile = _path+"/datFiles/fraghisto.dat";		//../results
    FILE * pFile;
    pFile = fopen( _HistoFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#Length, Lf   # With Length > Lf   Bin Center   Frequency\n" );
    fclose( pFile );
}

void PotentialAvenger::plotSTheta () {
	// Gnuplot file for fragmentation histogram
	FILE * pFileW;
	std::string sThetaFile = _path+"/gnuplot/plotSTheta.plt";	//../results/
	pFileW = fopen( sThetaFile.c_str(), "w" );
	fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
	fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
	fprintf( pFileW, " -- MH[DCML] (2010)\n");
	fprintf( pFileW, "datafile = './datFiles/stresstheta.dat'\n");
	fprintf( pFileW, "stats datafile;\n");
	fprintf( pFileW, "set title \"Cohesive Link Stress vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaCL.svg'\n");
	fprintf( pFileW, "plot for[i=1:1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 4:5 ti 'Link Stress' w l;\n\n" );
	fprintf( pFileW, "set title \"Spring Element Stress vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaSE.svg'\n");
	fprintf( pFileW, "plot for[i=1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 2:3 ti 'Spring Stress' w l;\n\n" );
	fprintf( pFileW, "set title \"Cohesive Link Damage vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Damage\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaCLD.svg'\n");
	fprintf( pFileW, "plot for[i=1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 4:6 ti 'Damage' w l;\n\n" );
	fclose( pFileW );

    // Prepare Gnuplot data file
	_SThetaFile = _path+"/datFiles/stresstheta.dat";		//../results

    FILE * pFile;
    pFile = fopen( _SThetaFile.c_str(), "w" );
    	fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#Time       SprTheta    SprStress   CohTheta    CohStress           i         _Nt\n" );
    fclose( pFile );
}

/*------------------------------ P R I V A T E -------------------------------*/


void PotentialAvenger::printVtk ( const unsigned timStepNum ) const {

    // Build a name for the vtk file
    std::string resuPath = _path+"/vtkFiles/";			//../results
    unsigned zeroNum = 6 - (unsigned) floor( log10( timStepNum ) );
    std::string baseName = "ring_";//+ convertInt(_myid) + "_";
    for ( unsigned i = 0; i < zeroNum; i++ ) {
        baseName += "0";
    }
    baseName += convertInt(timStepNum);
    std::string vtkFile = resuPath + baseName + ".vtk";

    // Print in the vtk file
    printHeader ( vtkFile );
    unsigned Ncell = printMesh ( vtkFile );
    printPointData ( vtkFile );
    printCellData ( vtkFile, Ncell );
}

void PotentialAvenger::printHeader ( const std::string& vtkFile ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "w" );
    fprintf ( pFile, "# vtk DataFile Version 2.0\n" );
    fprintf ( pFile, "Generated by <ring.h> -- MH [DCML] (2010)\n" );
    fprintf ( pFile, "ASCII\nDATASET UNSTRUCTURED_GRID\n\n" );
    fclose( pFile );
}

unsigned PotentialAvenger::printMesh ( const std::string& vtkFile ) const {
    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    fprintf ( pFile, "POINTS %d float\n", Nnod);
    for ( unsigned i = 0; i < Nnod; i++ ) {
        double xx = x[i];			//NodPos
        double y = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", xx, y, 0.0 );
    }

    unsigned Ncell = 0;
    if (visualizeCracks) {
        for ( unsigned i = 0; i < Nelt; i++ ) {
	    	if (d[i] < 1) Ncell++;
    	} 
    } else {
        Ncell = Nelt;
    }

    fprintf ( pFile, "\nCELLS %d %d\n", Ncell, 3*Ncell );
    for ( unsigned i = 0; i < Nelt; i++ ) {
        if (d[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12d %12d %12d\n", 2, i, i+1 );
    }
    fprintf ( pFile, "\nCELL_TYPES %d\n", Ncell );
    for ( unsigned i = 0; i < Nelt; i++ ) {
        if (d[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12d\n", 3 );
    }
    fprintf ( pFile, "\n" );
    fclose( pFile );

    return Ncell;
}

void PotentialAvenger::printPointData ( const std::string& vtkFile ) const {
    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    //int pointData = _NodPos.size();

    fprintf ( pFile, "POINT_DATA %d", Nnod);
    fprintf ( pFile, "\nVECTORS displacements float\n" );
    for ( unsigned i = 0; i < u.size(); i++ ) {
        double dx = printable(u[i]);	//Dis[i][0][0]
        double dy = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", dx, dy, 0.0 );
    }
    fprintf ( pFile, "\nVECTORS velocities float\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) {
        double vx = printable(v[i]);
        double vy = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", vx, vy, 0.0 );
    }
    fprintf ( pFile, "\n" );

    fprintf ( pFile, "\nSCALARS phiNL float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) fprintf ( pFile, " %12.3e \n", printable(phiNL[i]));
    fprintf ( pFile, "\n" );
    
    fprintf ( pFile, "\nSCALARS inTLSnode int\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) fprintf ( pFile, " %u \n", inTLSnode[i]);
    fprintf ( pFile, "\n" );
    
    fprintf ( pFile, "\nSCALARS absGradPhiL float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nnod; i++ ) fprintf ( pFile, " %12.3e \n", printable(fabs(gradPhiL[i])));
    fprintf ( pFile, "\n" );
    
    fprintf ( pFile, "\nSCALARS absGradPhiNL float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nnod; i++ ) fprintf ( pFile, " %12.3e \n", printable(fabs(gradPhiNL[i])));
    fprintf ( pFile, "\n" );
    
    fclose( pFile );
}

void PotentialAvenger::printCellData ( const std::string& vtkFile, const unsigned& Ncell ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    fprintf( pFile, "CELL_DATA %d", Ncell );

    fprintf ( pFile, "\nSCALARS phiL float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) fprintf ( pFile, " %12.3e \n", printable(phiL[i]));
    fprintf ( pFile, "\n" );
    
    fprintf( pFile, "\nSCALARS stress float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", printable(s[i]));
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS strain float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e\n", printable(e[i]));
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS Yraw/Yc float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", printable(e[i]*e[i]*E*0.5/Yc));
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS Y/Yc float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", printable(Y[i]/Yc));
    fprintf( pFile, "\n" );

    fprintf ( pFile, "\nSCALARS damage float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12.3e \n", printable(d[i]));
    fprintf ( pFile, "\n" );

	
    fprintf ( pFile, "\nSCALARS damageRate float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12.3e \n", printable((d[i] - d_1[i]) / dt));
    fprintf ( pFile, "\n" );

    fprintf( pFile, "\nSCALARS inTLS int\n");
    fprintf( pFile, "LOOKUP_TABLE default\n");
    for ( unsigned i = 0; i < Nelt; i++) if (d[i] < 1 || visualizeCracks == 0) fprintf(pFile, "%u \n", inTLS[i]);
    fprintf( pFile, "\n");

    fclose( pFile );
}

void PotentialAvenger::printGlobalInfo () const {

    if ( _EnrgFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _EnrgFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", t[_Nt] );
        fprintf( pFile, "%12.3e", strain_energy );
        fprintf( pFile, "%12.3e", dissip_energy );
        fprintf( pFile, "%12.3e", ext_energy );
        fprintf( pFile, "%12.3e", kinetic_energy );
	fprintf( pFile, "%12.3e", max_energy * 0.01 );
	fprintf( pFile, "%12.3e", tot_energy );
	fprintf( pFile, "%12.3e", dissip_energy_local );
	fprintf( pFile, "%12.3e", dissip_energy_TLS );
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::printFrags (const vector<double>& fragLength) {
    double DSum = 0.0;
    for (unsigned i = 0; i < d.size(); ++i) DSum += d[i];

    if ( _FragFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _FragFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", t[_Nt] );
        fprintf( pFile, "%12u", _numFrag );
        fprintf( pFile, "%12.3f", DSum );
        fprintf( pFile, "%12.3e", _fMean );
        fprintf( pFile, "%12.3e", _fMed );
        fprintf( pFile, "%12.3e", _fMax );
	fprintf( pFile, "%12.3e", _fMin );
	fprintf( pFile, "%12.3e", _fStDev );
	fprintf( pFile, "%12.3e", _fRange );
	fprintf( pFile, "%12.3f", _fSkew );
	fprintf( pFile, "%12.3f", _fExKurtosis );
	if (_numFrag <= 10){
	    for (unsigned i = 0; i < fragLength.size(); i++){
		fprintf( pFile, "%12f", fragLength[i] );
	    }
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::printSTheta () {
    if ( _SThetaFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _SThetaFile.c_str(), "a" );
        //fprintf( pFile, "%12.3e", _T );
	for (unsigned i = 0; i < Nelt; i++) {
	    double sprTheta = (double)(360*(i+0.5))/(double)(Nelt);
	    double cohTheta = (double)(360*(i+1))/(double)(Nelt);
	    fprintf( pFile, "%12.3e", t[_Nt] );
	    fprintf( pFile, "%12.3f", sprTheta );
        fprintf( pFile, "%12.3e", s[i] );
        fprintf( pFile, "%12.3f", cohTheta );
//        fprintf( pFile, "%12.3e", _sigCoh[i] );
        fprintf( pFile, "%12.3e", d[i] );
        fprintf( pFile, "%12.3f", (double)(i) );
        fprintf( pFile, "%12.3f", (double)(_Nt) );
	    fprintf( pFile, "\n" );
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::fragmentStats(const vector<double>& fragLength) {

    if (fragLength.size() == 0) return;

	//Initialize statistics of fragment length distribution
	_fMean = 0;
	_fMed = 0;
	_fMax = 0;
	_fMin = 0;
	_fStDev = 0;
	_fRange = 0;
	_fSkew = 0;
	_fExKurtosis = 0;

	//If there are any fragments...
	//Calculate Median
	// Sort the list in ascending order
	vector<double> fragLengthSort = fragLength;
    sort(fragLengthSort.begin(), fragLengthSort.end());

	if (fragLength.size() % 2 == 0) {
        	//If even number, take average of two middle values
		_fMed = ( fragLengthSort[ (unsigned)(fragLengthSort.size() * 0.5) ]
			+ fragLengthSort[ (unsigned)(fragLengthSort.size() * 0.5) -1 ] ) * 0.5;
	} else {
		//If odd number, take middle value
		_fMed = fragLengthSort[ (fragLengthSort.size() - 1) / 2 ];
	}
	//Calculate Max, Min, Range
	_fMax = fragLengthSort.back();
	_fMin = fragLengthSort.front();
	_fRange = _fMax - _fMin;

	//Calculate Mean
	for (unsigned k = 0; k < fragLengthSort.size(); k++){
		//Sum of lengths
		_fMean += fragLength[k];
	}
    //Mean = sum / number
	_fMean = _fMean / _numFrag;

	//Calculate Std. Deviation
	for (unsigned k = 0; k < fragLengthSort.size(); k++){
		//Sum of squared (lengths - means)
		_fStDev += pow( (fragLengthSort[k] - _fMean), 2);
	}
	_fStDev = sqrt( _fStDev / _numFrag ) ;

	//Calculate Skew
	for (unsigned k = 0; k < fragLengthSort.size(); k++){
		//Sum of squared (lengths - means)
		_fSkew += pow( (fragLengthSort[k] - _fMean), 3);
	}
	_fSkew = _fSkew / (_numFrag * pow(_fStDev,3) );

	//Calculate Kurtosis
	for (unsigned k = 0; k < fragLengthSort.size(); k++){
		//Sum of squared (lengths - means)
		_fExKurtosis += pow( (fragLengthSort[k] - _fMean), 4);
	}
	_fExKurtosis = _fExKurtosis / (_numFrag * pow(_fStDev,4) ) - 3.0;
    return;
}


void PotentialAvenger::printHisto(const std::vector<double>& fragLength) {
    // Prints Histogram and scaled 1-cdf figure
    vector<vector<double> > fragInvCDF;
    vector<unsigned> fHisto;
    vector<double> fragLengthSort = fragLength;

    if (_numFrag > 1) {

        sort(fragLengthSort.begin(), fragLengthSort.end());

		fragInvCDF.resize(2);
		fragInvCDF[0].resize(1000);	//a length, from zero to the max. fragment size
		fragInvCDF[1].resize(1000);	//number of fragments larger than this length
		fHisto.assign(25, 0);		//number of bins for the fragment histogram
	
		//Histogram - 25 bins
		 double max = _fMax;	//size
		//Step through fragment length list; increase count in the bin if fragment fits
		for (unsigned k = 0; k < fragLengthSort.size(); k++){
            double length = fragLengthSort[k];
//            if (fragment_list.size() % 2 == 1) length *= 2; //if not broken from wall, this segment has twice the length
			if (length < max * 0.04) fHisto[0]++;
			if ((length < max * 0.08) && (length >= max * 0.04)) fHisto[1]++;
			if ((length < max * 0.12) && (length >= max * 0.08)) fHisto[2]++;
			if ((length < max * 0.16) && (length >= max * 0.12)) fHisto[3]++;
			if ((length < max * 0.20) && (length >= max * 0.16)) fHisto[4]++;
			if ((length < max * 0.24) && (length >= max * 0.20)) fHisto[5]++;
			if ((length < max * 0.28) && (length >= max * 0.24)) fHisto[6]++;
			if ((length < max * 0.32) && (length >= max * 0.28)) fHisto[7]++;
			if ((length < max * 0.36) && (length >= max * 0.32)) fHisto[8]++;
			if ((length < max * 0.40) && (length >= max * 0.36)) fHisto[9]++;
			if ((length < max * 0.44) && (length >= max * 0.40)) fHisto[10]++;
			if ((length < max * 0.48) && (length >= max * 0.44)) fHisto[11]++;
			if ((length < max * 0.52) && (length >= max * 0.48)) fHisto[12]++;
			if ((length < max * 0.56) && (length >= max * 0.52)) fHisto[13]++;
			if ((length < max * 0.60) && (length >= max * 0.56)) fHisto[14]++;
			if ((length < max * 0.64) && (length >= max * 0.60)) fHisto[15]++;
			if ((length < max * 0.68) && (length >= max * 0.64)) fHisto[16]++;
			if ((length < max * 0.72) && (length >= max * 0.68)) fHisto[17]++;
			if ((length < max * 0.76) && (length >= max * 0.72)) fHisto[18]++;
			if ((length < max * 0.80) && (length >= max * 0.76)) fHisto[19]++;
			if ((length < max * 0.84) && (length >= max * 0.80)) fHisto[20]++;
			if ((length < max * 0.88) && (length >= max * 0.84)) fHisto[21]++;
			if ((length < max * 0.92) && (length >= max * 0.88)) fHisto[22]++;
			if ((length < max * 0.96) && (length >= max * 0.92)) fHisto[23]++;
			if ((length <= max) && (length >= max * 0.96)) fHisto[24]++;
		}

		//Open file to record histogram and 1-cdf data
		if ( _HistoFile.size() > 0 ) {
			FILE * pFile;
			pFile = fopen( _HistoFile.c_str(), "a" );
			double j = 0;
			for (unsigned i = 0; i < 1000; i++) {

				//grab the 1-cdf data; 
				unsigned count = 0;
				j = max * (static_cast<double>(i) / 1000.0);	//from 0 to max length, 1000 increments
				for (unsigned k = 0; k < fragLengthSort.size(); k++) {
                    double length = fragLengthSort[k];
					if (length > j) {		//if frag length greater than j, add to count
						count += 1;
					}
				}
		
				//save to vector
				fragInvCDF[0][i] = j;
				fragInvCDF[1][i] = (double)count;
				fprintf( pFile, "%6.3e %u", j, count);		//print to file

				//print histogram info to file - relative size (% of max frag length) & count
				if (i < 25) {	//piggybacking the for loop, only need the first 25
					fprintf( pFile, " %f %u", (double)(i*4+2), fHisto[i] );
				} else {
					fprintf( pFile, " 0 0");
				}
				fprintf( pFile, "\n" );
			}

			//print raw fragment sizes to file
			fprintf( pFile, "# Sizes: \n" );
			for (unsigned k = 0; k < fragLength.size(); k++){
                double length = fragLength[k];
				fprintf( pFile, "%12.3e \n", length );
			}

			fclose( pFile );
		}
    }
    return;
}


void PotentialAvenger::printClean () const {
    std::string cleanPath = _path+"/clean.sh";
    FILE * pFile;
    pFile = fopen( cleanPath.c_str(), "w" );
    fprintf( pFile, "#!/bin/bash\n\n" );
    fprintf( pFile, "# Go to results directory\n" );
    fprintf( pFile, "cd %s\n\n", _path.c_str() );
    fprintf( pFile, "# Remove the data files\n" );
    fprintf( pFile, "cd ./datFiles/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "cd ./automatedRuns/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "# Remove the gnuplot files\n" );
    fprintf( pFile, "cd ./gnuplot/ ; rm *.plt; cd -\n\n" );
    fprintf( pFile, "# Remove the png/svg files\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.png; cd -\n\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.svg; cd -\n\n" );
    fprintf( pFile, "# Remove the vtk files\n" );
    fprintf( pFile, "cd ./vtkFiles/; find . -name \"*.vtk\" -print0 | xargs -0 rm -f; cd -\n\n" );
    fprintf( pFile, "# Remove plot.sh\n" );
    fprintf( pFile, "rm plot.sh\n" );
    fclose( pFile );
    std::string shellCmd = "chmod u+x " + cleanPath;
    //int status = system( shellCmd.c_str() );
	system( shellCmd.c_str() );

    shellCmd = "./" + cleanPath;
	system( shellCmd.c_str() );

}

