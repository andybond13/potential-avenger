//potential-avenger.c
//Andrew Stershic
//DCML, Duke University
//(c) 2013

#include <potential-avenger.h>
#include <math.h>
#include <sys/stat.h>

using namespace std;

int main(int argc, const char* argv[]) {
    assert(argc == 8);

    double strain_rate = atof(argv[1]);
    double ts_refine = atof(argv[2]);
    double end_t = atof(argv[3]);
    unsigned Nelt = atoi(argv[4]);
    double lc = atof(argv[5]);
    unsigned intOrder = atoi(argv[6]);
    unsigned printVTK = atoi(argv[7]);
    string path = ".";

    PotentialAvenger pa = PotentialAvenger(strain_rate, ts_refine, end_t, Nelt, lc, intOrder, printVTK, path);
    pa.run();
}

PotentialAvenger::PotentialAvenger(double& in0, double& in1, double& in2, unsigned& in3, double& in4, unsigned& in5, unsigned& in6, string& path){
    strain_rate = in0;
    ts_refine = in1;
    end_t = in2;
    Nelt = in3;
    lc = in4;
    intOrder = in5;
    printVTK = in6;
    _path = path + "/results";

    //make plot files
    printClean();
	plotEnergies();
    plotFrags();
    plotHisto();
    plotSTheta();

};

PotentialAvenger::~PotentialAvenger(){
// create a plot file if necessary
    std::string plotFil = _path+"/plot.sh";		//"../results/plot.sh"
    FILE * pFileP;
    pFileP = fopen( plotFil.c_str(), "w" );
    fprintf( pFileP, "#!/bin/bash\n" );
    fprintf( pFileP, "# shell script generated by <ring.h>" );
    fprintf( pFileP, " -- MH [DCML] (2010)\n\n" );
    if ( _EnrgFile.size() != 0 ) {
        std::string enrgFil = "./gnuplot/plotEnrg.plt";
        fprintf( pFileP, "gnuplot %s\n", enrgFil.c_str() );
    }
    if ( _FragFile.size() != 0 ) {
        std::string fragFil = "./gnuplot/plotFragInfo.plt";
        fprintf( pFileP, "gnuplot %s\n", fragFil.c_str() );
    }
    if ( _HistoFile.size() != 0 ) {
        std::string histoFil = "./gnuplot/plotHisto.plt";
        fprintf( pFileP, "gnuplot %s\n", histoFil.c_str() );
    }
    if ( _SThetaFile.size() != 0 ) {
        std::string sThetaFil = "./gnuplot/plotSTheta.plt";
        fprintf( pFileP, "gnuplot %s\n", sThetaFil.c_str() );
    }
    fprintf( pFileP, "\n/usr/bin/open -a \"/Applications/Google Chrome.app\" ./pngFiles/*.svg &\n" );
    fclose( pFileP );
    chmod( plotFil.c_str(), 0775 );

};

unsigned min(const vector<unsigned> in) {
    assert(in.size() > 0);
    unsigned min = in[0];
    for (unsigned i = 1; i < in.size(); ++i) {
        if (in[i] < min) min = in[1];
    }
    return min;
}

unsigned max(const vector<unsigned> in) {
    assert(in.size() > 0);
    unsigned max = in[0];
    for (unsigned i = 1; i < in.size(); ++i) {
        if (in[i] > max) max = in[1];
    }
    return max;
}

double dotProduct(const vector<double> a, const vector<double> b) {
    double sum = 0;
    assert(a.size() == b.size() );
    for (unsigned i = 0; i < a.size(); ++i) sum+= a[i]*b[i];
    return sum;
}

unsigned median(const vector<unsigned> in) {
    return in[(in.size()-1)/2];
}

double sum(const vector<double> in) {
    return dotProduct(in,vector<double>(in.size(),1));
}


void PotentialAvenger::run() {

    printRunInfo();

    dm = DamageModel("Parabolic",lc);

    unsigned Ntim = Nelt*ts_refine*end_t;
    Nnod = Nelt+1;
    _Nt = 0;
    E = 1; //(beton)
    rho = 1; //(beton)
    A = 1; // barre de 10cm sur 10cm
    double c = sqrt(E/rho);
    L = 1;
    h = 1/static_cast<double>(Nelt); //
    double cfl = 1./ts_refine;
    dt = cfl * h/c;//
    Yc = E/10;
    ec = sqrt(2 * Yc / E);
    sigc = E * ec;

    // two gauss point on the element
    vector<double> pg(2);
    pg[0] = (1-sqrt(3)/3)/2;
    pg[1] = (1+sqrt(3)/3)/2;
    vector<double> wg(2);
    wg[0] = 0.5;
    wg[1] = 0.5;

    d = vector<double>(Nelt,0);
    s = vector<double>(Nelt,0);
    e = vector<double>(Nelt,0);
    energy = vector<double>(Nelt,0);
    Y = vector<double>(Nelt,0);
    YmYc = vector<double>(Nelt,0);
    strain_energy = 0.0;
    kinetic_energy = 0.0;
    dissip_energy = 0.0;
    ext_energy = 0.0;
    tot_energy = 0.0;
    fragment_list.clear();

    //Matrix bpos = Matrix(Ntim, Nelt);
    //Matrix grad = Matrix(Ntim, Nelt);
    ustat = vector<double>(Nnod,0);
    Ystat = vector<double>(Nnod,0);
    u = vector<double>(Nnod,0);
    v = vector<double>(Nnod,0);
    a = vector<double>(Nnod,0);
    phi = vector<double>(Nnod,0);

    vector<double> phi_1 = vector<double>(Nnod,0);
    vector<double> phi_2 = vector<double>(Nnod,0);
    vector<double> phi_3 = vector<double>(Nnod,0);
    vector<double> phi_4 = vector<double>(Nnod,0);
    vector<double> phi_5 = vector<double>(Nnod,0);
    vector<double> phi_6 = vector<double>(Nnod,0);
    vector<double> phidot;
    //vector<double> ddotbar(Ntim,0);

    vector<unsigned> nbiter = vector<unsigned>(Ntim,0);
    nfrags = vector<unsigned>(Ntim,0);
    vector<Segment> segments;

    m.assign(Nnod,rho*h*A);
    m[0] = m[0]/2; m[Nnod-1] = m[Nnod-1]/2;

    //initialization
    x = vector<double>(Nnod,0);
    for (unsigned j = 0; j < Nnod; ++j) x[j] = j*h;

    xe = vector<double>(Nnod,0);
    for (unsigned j = 0; j < Nelt; ++j) xe[j] = 0.5*(x[j] + x[j+1]);

    t = vector<double>(Ntim,0);
    for (unsigned j = 0; j < Ntim; ++j) t[j] = j*dt;

    // Initially the bar is loaded and all elements are at Yc
    // A tls is placed on the first element, obviously it satifies
    //   Ybar = Yc
    // This extra damage will create new stress that are less than in the next element
    // and ill thus give an unloading wave.

    //constant strain rate applied
    double csr = strain_rate;
    bool vbc = true;
    for (unsigned j = 0; j < Nnod; ++j) v[j] = vbc*csr*x[j];

    for (unsigned j = 0; j < Nnod; ++j) {
        u[j] = x[j] * ec * L * 0.999*(1-vbc);
        ustat[j] = x[j] * ec * L * 0.999*(1-vbc);
        phi[j] = (2*h-x[j])*(1-vbc)-vbc;
    }

    Segment seg1 = Segment(x[0],phi[0],-1,Nnod);
    seg1.indices.push_back(0);
    segments.push_back(seg1);

    //calculate stresses
    calculateStresses(pg,wg);

    //acceleration
    a[0] = 0;
    a[Nnod-1] = 0;
    for (unsigned j = 1; j < Nnod-1; ++j)  a[j] = A*(s[j] - s[j-1]) /m[j];

    nbiter[0] = 0;
    analyzeDamage(x,phi,h,segments);
    unsigned len = 0;
    for (unsigned l = 0; l < segments.size(); ++l) {
        if (segments[l].size() == 0) continue;
        len++;
    }
    phidot.resize(len);

    //print data to file
    fragmentStats();
    calculateEnergies(0);
    if (printVTK != 0) printVtk(_Nt);
    printFrags();
    printGlobalInfo();

    //time-integration loop
    for (unsigned i = 1; i < Ntim; ++i){
        _Nt++;
//cout << "t = " << t[i] << endl;

        //Copy kinematic variables to "old"
        u_1 = vector<double>(Nnod,0); u_1 = u; u.assign(Nnod,0.0);
        vector<double> v_1 = vector<double>(Nnod,0); v_1 = v; v.assign(Nnod,0.0);
        vector<double> a_1 = vector<double>(Nnod,0); a_1 = a; a.assign(Nnod,0.0);
        d_1 = vector<double>(Nnod,0); d_1 = d; d.assign(Nnod,0.0);
        phi_6.clear(); if (i >= 6) phi_6 = phi_5;
        phi_5.clear(); if (i >= 5) phi_5 = phi_4;
        phi_4.clear(); if (i >= 4) phi_4 = phi_3;
        phi_3.clear(); if (i >= 3) phi_3 = phi_2;
        phi_2.clear(); if (i >= 2) phi_2 = phi_1;
        phi_1 = phi;


        //prediction
        for (unsigned j = 0; j < Nnod; ++j) {
            v[j]= v_1[j] + 0.5*dt*a_1[j];
            u[j]= u_1[j] + dt*v_1[j] + 0.5*dt*dt*a_1[j];
        }

        //def computation and Y update.
        for (unsigned j = 0; j < Nelt; ++j) {
            e[j] = (u[j+1] - u[j]) / h;
            //b=0.5*E*e(i,j)*e(i,j)-Yc;
        }

        // moving the localization front
        // we compute a = integral (Yn+1 - Yc) d' in the current non-local zone
        // then we compute b = (Yn+1-Yc) d' on the front
        // the shift in level set if the ratio of the two.

        for (unsigned l = 0; l < segments.size(); ++l) {
            if (segments[l].size()==0) continue;//segments.erase(segments.begin()+l);
            unsigned sbegin = segments[l].begin();
            unsigned send = segments[l].end();
        
            //skip if all negative
            bool allNeg = true;
            for (unsigned k = sbegin; k <= send; ++k) {
                if (phi[k] != -1) {
                    allNeg = false;
                    break;
                }
            }
            if (allNeg) continue;
        
            double err_crit = 1e15;
            double dphi = 0;
            nbiter[i] = 0;
            double residu = 0;

            while (err_crit > 1.e-6) {
                nbiter[i]++;
                double residu_Y = 0; double tangent_Y = 0;
                unsigned loop_residu = 0;
                unsigned loop_tangent = 0;
                for (unsigned j = max(0,static_cast<int>(sbegin)-1); j <= min(send,Nelt-2); ++j) {
                    if (j < 0) continue;
                    assert(pg.size() == wg.size());
                    if (phi[j] > 0 && phi[j+1] > 0) {
                        for (unsigned k = 0; k < pg.size(); ++k) {
                            double philoc = pg[k]*phi[j] + (1-pg[k]) * phi[j+1];
                            residu_Y += h * wg[k] * (0.5 * E * e[j] * e[j] - Yc) * dm.dp(philoc);
                            tangent_Y += h * wg[k] * (0.5 * E * e[j] * e[j] - Yc) * dm.dpp(philoc);
                        }
                        loop_residu++;
                    } else if  (phi[j] > 0 && phi[j+1] <= 0) {
                        double delta = h * fabs(phi[j]) / (fabs(phi[j])+fabs(phi[j+1])); //phi>0 portion
                        for (unsigned k = 0; k < pg.size(); ++k) {
                            double philoc = pg[k] * phi[j];
                            residu_Y += delta * wg[k] * (0.5 * E * e[j] * e[j] - Yc) * dm.dp(philoc);
                            tangent_Y += delta * wg[k] * (0.5 * E * e[j] * e[j] - Yc) * dm.dpp(philoc);
                        }
                        loop_residu++;
                        if (delta < h) tangent_Y += (0.5 * E * e[j] * e[j] - Yc)* dm.dp(0.);
                        else tangent_Y += (0.5 * E * e[j+1] * e[j+1] - Yc)  * dm.dp(0.);
                        
                        loop_tangent = loop_tangent + 1;
                    } else if  (phi[j] <= 0 && phi[j+1] > 0) {
                        double delta = h * fabs(phi[j+1]) / (fabs(phi[j])+fabs(phi[j+1])); //phi>0 portion
                        for (unsigned k = 0; k < pg.size(); ++k) {
                            double philoc = pg[k] * phi[j+1];
                            residu_Y += delta * wg[k] * (0.5 * E * e[j] * e[j] - Yc) * dm.dp(philoc);
                            tangent_Y += delta * wg[k] * (0.5 * E * e[j] * e[j] - Yc) * dm.dpp(philoc);
                        }
                        loop_residu++;
                        if (delta < h) tangent_Y += (0.5 * E * e[j] * e[j] - Yc)* dm.dp(0.); //%todo-doublecheck this  
                        else tangent_Y += (0.5 * E * e[j] * e[j] - Yc)  * dm.dp(0.);   //%todo-doublecheck this
                        loop_tangent++;
                    
                    }
                }
            
                // law Ybar = Yc
                if (1==1) {
                    bool flag = true; //0 is exterior (damage centered on edge of domain); 1 is interior
                    if (l == 1 && segments[l].begin() == 0) flag = false;
                    if (l == segments.size()-1 && segments[l].end() == Nnod-1) flag = false;

                    
                    double phimax = phi[sbegin];
                    unsigned iphimax = sbegin;
                    for (unsigned k = sbegin; k <= send; ++k) {
                        if (phi[k] > phimax) {
                            phimax = phi[k];
                            iphimax = k;
                        }
                    }
                    phimax = segments[l].phipeak;

                    double phimaxY;
                    if (iphimax == Nnod-1) phimaxY = 0.5*E*pow(e[Nelt-1],2); //1/2*s(i,Nelt)*e(i,Nelt);
                    else phimaxY = 0.5*E*pow(e[iphimax],2);// 1/2*s(i,iphimax)*e(i,iphimax);
                    
                    double YbarmYc = residu_Y/(dm.dval(phimax));
                    double oldresidu = residu;
                    residu = YbarmYc/Yc;
                    err_crit = fabs(residu-oldresidu);
                    double tangent = (tangent_Y + flag*(phimaxY-Yc)*dm.dp(phimax)/2)/(Yc*dm.dval(phimax)) - ((1+flag/2)*dm.dp(phimax)/pow(dm.dval(phimax),2)) * (YbarmYc/Yc);
                    if (fabs(tangent) <= 1.e-10) {
                        err_crit = 0.; dphi = 0.;
                    } else {
                        dphi = - residu/tangent;
                    }
                }
cout << dphi << endl;
                if (nbiter[i] > 50) {
                    dphi = 0;
                    //assert(1==0);
                }
            
                if (isnan(dphi)) {
                    dphi = 0;
                    assert(1==0);                
                }
cout << sbegin << " - " << send << endl;
                for (unsigned j = sbegin; j <=send; ++j) {
                    if (i > 5 && intOrder >= 6) {
                        vector<double> w;
                        w.push_back(60./147); w.push_back(360./147); w.push_back(-450./147); w.push_back(400./147);
                        w.push_back(-225./147); w.push_back(72./147); w.push_back(-10./147); 
                        vector<double> phihist;
                        phihist.push_back(dphi); phihist.push_back(phi_1[j]); phihist.push_back(phi_2[j]);
                        phihist.push_back(phi_3[j]); phihist.push_back(phi_4[j]); phihist.push_back(phi_5[j]);
                        phihist.push_back(phi_6[j]);
                        phi[j] = dotProduct(phihist,w);
                    } else if (i > 4 && intOrder >= 5) {
                        vector<double> w;
                        w.push_back(60./137); w.push_back(300./137); w.push_back(-300./137); w.push_back(200./137);
                        w.push_back(-75./137); w.push_back(12./137);
                        vector<double> phihist;
                        phihist.push_back(dphi); phihist.push_back(phi_1[j]); phihist.push_back(phi_2[j]);
                        phihist.push_back(phi_3[j]); phihist.push_back(phi_4[j]); phihist.push_back(phi_5[j]);
                        phi[j] = dotProduct(phihist,w);
                    } else if (i > 3 && intOrder >= 4) {
                        vector<double> w;
                        w.push_back(12./25); w.push_back(48./25); w.push_back(-36./25); w.push_back(16./25);
                        w.push_back(-3./25);
                        vector<double> phihist;
                        phihist.push_back(dphi); phihist.push_back(phi_1[j]); phihist.push_back(phi_2[j]);
                        phihist.push_back(phi_3[j]); phihist.push_back(phi_4[j]);
                        phi[j] = dotProduct(phihist,w);
                    } else if (i > 2 && intOrder >= 3) {
                        vector<double> w;
                        w.push_back(6./11); w.push_back(18./11); w.push_back(-9./11); w.push_back(2./11);
                        vector<double> phihist;
                        phihist.push_back(dphi); phihist.push_back(phi_1[j]); phihist.push_back(phi_2[j]);
                        phihist.push_back(phi_3[j]);
                        phi[j] = dotProduct(phihist,w);
                    } else if (i > 1 && intOrder >= 2) {
                        vector<double> w;
                        w.push_back(2./3); w.push_back(4./3); w.push_back(-1./3);
                        vector<double> phihist;
                        phihist.push_back(dphi); phihist.push_back(phi_1[j]); phihist.push_back(phi_2[j]);
                        phi[j] = dotProduct(phihist,w);
                    } else {
                        phi[j] = phi_1[j] + dphi;
                    }
                    phi[j] = max(phi[j],phi_1[j]); //constraint: dphi >= 0
                    //enforcing limit of level-set motion
                    //phi(i,j) = min(phi(i-1,j)+h,phi(i,j));
                }
            } //while
        
            err_crit = 0.0;
        } //for segments

        //check for nucleation
        vector<double> Yin;
        for (unsigned l = 0; l < Nelt; ++l)  Yin.push_back(0.5*E*e[l]*e[l]);
        vector<double> YcVec(1,Yc);
        string elemOrNodal="elem";
        checkFailureCriteria(t[i],x,phi,YcVec,elemOrNodal,Yin,false,false,2*h,segments);

        //enforce phi constraints - update segments
        analyzeDamage(x,phi,h,segments);

        int index = -1;
        for (unsigned l = 0; l < segments.size(); ++l) {
            if (segments[l].size() == 0) continue;
            index++;
            //median(segments[l]);
            unsigned smid = median(segments[l].indices);

            len = 0;
            for (unsigned j = 0; j < segments.size(); ++j) {
                if (segments[j].size() == 0) continue;
                len++;
            }
            phidot.resize(len);
            phidot[index] = (phi[smid] - phi_1[smid])/dt;
            if (phidot[index] * dt > h*1.01 ) {
                printf("level-set front advancing more than one element per time-step: t=%f, segment %u , dphi/h = %f \n",t[i],l,phidot[index]*dt/h);
            }
        }

        //updating the stress
        calculateStresses(pg,wg);

        //acceleration
        if (phi[0] <= lc) a[0] = 0;
        else a[0] =  A*s[0]/m[0];
        a[Nnod-1] = 0; //note: this is a constraint which was hidden. if free, it would be -s(i,Nnod)/m(j);
        for (unsigned j = 1; j < Nnod - 1; ++j) a[j] = A*(s[j] - s[j-1]) /m[j];

        //correction
        for (unsigned j = 0; j < Nnod; ++j) v[j]= v[j] + 0.5*dt*a[j];

        //record number of fragments and quantities per fragment
        fragment_list.clear();
        findFragments(dm, segments,phi,nfrags[i],fragment_list);
        _numFrag = nfrags[i];

        //calculate energies
        calculateEnergies(i);

		//print the rest of the table/graph data
        if (printVTK != 0) if ( ( (_Nt -1) % printVTK) == 0 ) printVtk(_Nt);
        fragmentStats();
        printFrags();
        printGlobalInfo();

    }//end time-loop


    double minfrag = L*2;
    double sumfrag = 0;
    for (unsigned i = 0; i < nfrags[Ntim-1]/2; ++i) {
        
        double fragLen = fragment_list[i].length()*static_cast<double>(h);

        if (((nfrags[Ntim-1] % 2) == 1) && (fragment_list[i].begin() == 0)) fragLen *= 2;
    
        if (fragLen < minfrag) minfrag = fragLen;

        sumfrag += fragLen;
    }

    if (nfrags[Ntim-1] == 0) {
        for (unsigned i = 0; i < segments.size(); ++i) {
            if (segments[i].size() > 0) cout << dm.dval(segments[i].phipeak) << " , " << segments[i].phipeak << endl;
        }
    }

    if (nfrags[Ntim-1] > 0) assert(fabs(sumfrag - L) < 0.5*h);
    printf("Final number of fragments: %i \nMinimum fragment length: %f \nFinal dissipated energy: %f \n",nfrags[Ntim-1],minfrag,dissip_energy);

    
    //print histogram
    printHisto();
    return;
};

void PotentialAvenger::calculateStresses(const vector<double>& pg, const vector<double>& wg) {
    for (unsigned j = 0; j < Nelt; ++j) {

        assert(pg.size() == wg.size());

        s[j] = 0;
        e[j] = (u[j+1] - u[j])/h;
        vector<double> dloc(pg.size(),0.0);
        if (phi[j] > 0  && phi[j+1] > 0) {
            for (unsigned k = 0; k < pg.size(); ++k) {
                double philoc = pg[k] * phi[j] + (1-pg[k]) * phi[j+1];
                dloc[k] = dm.dval(philoc);
                s[j] += wg[k] * (1-dloc[k]) * E * e[j];
            }
        } else if  (phi[j] <= 0 && phi[j+1] <= 0) {
            s[j] = E * e[j];
        } else if  (phi[j] > 0 && phi[j+1] <= 0) {
            double delta = fabs(phi[j]) / (fabs(phi[j])+fabs(phi[j+1]));
            double sloc = 0;
            for (unsigned k = 0; k < 2; ++k) {
                double philoc = pg[k] * phi[j];
                dloc[k] = dm.dval(philoc);
                sloc += wg[k] * (1-dloc[k]) * E * e[j];
            }
            s[j] = delta *  sloc +  (1-delta) * E * e[j];
        } else if (phi[j] <= 0 && phi[j+1] > 0) {
            double delta = fabs(phi[j+1]) / (fabs(phi[j])+fabs(phi[j+1]));
            double sloc = 0;
            for (unsigned k = 0; k < 2; ++k) {
                double philoc = pg[k] * phi[j+1];
                dloc[k] = dm.dval(philoc);
                sloc += wg[k] * (1-dloc[k]) * E * e[j];
            }
            s[j] = delta *  sloc +  (1-delta) * E * e[j];
        }

        d[j] = 0;
        for (unsigned k = 0; k < pg.size(); ++k) {
            d[j] += wg[k] * dloc[k];
        }
    }
    return;
}

void PotentialAvenger::calculateEnergies(const unsigned& i) {
    double dissip = 0.0;
    kinetic_energy = 0.0;

    for (unsigned j = 0; j < Nelt; ++j) {
        Y[j] = 0.5 * E * e[j] * e[j];
        YmYc[j] = Y[j]/Yc - 1;
        if (i > 0) {
            dissip += h * Y[j] * (d[j] - d_1[j]);
            kinetic_energy += 0.5 * h * rho * 0.5 *
                                ( pow(u[j] - u_1[j],2) + pow(u[j+1] - u_1[j+1],2) ) / pow(dt,2);
            //ustat(i,j+1) = ustat(i,j) + h*s(0,Nelt)/(E*(1-d(i,j)));
        } else {
            kinetic_energy += 0.5 * h * rho * 0.5 * ( v[j] * v[j] + v[j+1] * v[j+1]);
        }
        energy[j] = h * Y[j] * (1 - d[j]);
    }
    //ustat(i,:) *= u(1,Nnod)/ustat(i,Nnod);
    for (unsigned j = 0; j < Nelt; ++j) Ystat[j] = 0.5 * E * pow((ustat[j+1] - ustat[j])/h,2);
    dissip_energy += dissip;
    strain_energy = sum (energy);
    if (i > 0) ext_energy += (a[Nnod-1] * m[Nnod-1] + s[Nnod-2] * A) * v[Nnod-1] * dt;
    else ext_energy = dissip + strain_energy + kinetic_energy;
    tot_energy = strain_energy + kinetic_energy + dissip_energy - ext_energy;
    max_energy = max(max(kinetic_energy,dissip_energy),strain_energy);
}

std::string convertInt(unsigned number) {
    if (number == 0)
        return "0";
    string temp="";
    string returnvalue="";
	//read from back
    while (number>0)
    {
        temp+=number%10+48;
        number/=10;
    }
    for (unsigned i=0;i<temp.length();i++)
        returnvalue+=temp[temp.length()-i-1];
    return returnvalue;
}

void PotentialAvenger::nucleate(const double t, const std::vector<double>& x, std::vector<double>& phi, const std::vector<double>& xnuc, const std::vector<double>& phinuc, std::vector<Segment>& newSegment){
    //t      -time
    //x      -mesh
    //phi    -level-set calculated at this time-step
    //xnuc   -location(s) of localizations to be nucleated
    //phinuc -amount of the level-set to be set at nucleated localizations

    assert(xnuc.size() == phinuc.size());
    assert(xnuc.size() > 0);

    for (unsigned j = 0; j < xnuc.size(); ++j) {
        double h = 0;
        int loc = -1;
        double delta = 0;
        
        for (unsigned i = 0; i < x.size()-1; ++i) {
            if ((xnuc[j] >= x[i]) && (xnuc[j] < x[i+1])) {
                loc = i;
                h = x[i+1] - x[i];                
                delta = (xnuc[j] - x[i])/h;
                break;
            }

        }
    
        assert(loc != -1);
    
        phi[loc] = phinuc[j] - delta*h;
        phi[loc+1] = phinuc[j] - (1-delta)*h;
        printf("crack nucleated, t = %f, x = %f \n",t,xnuc[j]);
        
        //create two new segments
        if (xnuc[j] > x[0]) {
            Segment seg1 = Segment(xnuc[j],phinuc[j]-delta*h,-1,Nnod);
            seg1.indices.push_back(loc);
            newSegment.push_back(seg1);
        }
        if (xnuc[j] < x[x.size()-1]) {
            Segment seg2 = Segment(xnuc[j],phinuc[j]-(1-delta)*h,1,Nnod);
            seg2.indices.push_back(loc+1);
            newSegment.push_back(seg2);
        }

    }
};

void PotentialAvenger::findFragments(DamageModel& dm, std::vector<Segment>& newSegment, const std::vector<double>& phi, unsigned& nfrags, std::vector<Fragment>& fragment_list) {

    fragment_list.clear();

    sort(newSegment.begin(),newSegment.end());

    Fragment f = Fragment();
    for (unsigned i = 0; i < newSegment.size(); ++i) {

        if (newSegment[i].size() == 0) continue;
        f.add(&newSegment[i]);
        double phimax = newSegment[i].phipeak;
        double slope = newSegment[i].slope;
        if (slope == 1 && dm.dval(phimax) == 1.0 || newSegment[i].end()  == Nnod - 1) {
            fragment_list.push_back(f);
            f.clear(); f = Fragment();
        } else {}
            //cout << slope << " , " << dm.dval(phimax) << endl;
    }
    
    //calculate total number of fragments (removing symmetry simplification)
    if (fragment_list.size() == 0) {nfrags = 0; return;};
    nfrags = fragment_list.size()*2;
    if (dm.dval(phi[0]) < 1.0) {
        nfrags = nfrags - 1;
    }
};

void PotentialAvenger::checkFailureCriteria(const double t, const std::vector<double>& x, std::vector<double>& phi, std::vector<double>& criterion, const std::string elemOrNodal, const std::vector<double>& qty, const bool absOrAsIs, const bool phiPos, const double failvalue, std::vector<Segment>& newSegment){

    //x              -mesh
    //phi            -level-set calculated at this time-step
    //criterion      -criterion to compare against for failure
    //elemOrNodal    -either 'elem' or 'nodal' - is criterion elemental or nodal
    //qty            -the quantity to be compared to the criterion -e.g. s,Y
    //absOrAsIs      -whether to compare (0) qty or (1) abs(qty) to criterion
    //phiPos         -whether(1) or not(0) failure cannot occur depending on if phi>0
    //failvalue      -what to call phi at localization zone if created - e.g. h
    //failure if qty > criterion

    assert(elemOrNodal.compare("elem") == 0 || elemOrNodal.compare("nodal") == 0);
    assert(absOrAsIs == false || absOrAsIs == true);
    if (elemOrNodal.compare("nodal") == 0) {
        assert(x.size() == qty.size());
    } else {
        assert(x.size() == qty.size()+1);
    }
    assert((qty.size() == criterion.size()) || (criterion.size() == 1));

    if (criterion.size() == 1) {
        double val = criterion[0];
        criterion.assign(qty.size(),val);
    }
    vector<double> xlist;
    for (unsigned i = 0; i < qty.size(); ++i) {
        if (phiPos == 0) {//can't fail if phi>0
            if (elemOrNodal.compare("nodal") == 0) {
                if (phi[i] > 0) continue;
            } else {
                if (phi[i]>0 || phi[i+1]>0) continue;
            }
        }

        double qtyc = qty[i];

        //can't fail if already nucleated
        double h = x[i+1]-x[i];
        for (unsigned j = 0; j < newSegment.size(); ++j) {
            if (fabs(newSegment[j].xpeak-x[i]) < h) goto nextLoop; 
        }

        if (absOrAsIs) {
            qtyc = fabs(qtyc);
        }

        if (qtyc > criterion[i]) {
            if (elemOrNodal.compare("nodal") == 0) {
                xlist.push_back(x[i]);
            } else {
                //assume middle of element
                xlist.push_back(0.5*(x[i]+x[i+1]));
            }
        }
        nextLoop: //jump to here if can't nucleate
        qtyc = 0;
    }
    //nucleate list
    if (xlist.size() > 0) {
        vector<double> failvalueList = vector<double>(xlist.size(),failvalue);
        nucleate(t,x,phi,xlist,failvalueList, newSegment);
    }
};

void PotentialAvenger::analyzeDamage(const vector<double>& x, vector<double>& phi, const double h, vector<Segment>& newSegment) {

    //produce:
    //new phi based on distances - maxima

    //if all negative one, skip
    unsigned sum = 0;
    for (unsigned i = 0; i < phi.size(); ++i) {
        if (phi[i] > -1) sum++;
    }
    if (sum == 0) return;

    vector<double> list_max;
    vector<double> value_max;
    sort(newSegment.begin(), newSegment.end());
   
    assert(x.size() >= 1);
    //if (value_max.size() == list_max.size() && value_max.size() == 0) return;

    //simply use pre-defined segments
    if (newSegment.size() == 0) return;
    for (unsigned i = 0; i < newSegment.size(); ++i) {
        //assert(newSegment[i].size() > 0);
        list_max.push_back(newSegment[i].xpeak);
        value_max.push_back(newSegment[i].phipeak);
        newSegment[i].indices.clear();
    }

    //re-define segments.indices and phi
    vector<double> phinew = vector<double>(phi.size(),-1);
    for (unsigned i = 0; i < phi.size(); ++i) {
        
        int segphimin = -1;
        double min = 9999999999;
        for (unsigned k = 0; k < value_max.size(); ++k) {
            double qty = -value_max[k] + fabs(x[i] - list_max[k]);
            if (qty < min) {
                min = qty;
                segphimin = k;
            }
        }
        assert(segphimin > -1);

        phinew[i] = -min;
        
        newSegment[segphimin].indices.push_back(i);

        phinew[i] = max(phinew[i],phi[i]);
    }

    unsigned tot_indices = 0;
    for (unsigned i = 0; i < newSegment.size(); ++i) {
        double value_maxnew = newSegment[i].phipeak;
        double list_maxnew = newSegment[i].xpeak;
        for (vector<unsigned>::iterator j = newSegment[i].indices.begin() ; j != newSegment[i].indices.end(); ++j) {
            if (phinew[*j] > value_maxnew) {
                value_maxnew = phinew[*j];
                list_maxnew = x[*j];
            }
            assert(phinew[*j] <= value_maxnew);
            tot_indices++;
        }
       newSegment[i].phipeak = value_maxnew;
       newSegment[i].xpeak = list_maxnew;
    }
    assert(tot_indices == x.size());

    //return phinew as phi
    for (unsigned i = 0; i < phi.size(); ++i) {
        phi[i] = phinew[i];
    }
};  

void PotentialAvenger::printRunInfo() {
    cout << endl;
    cout << "Run Info:" << endl;
    cout << "Strain rate = " << strain_rate << endl;
    cout << "# Elements = " << Nelt << endl;
    cout << "End Time (s) = " << end_t << endl;
    cout << "Time-step refinement ratio = " << ts_refine << endl;
    cout << "Damage gradient length (lc) = " << lc << endl;
    cout << "Integration Order = " << intOrder << endl;
    cout << "Beginning run... " << endl;
    cout << endl;

};

void PotentialAvenger::plotEnergies () {
    // Gnuplot file for energies
    FILE * pFileW;
    std::string stressFile = _path+"/gnuplot/plotEnrg.plt";		//../results
    pFileW = fopen( stressFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Global energies\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"energy (J)\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgSpr.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'Wspr' w l\n" );
    fprintf( pFileW, "set output './pngFiles/enrgDissip.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:3 ti 'Wdissip' w l\n" );
    fprintf( pFileW, "set output './pngFiles/enrgExt.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:4 ti 'Wext' w l\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgKin.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:5 ti 'Wkin' w l\n\n" );
    fprintf( pFileW, "set ylabel \"Energy Balance Check\"\n" );
    fprintf( pFileW, "set output './pngFiles/enrgBalance.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:(abs($7)) ti 'Wsum' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:6 ti '0.01 * Wmax' w l\n\n" );
    fprintf( pFileW, "set ylabel \"J/s\"\n" );

    fprintf( pFileW, "set output './pngFiles/enrgAll.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'Wspr' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:3 ti 'Wdis' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:4 ti 'Wext' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:5 ti 'Wkin' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:(abs($2+$3+$5)) ti 'Wsum' w l\n\n");

    fclose( pFileW );

    // Prepare Gnuplot data file
    _EnrgFile = _path+"/datFiles/energies.dat";		//../results
    FILE * pFile;
    pFile = fopen( _EnrgFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Total energies for the system\n" );
    fprintf( pFile, "#       time        Wspr        Wdis        Wext");
    fprintf( pFile, "        Wkin   0.01*Wmax        Wsum\n" );
    fclose( pFile );
}

void PotentialAvenger::plotFrags (){
    // Gnuplot file for fragmentation
    FILE * pFileW;
    std::string fragFile = _path+"/gnuplot/plotFragInfo.plt";		//../results
    pFileW = fopen( fragFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Fragmentation Information\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"Number of Fragments\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/numFrag.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraginfo.dat' usi 1:3 ti 'Sum of Damage' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/fraginfo.dat' usi 1:2 ti '# Frags' w l\n\n" );

    fclose( pFileW );

    // Prepare Gnuplot data file
    _FragFile = _path+"/datFiles/fraginfo.dat";		//../results
    FILE * pFile;
    pFile = fopen( _FragFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#       time      #frags   DamageSum        Mean      Median         Max         Min");
    fprintf( pFile, "       StDev       Range        Skew    Ex. Kurt.");
    fprintf( pFile, "((R*L^2)/|L|) (Locations)\n");
    fclose( pFile );
}

void PotentialAvenger::plotHisto () {
    // Gnuplot file for fragmentation histogram
    FILE * pFileW;
    std::string histoFile = _path+"/gnuplot/plotHisto.plt";		//../results
    pFileW = fopen( histoFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "set title \"Fragment Length CDF Graph\"\n"); 
    fprintf( pFileW, "set xlabel \"Fragment Length, Lf (m)\"\n" );
    fprintf( pFileW, "set ylabel \"# ( Length > Lf )\"\n" );
    if (_numFrag > 0) fprintf( pFileW, "set yrange [0:%u]\n", _numFrag);
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/fraginvcdf.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' usi 1:2 ti '' w l;\n\n" );
    fprintf( pFileW, "set boxwidth 0.9 absolute\n" );
    fprintf( pFileW, "set style fill   solid 1.00 border -1\n" );
    fprintf( pFileW, "set title \"Fragmentation Histogram\"\n"); 
    fprintf( pFileW, "set xlabel \"Size Distribution Relative to Max. Frag. Size (Percent)\"\n" );
    fprintf( pFileW, "set ylabel \"Frequency\"\n" );
    fprintf( pFileW, "set xrange [0:100]\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/fragHisto.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' using 3:4:(4) ti '' with boxes;\n" );
    fclose( pFileW );

    // Prepare Gnuplot data file
    _HistoFile = _path+"/datFiles/fraghisto.dat";		//../results
    FILE * pFile;
    pFile = fopen( _HistoFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#Length, Lf   # With Length > Lf   Bin Center   Frequency\n" );
    fclose( pFile );
}

void PotentialAvenger::plotSTheta () {
	// Gnuplot file for fragmentation histogram
	FILE * pFileW;
	std::string sThetaFile = _path+"/gnuplot/plotSTheta.plt";	//../results/
	pFileW = fopen( sThetaFile.c_str(), "w" );
	fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
	fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
	fprintf( pFileW, " -- MH[DCML] (2010)\n");
	fprintf( pFileW, "datafile = './datFiles/stresstheta.dat'\n");
	fprintf( pFileW, "stats datafile;\n");
	fprintf( pFileW, "set title \"Cohesive Link Stress vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaCL.svg'\n");
	fprintf( pFileW, "plot for[i=1:1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 4:5 ti 'Link Stress' w l;\n\n" );
	fprintf( pFileW, "set title \"Spring Element Stress vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaSE.svg'\n");
	fprintf( pFileW, "plot for[i=1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 2:3 ti 'Spring Stress' w l;\n\n" );
	fprintf( pFileW, "set title \"Cohesive Link Damage vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Damage\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaCLD.svg'\n");
	fprintf( pFileW, "plot for[i=1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 4:6 ti 'Damage' w l;\n\n" );
	fclose( pFileW );

    // Prepare Gnuplot data file
	_SThetaFile = _path+"/datFiles/stresstheta.dat";		//../results

    FILE * pFile;
    pFile = fopen( _SThetaFile.c_str(), "w" );
    	fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#Time       SprTheta    SprStress   CohTheta    CohStress           i         _Nt\n" );
    fclose( pFile );
}

/*------------------------------ P R I V A T E -------------------------------*/


void PotentialAvenger::printVtk ( const unsigned timStepNum ) const {

    // Build a name for the vtk file
    std::string resuPath = _path+"/vtkFiles/";			//../results
    unsigned zeroNum = 6 - (unsigned) floor( log10( timStepNum ) );
    std::string baseName = "ring_";//+ convertInt(_myid) + "_";
    for ( unsigned i = 0; i < zeroNum; i++ ) {
        baseName += "0";
    }
    baseName += convertInt(timStepNum);
    std::string vtkFile = resuPath + baseName + ".vtk";

    // Print in the vtk file
    printHeader ( vtkFile );
    printMesh ( vtkFile );
    printPointData ( vtkFile );
    printCellData ( vtkFile );
}

void PotentialAvenger::printHeader ( const std::string& vtkFile ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "w" );
    fprintf ( pFile, "# vtk DataFile Version 2.0\n" );
    fprintf ( pFile, "Generated by <ring.h> -- MH [DCML] (2010)\n" );
    fprintf ( pFile, "ASCII\nDATASET UNSTRUCTURED_GRID\n\n" );
    fclose( pFile );
}

void PotentialAvenger::printMesh ( const std::string& vtkFile ) const {
    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    fprintf ( pFile, "POINTS %d float\n", Nnod);
    for ( unsigned i = 0; i < Nnod; i++ ) {
        double xx = x[i];			//NodPos
        double y = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", xx, y, 0.0 );
    }
    fprintf ( pFile, "\nCELLS %d %d\n", Nelt, 3*Nelt );
    for ( unsigned i = 0; i < Nelt; i++ ) {
        fprintf ( pFile, " %12d %12d %12d\n", 2, i, i+1 );
    }
    fprintf ( pFile, "\nCELL_TYPES %d\n", Nelt );
    for ( unsigned i = 0; i < Nelt; i++ ) {
        fprintf ( pFile, " %12d\n", 3 );
    }
    fprintf ( pFile, "\n" );
    fclose( pFile );
}

void PotentialAvenger::printPointData ( const std::string& vtkFile ) const {
    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    //int pointData = _NodPos.size();
    fprintf ( pFile, "POINT_DATA %d", Nnod);
    fprintf ( pFile, "\nVECTORS displacements float\n" );
    for ( unsigned i = 0; i < u.size(); i++ ) {
        double dx = u[i];	//Dis[i][0][0]
        double dy = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", dx, dy, 0.0 );
    }
    fprintf ( pFile, "\nVECTORS velocities float\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) {
        double vx = v[i];
        double vy = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", vx, vy, 0.0 );
    }
    fprintf ( pFile, "\n" );

    fprintf ( pFile, "\nSCALARS phi float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) fprintf ( pFile, " %12.3e \n", phi[i]);
    fprintf ( pFile, "\n" );

    fprintf ( pFile, "\nSCALARS damage float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) fprintf ( pFile, " %12.3e \n", d[i]);
    fprintf ( pFile, "\n" );
    fclose( pFile );
}

void PotentialAvenger::printCellData ( const std::string& vtkFile ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    fprintf( pFile, "CELL_DATA %d", Nelt );
    fprintf( pFile, "\nSCALARS stress float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) fprintf( pFile, " %12.3e \n", s[i]);
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS strain float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) fprintf( pFile, " %12.3e\n", e[i]);
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS Y/Yc float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) fprintf( pFile, " %12.3e \n", e[i]*s[i]*0.5/Yc);
    fprintf( pFile, "\n" );

    fclose( pFile );
}

void PotentialAvenger::printGlobalInfo () const {

    if ( _EnrgFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _EnrgFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", t[_Nt] );
        fprintf( pFile, "%12.3e", strain_energy );
        fprintf( pFile, "%12.3e", dissip_energy );
        fprintf( pFile, "%12.3e", ext_energy );
        fprintf( pFile, "%12.3e", kinetic_energy );
	fprintf( pFile, "%12.3e", max_energy * 0.01 );
	fprintf( pFile, "%12.3e", tot_energy );
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::printFrags () {
    double DSum = 0.0;
    for (unsigned i = 0; i < d.size(); ++i) DSum += d[i];

    if ( _FragFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _FragFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", t[_Nt] );
        fprintf( pFile, "%12u", _numFrag );
        fprintf( pFile, "%12.3f", DSum );
        fprintf( pFile, "%12.3e", _fMean );
        fprintf( pFile, "%12.3e", _fMed );
        fprintf( pFile, "%12.3e", _fMax );
	fprintf( pFile, "%12.3e", _fMin );
	fprintf( pFile, "%12.3e", _fStDev );
	fprintf( pFile, "%12.3e", _fRange );
	fprintf( pFile, "%12.3f", _fSkew );
	fprintf( pFile, "%12.3f", _fExKurtosis );
	if (_numFrag <= 10){
	    for (unsigned i = 0; i < fragment_list.size(); i++){
		fprintf( pFile, "%12f", fragment_list[i].length() );
	    }
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::printSTheta () {
    if ( _SThetaFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _SThetaFile.c_str(), "a" );
        //fprintf( pFile, "%12.3e", _T );
	for (unsigned i = 0; i < Nelt; i++) {
	    double sprTheta = (double)(360*(i+0.5))/(double)(Nelt);
	    double cohTheta = (double)(360*(i+1))/(double)(Nelt);
	    fprintf( pFile, "%12.3e", t[_Nt] );
	    fprintf( pFile, "%12.3f", sprTheta );
        fprintf( pFile, "%12.3e", s[i] );
        fprintf( pFile, "%12.3f", cohTheta );
//        fprintf( pFile, "%12.3e", _sigCoh[i] );
        fprintf( pFile, "%12.3e", dm.dval(phi[i]) );
        fprintf( pFile, "%12.3f", (double)(i) );
        fprintf( pFile, "%12.3f", (double)(_Nt) );
	    fprintf( pFile, "\n" );
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::fragmentStats() {

    if (fragment_list.size() == 0) return;

	//Initialize statistics of fragment length distribution
	_fMean = 0;
	_fMed = 0;
	_fMax = 0;
	_fMin = 0;
	_fStDev = 0;
	_fRange = 0;
	_fSkew = 0;
	_fExKurtosis = 0;

	//If there are any fragments...
	//Calculate Median
	// Sort the list in ascending order
    vector<double> fragLength(0);
    for (unsigned i = 0; i < fragment_list.size(); ++i) {
        double fragLen = fragment_list[i].length()*static_cast<double>(h);
        if (((fragment_list.size() % 2) == 1) && (fragment_list[i].begin() == 0)) fragLen *= 2;
        fragLength.push_back(fragLen);
    }
	sort(fragLength.begin(), fragLength.end());

	if (fragLength.size() % 2 == 0) {
        	//If even number, take average of two middle values
		_fMed = ( fragLength[ (unsigned)(fragLength.size() * 0.5) ]
			+ fragLength[ (unsigned)(fragLength.size() * 0.5) -1 ] ) * 0.5;
	} else {
		//If odd number, take middle value
		_fMed = fragLength[ (fragLength.size() - 1) / 2 ];
	}
	//Calculate Max, Min, Range
	_fMax = fragLength.back();
	_fMin = fragLength.front();
	_fRange = _fMax - _fMin;

	//Calculate Mean
	for (unsigned k = 0; k < fragLength.size(); k++){
		//Sum of lengths
		_fMean += fragLength[k];
	}
    //Mean = sum / number
	_fMean = _fMean / _numFrag;

	//Calculate Std. Deviation
	for (unsigned k = 0; k < fragLength.size(); k++){
		//Sum of squared (lengths - means)
		_fStDev += pow( (fragLength[k] - _fMean), 2);
	}
	_fStDev = sqrt( _fStDev / _numFrag ) ;

	//Calculate Skew
	for (unsigned k = 0; k < fragLength.size(); k++){
		//Sum of squared (lengths - means)
		_fSkew += pow( (fragLength[k] - _fMean), 3);
	}
	_fSkew = _fSkew / (_numFrag * pow(_fStDev,3) );

	//Calculate Kurtosis
	for (unsigned k = 0; k < fragLength.size(); k++){
		//Sum of squared (lengths - means)
		_fExKurtosis += pow( (fragLength[k] - _fMean), 4);
	}
	_fExKurtosis = _fExKurtosis / (_numFrag * pow(_fStDev,4) ) - 3.0;
    return;
}


void PotentialAvenger::printHisto() {
    // Prints Histogram and scaled 1-cdf figure
    vector<vector<double> > fragInvCDF;
    vector<unsigned> fHisto;

    if (_numFrag > 1) {

        vector<double> fragLength(0);
        for (unsigned i = 0; i < fragment_list.size(); ++i) {
            double fragLen = fragment_list[i].length()*static_cast<double>(h);
            if (((fragment_list.size() % 2) == 1) && (fragment_list[i].begin() == 0)) fragLen *= 2;
            fragLength.push_back(fragLen);
        }
        	sort(fragLength.begin(), fragLength.end());

		fragInvCDF.resize(2);
		fragInvCDF[0].resize(1000);	//a length, from zero to the max. fragment size
		fragInvCDF[1].resize(1000);	//number of fragments larger than this length
		fHisto.assign(25, 0);		//number of bins for the fragment histogram
	
		//Histogram - 25 bins
		 double max = _fMax;	//size
		//Step through fragment length list; increase count in the bin if fragment fits
		for (unsigned k = 0; k < fragment_list.size(); k++){
            double length = fragLength[k];
            if (fragment_list.size() % 2 == 1) length *= 2; //if not broken from wall, this segment has twice the length
			if (length < max * 0.04) fHisto[0]++;
			if ((length < max * 0.08) && (length >= max * 0.04)) fHisto[1]++;
			if ((length < max * 0.12) && (length >= max * 0.08)) fHisto[2]++;
			if ((length < max * 0.16) && (length >= max * 0.12)) fHisto[3]++;
			if ((length < max * 0.20) && (length >= max * 0.16)) fHisto[4]++;
			if ((length < max * 0.24) && (length >= max * 0.20)) fHisto[5]++;
			if ((length < max * 0.28) && (length >= max * 0.24)) fHisto[6]++;
			if ((length < max * 0.32) && (length >= max * 0.28)) fHisto[7]++;
			if ((length < max * 0.36) && (length >= max * 0.32)) fHisto[8]++;
			if ((length < max * 0.40) && (length >= max * 0.36)) fHisto[9]++;
			if ((length < max * 0.44) && (length >= max * 0.40)) fHisto[10]++;
			if ((length < max * 0.48) && (length >= max * 0.44)) fHisto[11]++;
			if ((length < max * 0.52) && (length >= max * 0.48)) fHisto[12]++;
			if ((length < max * 0.56) && (length >= max * 0.52)) fHisto[13]++;
			if ((length < max * 0.60) && (length >= max * 0.56)) fHisto[14]++;
			if ((length < max * 0.64) && (length >= max * 0.60)) fHisto[15]++;
			if ((length < max * 0.68) && (length >= max * 0.64)) fHisto[16]++;
			if ((length < max * 0.72) && (length >= max * 0.68)) fHisto[17]++;
			if ((length < max * 0.76) && (length >= max * 0.72)) fHisto[18]++;
			if ((length < max * 0.80) && (length >= max * 0.76)) fHisto[19]++;
			if ((length < max * 0.84) && (length >= max * 0.80)) fHisto[20]++;
			if ((length < max * 0.88) && (length >= max * 0.84)) fHisto[21]++;
			if ((length < max * 0.92) && (length >= max * 0.88)) fHisto[22]++;
			if ((length < max * 0.96) && (length >= max * 0.92)) fHisto[23]++;
			if ((length <= max) && (length >= max * 0.96)) fHisto[24]++;
		}

		//Open file to record histogram and 1-cdf data
		if ( _HistoFile.size() > 0 ) {
			FILE * pFile;
			pFile = fopen( _HistoFile.c_str(), "a" );
			double j = 0;
			for (unsigned i = 0; i < 1000; i++) {

				//grab the 1-cdf data; 
				unsigned count = 0;
				j = max * (static_cast<double>(i) / 1000.0);	//from 0 to max length, 1000 increments
				for (unsigned k = 0; k < fragment_list.size(); k++) {
                    double length = fragLength[k];
					if (length > j) {		//if frag length greater than j, add to count
						count += 1;
					}
				}
		
				//save to vector
				fragInvCDF[0][i] = j;
				fragInvCDF[1][i] = (double)count;
				fprintf( pFile, "%6.3e %u", j, count);		//print to file

				//print histogram info to file - relative size (% of max frag length) & count
				if (i < 25) {	//piggybacking the for loop, only need the first 25
					fprintf( pFile, " %f %u", (double)(i*4+2), fHisto[i] );
				} else {
					fprintf( pFile, " 0 0");
				}
				fprintf( pFile, "\n" );
			}

			//print raw fragment sizes to file
			fprintf( pFile, "# Sizes: \n" );
			for (unsigned k = 0; k < fragment_list.size(); k++){
                double length = fragment_list[k].length();
                if (fragment_list.size() % 2 == 1) length *= 2; //if not broken from wall, this segment has twice the length
				fprintf( pFile, "%12.3e \n", length );
			}

			fclose( pFile );
		}
    }
    return;
}


void PotentialAvenger::printClean () const {
    std::string cleanPath = _path+"/clean.sh";
    FILE * pFile;
    pFile = fopen( cleanPath.c_str(), "w" );
    fprintf( pFile, "#!/bin/bash\n\n" );
    fprintf( pFile, "# Go to results directory\n" );
    fprintf( pFile, "cd %s\n\n", _path.c_str() );
    fprintf( pFile, "# Remove the data files\n" );
    fprintf( pFile, "cd ./datFiles/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "cd ./automatedRuns/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "# Remove the gnuplot files\n" );
    fprintf( pFile, "cd ./gnuplot/ ; rm *.plt; cd -\n\n" );
    fprintf( pFile, "# Remove the png/svg files\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.png; cd -\n\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.svg; cd -\n\n" );
    fprintf( pFile, "# Remove the vtk files\n" );
    fprintf( pFile, "cd ./vtkFiles/; find . -name \"*.vtk\" -print0 | xargs -0 rm -f; cd -\n\n" );
    fprintf( pFile, "# Remove plot.sh\n" );
    fprintf( pFile, "rm plot.sh\n" );
    fclose( pFile );
    std::string shellCmd = "chmod u+x " + cleanPath;
    //int status = system( shellCmd.c_str() );
	system( shellCmd.c_str() );

    shellCmd = "./" + cleanPath;
	system( shellCmd.c_str() );

}

