//potential-avenger.c
//Andrew Stershic
//DCML, Duke University
//(c) 2013, 2014

#include <potential-avenger.h>
#include <limits>
#include <sys/stat.h>

using namespace std;

PotentialAvenger::PotentialAvenger(double& in0, double& in1, double& in2, unsigned& in3, double& in4, unsigned& in5, unsigned& in6, int& in7, double& in8, double& in9, unsigned& in10, unsigned& in11, unsigned& in12, string& path){
    strain_rate = in0;
    ts_refine = in1;
    end_t = in2;
    Nelt = in3;
    lc = in4;
    startWithLoad = in5;
    printVTK = in6;
    oneAtATime = in7;
    minOpenDist = in8;
	alpha = in9;
    localOnly = in10;
    visualizeCracks = in11;
    fullCompression = in12;
    _path = path + "/results";

    _numFrag = 0;    

    //make plot files
    printClean();
	plotEnergies();
    plotFrags();
    plotHisto();
    plotSTheta();

};

PotentialAvenger::~PotentialAvenger(){
// create a plot file if necessary
    std::string plotFil = _path+"/plot.sh";		//"../results/plot.sh"
    FILE * pFileP;
    pFileP = fopen( plotFil.c_str(), "w" );
    fprintf( pFileP, "#!/bin/bash\n" );
    fprintf( pFileP, "# shell script generated by <ring.h>" );
    fprintf( pFileP, " -- MH [DCML] (2010)\n\n" );
    if ( _EnrgFile.size() != 0 ) {
        std::string enrgFil = "./gnuplot/plotEnrg.plt";
        fprintf( pFileP, "gnuplot %s\n", enrgFil.c_str() );
    }
    if ( _FragFile.size() != 0 ) {
        std::string fragFil = "./gnuplot/plotFragInfo.plt";
        fprintf( pFileP, "gnuplot %s\n", fragFil.c_str() );
    }
    if ( _HistoFile.size() != 0 ) {
        std::string histoFil = "./gnuplot/plotHisto.plt";
        fprintf( pFileP, "gnuplot %s\n", histoFil.c_str() );
    }
    if ( _SThetaFile.size() != 0 ) {
        std::string sThetaFil = "./gnuplot/plotSTheta.plt";
        fprintf( pFileP, "gnuplot %s\n", sThetaFil.c_str() );
    }
    fprintf( pFileP, "\n/usr/bin/open -a \"/Applications/Google Chrome.app\" ./pngFiles/*.svg &\n" );
    fclose( pFileP );
    chmod( plotFil.c_str(), 0775 );

};

unsigned min(const vector<unsigned> in) {
    assert(in.size() > 0);
    unsigned min = in[0];
    for (unsigned i = 1; i < in.size(); ++i) {
        if (in[i] < min) min = in[1];
    }
    return min;
}

unsigned max(const vector<unsigned> in) {
    assert(in.size() > 0);
    unsigned max = in[0];
    for (unsigned i = 1; i < in.size(); ++i) {
        if (in[i] > max) max = in[1];
    }
    return max;
}

double dotProduct(const vector<double> a, const vector<double> b) {
    double sum = 0;
    assert(a.size() == b.size() );
    for (unsigned i = 0; i < a.size(); ++i) sum+= a[i]*b[i];
    return sum;
}

int median(const vector<int> in) {
    return in[(in.size()-1)/2];
}

double sum(const vector<double> in) {
    return dotProduct(in,vector<double>(in.size(),1));
}

double sum(const vector<unsigned> in) {
    unsigned result = 0;
    for (unsigned i = 0; i < in.size(); ++i) result += in[i];
    return result;
}

template <typename T> double sgn(T val) {
    return (T(0) < val) - (val < T(0));
}

double printable (double in) {
    double limit = numeric_limits<double>::epsilon();
	if (fabs(in) < limit) return 0.0;
    else return in;
}

void PotentialAvenger::run(const double& Ein, const double& rhoIn, const double& Ain, const double& Lin, const double& Ycin, const vector<double>& pg, const vector<double>& wg, const vector<double>& phiIn, const vector<Segment*> segIn, unsigned& nucleated, bool& vbc, const vector<double>& eIn, const vector<double>& xIn, const vector<double>& uIn, const vector<double>& vIn, const vector<double>& YcvIn, DamageModel& dm) {

    printRunInfo();

	//copy input variables
	E = Ein;
	rho = rhoIn;
	A = Ain;
	L = Lin;
	Yc = Ycin;

    Nnod = Nelt+1;
    _Nt = 0;
    double c = sqrt(E/rho);
    h = 1/static_cast<double>(Nelt); //
    double cfl = 1./ts_refine;
    dt = cfl * h/c;//
    unsigned Ntim = static_cast<unsigned>(Nelt*ts_refine*end_t*c)+1;
    ec = sqrt(2 * Yc / E);
    sigc = E * ec;
	
	EPS = numeric_limits<double>::epsilon();
    d = vector<double>(Nelt,0);
    d_quad = vector<vector<double> >(Nelt);
    d_quad_wt = vector<vector<double> >(Nelt);
    d_1 = vector<double>(Nelt,0);
    d_max = vector<double>(Nelt,0);
    s = vector<double>(Nelt,0.0);
    energy = vector<double>(Nelt,0);
    Y = vector<double>(Nelt,0);
    Ybar = vector<double>(Nelt,0);
    Ycv = vector<double>(Nelt,Yc);
    strain_energy = 0.0;
    kinetic_energy = 0.0;
    dissip_energy = 0.0;
    dissip_energy_local = 0.0;
    dissip_energy_TLS = 0.0;
    ext_energy = 0.0;
    tot_energy = 0.0;
    vector<Fragment*> fragment_list;

    ustat = vector<double>(Nnod,0);
    Ystat = vector<double>(Nnod,0);
    u = uIn;
    v = vIn;
    a = vector<double>(Nnod,0);
    phiL = vector<double>(Nelt,0);
    phiNL = phiIn;

    phiNL_1 = vector<double>(Nnod,0);
    phidot = vector<vector<double> >(Ntim);
    gradPhiL = vector<double>(Nnod,0.0);
    gradPhiNL = vector<double>(Nnod,0.0);
    gradPhiNLelem = vector<double>(Nelt,0.0);

    vector<unsigned> nbiter = vector<unsigned>(Ntim,0);
    nfrags = vector<unsigned>(Ntim,0);
    _numFrag = 0;
    vector<Segment*> segments;

    m.assign(Nnod,rho*h*A);
    m[0] = m[0]/2; m[Nnod-1] = m[Nnod-1]/2;

    //initialization
	Ycv = YcvIn;
	e = eIn;
	x = xIn;

    xe = vector<double>(Nnod,0);
    for (unsigned j = 0; j < Nelt; ++j) xe[j] = 0.5*(x[j] + x[j+1]);

    t = vector<double>(Ntim,0);
    for (unsigned j = 0; j < Ntim; ++j) t[j] = static_cast<double>(j)*dt;

    // Initially the bar is loaded and all elements are at Yc
    // A tls is placed on the first element, obviously it satifies
    //   Ybar = Yc
    // This extra damage will create new stress that are less than in the next element
    // and ill thus give an unloading wave.

    //constant strain rate applied

    for (unsigned j = 0; j < Nnod; ++j) {
        ustat[j] = 0.0;//x[j] * ec * L * 0.999*(1-vbc);
        if (j < Nnod-1) phiL[j] = 0.0;//(2*h-x[j])*(1-vbc)-vbc;
    }

    //check to see which elements are in TLS zones
    inTLS.assign(Nelt,0);
    inTLSnode.assign(Nnod,0);
    checkInTLS(segments,inTLS,inTLSnode);

    //calculate stresses
	for (unsigned j = 0; j < Nelt; ++j) calculateStressesL(pg,wg,j);

    if (localOnly == 0) calculateStressesNL(pg,wg,segments);
    //acceleration
    a[0] = 0;
    a[Nnod-1] = 0;
    for (unsigned j = 1; j < Nnod-1; ++j)  a[j] = A*(s[j] - s[j-1]) /m[j];

    nbiter[0] = 0;
    analyzeDamage(phiNL,h,segments);
    unsigned len = 0;
    for (unsigned l = 0; l < segments.size(); ++l) {
        if (segments[l]->size() == 0) continue;
        len++;
    }
    phidot[0].resize(len);

    //print data to file
    vector<double>fragLength = findFragments(dm, phiL, phiNL,nfrags[0],segments);
    calculateEnergies(0,pg,wg);
    if (printVTK != 0) printVtk(_Nt);
    printFrags(fragLength);
    printGlobalInfo();

    //time-integration loop
    for (unsigned i = 1; i < Ntim; ++i){
        _Nt++;
//cout << "t = " << t[i] << endl;

		Ybar.assign(Nelt,0.0);

        //Copy kinematic variables to "old"
        u_1 = vector<double>(Nnod,0); u_1 = u; u.assign(Nnod,0.0);
        vector<double> v_1 = vector<double>(Nnod,0); v_1 = v; v.assign(Nnod,0.0);
        vector<double> a_1 = vector<double>(Nnod,0); a_1 = a; a.assign(Nnod,0.0);
        d_1 = vector<double>(Nnod,0); d_1 = d; d.assign(Nnod,0.0);
        phiNL_1 = phiNL;


        //prediction
        for (unsigned j = 0; j < Nnod; ++j) {
            v[j]= v_1[j] + 0.5*dt*a_1[j];
            u[j]= u_1[j] + dt*v_1[j] + 0.5*dt*dt*a_1[j];
        }

        //def computation and Y update.
        for (unsigned j = 0; j < Nelt; ++j) {
            e[j] = (u[j+1] - u[j]) / h;
            //b=0.5*E*e(i,j)*e(i,j)-Yc;
        }

        //updating the stress and level-set fields
		//local
		for (unsigned j = 0; j < Nelt; ++j) {
			unsigned status = calculateStressesL(pg,wg,j); 
        	if (status == 1) updateLevelSetL(i,nbiter,segments,pg,wg,j);
		}
		//non-local / TLS
		if (localOnly == 0) {
        	updateLevelSetNL(i,nbiter,segments,pg,wg);
        	if (nucleated > 0) setPeakAll(phiNL,segments); 
    		analyzeDamage(phiNL,h,segments);
        	for (unsigned j = 0; j < Nnod; ++j)  phiNL[j] = max(phiNL[j], phiNL_1[j]);
        	calculateStressesNL(pg,wg,segments);
		} 
        // moving the localization front
        // we compute a = integral (Yn+1 - Yc) d' in the current non-local zone
        // then we compute b = (Yn+1-Yc) d' on the front
        // the shift in level set if the ratio of the two.


                if (alpha > 0) calculateLevelSetGradientL(d, gradPhiL);
                calculateLevelSetGradientNL(d, gradPhiNL);
        //check for nucleation
		unsigned numNuc = 0;
		unsigned nSegs = segments.size();
        if (localOnly == 0) {
	    	if (alpha == 0) {
	    		//non-local-only model
    	        vector<double> Yin;
	            for (unsigned l = 0; l < Nelt; ++l)  Yin.push_back(0.5*E*e[l]*e[l]);
    	        string elemOrNodal="elem";
            	numNuc = checkFailureCriteria(i,Ycv,elemOrNodal,Yin,false,false,1.0*h,segments, nbiter, pg, wg);//delete this 0.5*h rather than 2*h
    		} else {
		    	//local / non-local hybrid model
		    	string elemOrNodal = "nodal";
		    	vector<double> gradLimit(Nnod,1.0);
		    	numNuc = checkFailureCriteria(i,gradLimit,elemOrNodal,gradPhiL,true,true, 1.0*h, segments, nbiter, pg, wg);
		    }
        }

        //enforce phi constraints - update segments
		//if it nucleated this time-step, set YbarmYc = 0
		if (numNuc > 0) for (unsigned l = nSegs; l < segments.size(); ++l) segments.at(l)->YbarmYc = 0.0;

		if (numNuc > 0) {
        	setPeakAll(phiNL,segments); 
            updateLevelSetNL(i,nbiter,segments,pg,wg);
        	setPeakAll(phiNL,segments); 
    		analyzeDamage(phiNL,h,segments);
        	for (unsigned j = 0; j < Nnod; ++j)  phiNL[j] = max(phiNL[j], phiNL_1[j]);
            checkInTLS(segments,inTLS,inTLSnode);
            calculateStressesNL(pg,wg,segments);
		}
        int index = -1;
        for (unsigned l = 0; l < segments.size(); ++l) {
            if (segments[l]->size() == 0) continue;
            index++;
            //median(segments[l]);
            int smid = median(segments[l]->indices);

            len = 0;
            for (unsigned j = 0; j < segments.size(); ++j) {
                if (segments[j]->size() == 0) continue;
                len++;
            }
            phidot.at(i).resize(len);
            phidot.at(i).at(index) = (phiNL[smid] - phiNL_1[smid])/dt;
            if (phidot[i][index] * dt > h*1.01 ) {
                printf("level-set front advancing more than one element per time-step: t=%f, segment %u , dphi/h = %f \n",t[i],l,phidot[i][index]*dt/h);
            }
        }


        //check to see which elements are in TLS zones
        checkInTLS(segments,inTLS,inTLSnode);
       

        for (unsigned j = 1; j < Nnod-1; ++j)  phiNL[j] = max(phiNL[j], phiNL_1[j]);

		//acceleration
        if (max(phiL[0],phiNL[0]) <= lc) a[0] = 0;
        else a[0] =  A*s[0]/m[0];
        a[Nnod-1] = 0; //note: this is a constraint which was hidden. if free, it would be -s(i,Nnod)/m(j);
        for (unsigned j = 1; j < Nnod - 1; ++j) a[j] = A*(s[j] - s[j-1]) /m[j];

        //correction
        for (unsigned j = 0; j < Nnod; ++j) v[j]= v[j] + 0.5*dt*a[j];

        //record number of fragments and quantities per fragment
        fragLength.clear();
        fragLength = findFragments(dm, phiL, phiNL, nfrags[i],segments);
        _numFrag = nfrags[i];

        //calculate energies
        calculateEnergies(i,pg,wg);

        //update gradient for printing
		calculateLevelSetGradientL(d, gradPhiL);
		calculateLevelSetGradientNL(d, gradPhiNL);

		//update Ybar after segments redefined
        for (unsigned l = 0; l < segments.size(); ++l) {
            if (segments[l]->size()==0) continue;//segments.erase(segments.begin()+l);
            unsigned sbegin = segments[l]->begin();
            unsigned send = segments[l]->end();
            //clear Ybar
            segments[l]->YbarmYc = 0.0; 
            double YbarmYc = 0.0; double Ycavg = 0.0;
            double residu_Y = 0.0; double tangent_Y = 0.0;
            double phimin = 0.0;  double phimax = 0.0;
       		double phiminY = 0.0; double phimaxY = 0.0;
        	unsigned status = calculateYbar(pg,wg,Ycavg,YbarmYc,residu_Y,tangent_Y,phimin,phimax,phiminY,phimaxY,nbiter[i],sbegin,send,segments[l]);
		}

        //check enforcement of constraints
        checkConstraints(gradPhiL,gradPhiNL,segments);

		//print the rest of the table/graph data
        if (printVTK != 0) if ( ( _Nt % printVTK) == 0 ) {printVtk(_Nt); cout << "*t = " << t[i] << endl;}
        printFrags(fragLength);
        printGlobalInfo();

    }//end time-loop

    //find fragment length total & minimum
    cout << " fragment lengths:" << endl;
    double minfrag = _fMin; 
	double sumfrag = 0.0;
    for (unsigned i = 0; i < fragLength.size(); ++i) {
        cout << fragLength[i] << endl;
		if (minfrag > fragLength[i] ) minfrag = fragLength[i];
		sumfrag += fragLength[i];
	}
     nfrags[Ntim-1] = fragLength.size(); 

    printf("Final number of fragments: %i \nMinimum fragment length: %f    avg = %f\nFinal dissipated energy: %3.3e   = local %3.3e + TLS %3.3e  (%f/%f)\n",nfrags[Ntim-1],minfrag,sumfrag*L/static_cast<double>(nfrags[Ntim-1]),dissip_energy,dissip_energy_local,dissip_energy_TLS,dissip_energy_local/dissip_energy,dissip_energy_TLS/dissip_energy);
    double alt_dissip_energy = 0.0 + ext_energy - strain_energy - kinetic_energy; 
    printf("alt. dissipated energy: %3.3e \n",alt_dissip_energy); 
   cout << " fragment total length " << sumfrag << "     powder length = " << 2.0*L - sumfrag << endl;
    
    //print histogram
    printHisto(fragLength);

    //kill all segments and fragments
    killSegments(segments);
    killFragments(fragment_list);
    return;
};

void PotentialAvenger::killSegments(vector<Segment*>& seg) {
    for (unsigned i = 0; i < seg.size(); ++i) delete seg[i];
    seg.clear();
    return;
}

void PotentialAvenger::killFragments(vector<Fragment*>& frag) {
    for (unsigned i = 0; i < frag.size(); ++i) delete frag[i];
    frag.clear();
    return;
}

void PotentialAvenger::calculateLevelSetGradientL( const vector<double>& dV, vector<double>& gradientPhi) {
	//calculate the gradient of the levelset (local model). This will be used to see if the |gradPhi| > 1,
	//in which case, a non-local zone will be inserted
	assert(gradientPhi.size() == Nnod);
    assert(gradientPhi.size() > 4);
	for (unsigned i = 1; i < Nnod-1; ++i) {
		double phiM = phiL[i];
        double phiM1 = phiL[i-1];
		gradientPhi[i] = (phiM - phiM1) / h;
	}
    gradientPhi[0] = gradientPhi[1]; 
	for (unsigned i = 0; i < Nelt; ++i) if (inTLS[i]) gradientPhi[i] = 0.0; 
    return;
}

void PotentialAvenger::calculateLevelSetGradientNL( const vector<double>& dV, vector<double>& gradientPhi) {
    //calculate the gradient of the levelset (non-local model). This will be used to see if the |gradPhi| > 1,
    //in which case, a non-local zone will be inserted
    assert(gradientPhi.size() == Nnod);
    assert(gradientPhi.size() > 4);
    //gradientPhi[0] = (phiNL[1]-phiNL[0])/(h); //first-order boundary difference
    gradientPhi[0] = (-phiNL[2]+4*phiNL[1]-3*phiNL[0])/(2*h); //second-order boundary difference
    //gradientPhi[Nnod-1] = (phiNL[Nnod-1]-phiNL[Nnod-2])/(h); //first-order boundary difference
    gradientPhi[Nnod-1] = (3*phiNL[Nnod-1]-4*phiNL[Nnod-2]+phiNL[Nnod-3])/(2*h); //second-order boundary difference
    for (unsigned i = 1; i < Nnod-1; ++i) {
       double phiM = 0.5 * (phiNL[i] + phiNL[i+1]); 
       double phiM1 = 0.5* (phiNL[i] + phiNL[i-1]);
       gradientPhi[i] = (phiM - phiM1) / h;
    }

	//calculate gradient of level-set within elements of non-local zone
	for (unsigned i = 0; i < Nelt; ++i) {
		gradPhiNLelem[i] = (phiNL[i+1]-phiNL[i])/h;
	}
    return;
}

void PotentialAvenger::checkInTLS(const vector<Segment*>& segments, vector<unsigned>& elem, vector<unsigned>& nodes) {
	
	vector<unsigned> nodes_old = nodes;
	elem.assign(Nelt, 0);
	nodes.assign(Nnod,0);
    //check nodes; 1 = in TLS zone, 0 = not
    if (nucleated > 0) {
        for (unsigned index = 0; index < Nnod; ++index) {
			//compare to phiL on both sides (if possible). inTLS if phiNL > max(phiL)
			double phiLocal = 0.0;
			if (index > 0) phiLocal = max(phiLocal, phiL[index]);
			if (index < Nnod-1) phiLocal = max(phiLocal, phiL[index+1]);
			if (phiNL[index] >= phiLocal || nodes_old[index] == 1) nodes[index] = 1;
    	}
    }
//assert(elem.size() == inTLS.size() );
    //check elements based on node results
    for (unsigned k = 0; k < Nelt; ++k) {
        //if both nodes are not in TLS zones, then element is not in TLS zone; if one or both are in, then element is in
        if (nodes[k] == 0 && nodes[k+1] == 0) elem[k] = 0;
        else elem[k] = 1;
    }
    return;
}

void PotentialAvenger::checkConstraints(const vector<double>& gradientPhiL, const vector<double>& gradientPhiNL, const vector<Segment*>& segments) {

	//check gradient of level-set
	assert(gradientPhiL.size() == Nnod);
	assert(gradientPhiNL.size() == Nnod);
   
	if (localOnly == 0 && minOpenDist == 0.0 && alpha > 0) for (unsigned j = 0; j < Nnod; ++j) assert(fabs(gradientPhiL[j]) < 1.0 + Nelt*EPS);
    //if (localOnly == 0) for (unsigned j = 0; j < Nnod; ++j) assert(fabs(gradientPhiNL[j]) <= 1.0);

    //for local: check that Y <= Yc
	if (alpha > 0) {
    	for (unsigned j = 0; j < Nelt; ++j) if (inTLS[j] == 0 && d[j] < 1.0) assert( Y[j]/Ycv[j] < 1.0 + EPS*Nnod);
	}

	//for non-local: check that Ybar <= Yc
	if (minOpenDist == 0.0) {
    for (unsigned j = 0; j < segments.size(); ++j) assert( (segments[j]->YbarmYc) <= 1.e-6);
	}

	//for non-local: check that gradient of phi is 1 on all elements
	if (nucleated > 0) {
        for (unsigned l = 0; l < segments.size(); ++l) {
		double qty = (segments[l]->phipeak-segments[l]->phimin)/(segments[l]->xpeak-segments[l]->xmin);
		
/*			for (unsigned j = segments[l]->begin()+1; j < segments[l]->end()-1; ++j) {
				
				if( fabs(phiNL[j] - phiNL[j+1]) == h) {cout << " failing on segment " << l << "  element " << j << endl;} 
				assert( fabs(phiNL[j] - phiNL[j+1]) == h); 
			}
*/		}
	}

	return;
}

void PotentialAvenger::calculateStressesNL(const vector<double>& pg, const vector<double>& wg, vector<Segment*>& segments) {
    
	vector<double> dLocal = d;

    for (unsigned j = 0; j < Nelt; ++j) {

		if (inTLS[j] == 0) continue; //skip if local!
		
        d_quad[j].clear();
		d_quad_wt[j].clear();
	    s[j] = 0;
	    d[j] = 0;
   		if ((inTLS[j] == 1 && localOnly == 0) || alpha ==0.0 ) { 	//in TLS: use non-local damage model
	        assert(pg.size() == wg.size());
	
			if (inTLSnode[j]) phiNL[j] = max(phiNL[j],phiNL_1[j]);	
			if (inTLSnode[j+1]) phiNL[j+1] = max(phiNL[j+1],phiNL_1[j+1]);	
	        e[j] = (u[j+1] - u[j])/h;
  	    	vector<double> dloc(pg.size(),0.0);
			if (inTLSnode[j] == 1 && inTLSnode[j+1] == 0) {
				//element at transition: left in, right out
				double phiLocal = phiL[j+1];
				double delta = fabs(phiNL[j] - phiLocal); 
                delta = max(delta, 0.0); delta = min(delta, h);
        	    for (unsigned k = 0; k < pg.size(); ++k) {
					double philoc1 = pg[k] * phiNL[j] + (1-pg[k]) * (phiLocal);
					d_quad[j].push_back(dm.dval(philoc1));
					d_quad_wt[j].push_back(wg[k] * delta/h);
					dloc[k] = dm.dval(philoc1);
					d[j] += wg[k] * dloc[k] * delta/h;
            	    s[j] += wg[k] * (1.0-dloc[k]) * E * e[j] * delta/h;
                }
				d[j] += (h-delta)/h * dm.dval(phiLocal);
				s[j] += (h-delta)/h * (1.0-dm.dval(phiLocal)) * E * e[j];
				d_quad[j].push_back(dm.dval(phiLocal)); 
				d_quad_wt[j].push_back(1.0 * (h-delta)/h );
                

			} else if (inTLSnode[j] == 0 && inTLSnode[j+1] == 1) {
				//element at transition: left out, right in
				double phiLocal = phiL[j];
                double delta = h - fabs(phiLocal - phiNL[j+1]);
                delta = max(delta, 0.0); delta = min(delta, h);
                for (unsigned k = 0; k < pg.size(); ++k) {
                    double philoc1 = pg[k] * phiLocal + (1-pg[k]) * (phiNL[j+1]);
                    d_quad[j].push_back(dm.dval(philoc1));
                    d_quad_wt[j].push_back(wg[k] * (h-delta)/h);
                    dloc[k] = dm.dval(philoc1);
                    d[j] += wg[k] * dloc[k] * (h-delta)/h;
                    s[j] += wg[k] * (1.0-dloc[k]) * E * e[j] * (h-delta)/h;
//cout << " added 0 " << dm.dval(philoc1) << " ( " << wg[k] * delta/h << " )" <<endl;
                }   
				d[j] += delta/h * dm.dval(phiLocal);
				s[j] += delta/h * (1.0 - dm.dval(phiLocal)) * E * e[j];
                d_quad[j].push_back(dm.dval(phiLocal));
                d_quad_wt[j].push_back(1.0 * delta/h );
//cout << " added 0 " << dm.dval(phiLocal) <<  " ( " << (h-delta)/h << " ) " << endl;

    	    } else if (phiNL[j] > 0  && phiNL[j+1] > 0) {
				//both sides positive
        	    for (unsigned k = 0; k < pg.size(); ++k) {
            	    if (fabs(fabs(phiNL[j] - phiNL[j+1]) - h) > EPS) {
                	    //there's a peak/anti-peak inside!
                    	double delta = 0.5*(h - phiNL[j+1] + phiNL[j]); //delta computed for anti-peak

						//see if any peaks are within element -> reverse delta
						bool flag = false;
						for (unsigned ii = 0; ii < segments.size(); ++ii) {
							if (segments[ii]->xpeak >= x[j] && segments[ii]->xpeak <= x[j+1]) flag = true;
						}
						if (flag == true)  delta = h - delta;

	                    //subdivide interval into two: [x1, x1+delta] [x1+delta, x2], effectively double number of integration points
    	                double philoc1 = pg[k] * phiNL[j] + (1-pg[k]) * (phiNL[j] - delta);
    	                if (flag) philoc1 = pg[k] * phiNL[j] + (1-pg[k]) * (phiNL[j] + delta);
        	            double philoc2 = pg[k] * (phiNL[j] - delta) + (1-pg[k]) * phiNL[j+1];
        	            if (flag) philoc2 = pg[k] * (phiNL[j] + delta) + (1-pg[k]) * phiNL[j+1];
						d_quad[j].push_back(dm.dval(philoc1));
						d_quad[j].push_back(dm.dval(philoc2));
						d_quad_wt[j].push_back(delta/h * wg[k]);
						d_quad_wt[j].push_back((h-delta)/h * wg[k]);
            	        dloc[k] = delta/h * dm.dval(philoc1) + (h-delta)/h * dm.dval(philoc2);
                	} else {
	                    double philoc = pg[k] * phiNL[j] + (1-pg[k]) * phiNL[j+1];
						d_quad[j].push_back(dm.dval(philoc));
						d_quad_wt[j].push_back(wg[k]);
    	                dloc[k] = dm.dval(philoc);
        	        }
            	    s[j] += wg[k] * (1-dloc[k]) * E * e[j];
					d[j] += wg[k] * dloc[k];
	            }
    	    } else if  (phiNL[j] <= 0 && phiNL[j+1] <= 0) {
				//both sides negative
        	    s[j] = E * e[j];
			    d_quad[j].push_back(0.0);
				d_quad_wt[j].push_back(1.0); 
	        } else if  (phiNL[j] > 0 && phiNL[j+1] <= 0) {
				//left side positive, right side negative
    	        double delta = fabs(phiNL[j]) / (fabs(phiNL[j])+fabs(phiNL[j+1]));
        	    double sloc = 0;
            	for (unsigned k = 0; k < pg.size(); ++k) {
                	double philoc = pg[k] * phiNL[j];
	                dloc[k] = dm.dval(philoc);
    	            sloc += wg[k] * (1-dloc[k]) * E * e[j];
			        d[j] += wg[k] * dloc[k] * delta; //+ ( 1-delta) * 0.0
					d_quad[j].push_back(dm.dval(philoc));
					d_quad_wt[j].push_back(wg[k] * delta);
        	    }
				d_quad[j].push_back(0.0);
				d_quad_wt[j].push_back( 1-delta );
            	s[j] = delta *  sloc +  (1-delta) * E * e[j];
	        } else if (phiNL[j] <= 0 && phiNL[j+1] > 0) {
				//left side negative, right side positive
    	        double delta = fabs(phiNL[j+1]) / (fabs(phiNL[j])+fabs(phiNL[j+1]));
        	    double sloc = 0;
            	for (unsigned k = 0; k < pg.size(); ++k) {
                	double philoc = pg[k] * phiNL[j+1];
	                dloc[k] = dm.dval(philoc);
    	            sloc += wg[k] * (1-dloc[k]) * E * e[j];
			        d[j] += wg[k] * dloc[k] * delta; //+ ( 1-delta) * 0.0
					d_quad[j].push_back(dm.dval(philoc));
					d_quad_wt[j].push_back(wg[k] * delta); 
        	    }
				d_quad[j].push_back(0.0);
				d_quad_wt[j].push_back( 1-delta );
            	s[j] = delta *  sloc +  (1-delta) * E * e[j];
	        }

            if (d[j] > d_max[j]) d_max[j] = d[j];		//update maximum damage

			if (inTLSnode[j] + inTLSnode[j+1] == 1) {
				//if (d[j] < d_max[j]) d[j] = d_max[j];
			}

            if (fullCompression) {
                //this makes compression fully in contact no matter what the damage
                if (e[j] < 0) s[j] = e[j] * E;
            }
		}

        assert(d_quad[j].size() == d_quad_wt[j].size());
        assert(fabs(sum(d_quad_wt[j]) - 1.0) < 1.0e-6);
        assert(d_quad[j].size() == d_quad_wt[j].size());
	}

	return;
}

unsigned PotentialAvenger::calculateStressesL(const vector<double>& pg, const vector<double>& wg, const unsigned& j) {

	//for (unsigned j = 0; j < Nelt; ++j) {
	    //inTLS == 0 : local damage model
		unsigned status = 0;

        unsigned nodesInTLS = 0;
        if (inTLSnode[j]) nodesInTLS++;
        if (inTLSnode[j+1]) nodesInTLS++;
        if (nodesInTLS >= 2) return 0;


		d[j] = 0.0;
        s[j] = 0.0;
		double dee = d_1[j];
//cout << " dee before = " << dee << "  phiL before = " << phiL[j] << endl;
		//check to see if damage needs to be recalculated; (local model so no need to use quadrature for dH)
		if (0.5 * E * e[j] * e[j] > dH(j,d_1[j]) + Ycv[j]) 	{
			double factor = sqrt(2.0 * Ycv[j] / (E * e[j] * e[j]) ); 
			dee = (1.0 - fabs(factor)) / alpha;
            if (dee < 0.0) //E * e[j] * e[j] < 2.0 * Yc) 
				dee = 0.0;			//not damaged if Y < Yc
            if (dee > 1.0)
                dee = 1.0;
            assert(nodesInTLS < 2);
			status = 1;
		}
        if (dee > d_max[j]) d_max[j] = dee;		//update maximum damage
		d[j] = dee;
        s[j] = E * (1.0 - dee) * e[j];
		assert(d[j] >= d_1[j]);
		if (d[j] < 1.0) assert(0.5 * E * e[j] * e[j] - dH(j,d[j]) <= Ycv[j] * (1 + EPS));
		
        if (fullCompression) {
            //this makes compression fully in contact no matter what the damage
            if (e[j] < 0) s[j] = e[j] * E;
        }

		d_quad[j].clear();
		d_quad_wt[j].clear();

		d_quad[j].push_back(d[j]);
        d_quad_wt[j].push_back(1.0);

/*		if (d[j] > 0.0) {
			printf("elem = %u, 0.5Eee = %6.3e, dH = %6.3e, Ycv = %6.3e\n",j, 0.5 * E * e[j] * e[j], dH(j,d_1[j]), Ycv[j]);
			cout << "   new D = " << d[j] << endl;
			assert(1 == 0);
		} 
  */  
	//}
    return status;
}

void PotentialAvenger::calculateEnergies(const unsigned& i, const vector<double>& pg, const vector<double>& wg) {
    dissip_energy = 0.0;
    kinetic_energy = 0.0;

    for (unsigned j = 0; j < Nelt; ++j) {
        Y[j] = 0.5 * E * e[j] * e[j];
        for (unsigned k = 0; k < d_quad_wt[j].size(); ++k) {
            double dloc = d_quad[j][k];
            Y[j] -= d_quad_wt[j][k] * dH(j,dloc);
        }

		if (Ybar[j] == 0.0) Ybar[j] = Y[j]/Yc;

        if (inTLS[j] == 1) dissip_energy_TLS += h * A * Y[j] * (d[j] - d_1[j]); //global dissipation = int: Y dd/dt dV
        if (inTLS[j] == 0) dissip_energy_local += h * A * Y[j] * (d[j] - d_1[j]); //global dissipation = int: Y dd/dt dV
        if (i > 0) {
            kinetic_energy += 0.5 * h * A * rho * 0.5 *
                                ( pow(u[j] - u_1[j],2) + pow(u[j+1] - u_1[j+1],2) ) / pow(dt,2);
            //ustat(i,j+1) = ustat(i,j) + h*s(0,Nelt)/(E*(1-d(i,j)));
        } else {
            kinetic_energy += 0.5 * h * A * rho * 0.5 * ( v[j] * v[j] + v[j+1] * v[j+1]);
        }
        energy[j] = h * A * 0.5 * E * e[j] * e[j] * (1.0 - d[j]);
    }
    //ustat(i,:) *= u(1,Nnod)/ustat(i,Nnod);
    for (unsigned j = 0; j < Nelt; ++j) Ystat[j] = 0.5 * E * pow((ustat[j+1] - ustat[j])/h,2);

	dissip_energy = dissip_energy_local + dissip_energy_TLS;

    strain_energy = sum (energy);
    if (i > 0) ext_energy += (a[Nnod-1] * m[Nnod-1] + s[Nnod-2] * A) * v[Nnod-1] * dt;
    else ext_energy = dissip_energy + strain_energy + kinetic_energy;
    tot_energy = strain_energy + kinetic_energy + dissip_energy - ext_energy;
    max_energy = max(max(kinetic_energy,dissip_energy),strain_energy);
    return;
}

std::string convertInt(unsigned number) {
    if (number == 0)
        return "0";
    string temp="";
    string returnvalue="";
	//read from back
    while (number>0)
    {
        temp+=number%10+48;
        number/=10;
    }
    for (unsigned i=0;i<temp.length();i++)
        returnvalue+=temp[temp.length()-i-1];
    return returnvalue;
}

double PotentialAvenger::H (const unsigned j, const double dee) { 
    return (Ycv[j] * alpha * dee * dee)/(1.0 - alpha * dee);
}    

double PotentialAvenger::dH (const unsigned j, const double dee) const { 
    return (Ycv[j] * alpha * dee) * (2.0 - alpha * dee)/pow(1.0 - alpha * dee,2);
}    

double PotentialAvenger::d2H (const unsigned j, const double dee) const { 
    return (2.0 * Ycv[j] * alpha) /pow(1.0 - alpha * dee,3);
}    

void PotentialAvenger::updateLevelSetL( const unsigned& i, vector<unsigned>& nbiter, vector<Segment*>& segments, const vector<double>& pg, const vector<double>& wg, const unsigned& j) {

     //for (unsigned j = 0; j < Nelt; ++j) {
        unsigned nodesInTLS = 0;
        if (inTLSnode[j]) nodesInTLS++;
        if (inTLSnode[j+1]) nodesInTLS++;
		double dee = d[j];
        if (nodesInTLS < 2) 	phiL[j] = dm.phi(dee);
		else 				phiL[j] = 0.0;
	
     //}
	 return;
}

void PotentialAvenger::updateLevelSetNL( const unsigned& i, vector<unsigned>& nbiter, vector<Segment*>& segments, const vector<double>& pg, const vector<double>& wg ) {
	//non-local nodes   

	//save phiNL beforehand
	vector<double> phiNL_before = phiNL;
 
    for (unsigned l = 0; l < segments.size(); ++l) {
        if (segments[l]->size()==0) continue;//segments.erase(segments.begin()+l);
        unsigned sbegin = segments[l]->begin();
        unsigned send = segments[l]->end();
        
		//clear Ybar
		segments[l]->YbarmYc = 0.0;
 
        //skip if all negative
        bool allNeg = true;
        for (unsigned k = sbegin; k <= send; ++k) {
            if (phiNL[k] != -1) {
                allNeg = false;
                break;
            }
        }
        if (allNeg) continue;
        
        double err_crit = 1e15;
        double dphi = 0;
        nbiter[i] = 0;
        double residu = 0;
//cout << "int: [" << sbegin << "," << send<< "]  dmax = " << dm.dval(segments[l].phipeak) << "  phimax = " << segments[l].phipeak << "  ," << 
//"  x= " << segments[l].xpeak << "   slope = " << segments[l].slope <<
//endl;

        if (segments[l]->phipeak <= 0) continue;
        if (segments[l]->phimin >= lc) continue;

        double YbarmYc = 1.0;    
		vector<double> residuV, tangentV, phimaxV;
		unsigned iter_max = 50; 
        while (err_crit > 1.e-6 && nbiter[i] < iter_max) {
            nbiter[i]++;

			double tangent_Y = 0.0;
            double phimin = 0.0;
			double phimax = 0.0; 
            double phiminY = 0.0;
			double phimaxY = 0.0;
			double Ycavg = 0.0; 
            unsigned status = calculateYbar(pg,wg,Ycavg,YbarmYc,tangent_Y,phimin,phimax,phiminY,phimaxY,nbiter[i],sbegin,send,segments[l]);
			if (status == 0) goto next;
			if (YbarmYc < 0 && nbiter[i] == 1) goto next;
			if (segments[l]->phimin >= lc) goto next;

            int flag = 1; //0 is exterior (damage centered on edge of domain); 1 is interior
            if (segments[l]->begin() == 0 || segments[l]->end() == Nnod-1) flag = 0;

            if (l == 1 && segments[l]->begin() == 0) flag = 0;
            if (l == segments.size()-1 && segments[l]->end() == Nnod-1) flag = 0;
            residu = YbarmYc;
            err_crit = fabs(residu)/Yc ; //Ycavg;

            double tangent = tangent_Y/dm.dval(phimax)  - residu * dm.dp(phimax)/dm.dval(phimax);
//            double tangent = (tangent_Y + (phiminY-Ycavg)*dm.dp(phimin) )/( dm.dval(phimax)-dm.dval(phimin)) - dm.dp(phimax)/pow(dm.dval(phimax)-dm.dval(phimin),1) * residu;
            if (flag) tangent = (tangent_Y + 0.5*(phiminY-Ycavg)*dm.dp(phimin) - 0.5*(phimaxY-Ycavg)*dm.dp(phimax) )/( Ycavg*(dm.dval(phimax)-dm.dval(phimin)) ) - (dm.dp(phimax) - dm.dp(phimin) )/pow(dm.dval(phimax)-dm.dval(phimin),1) * (YbarmYc/Ycavg);
			if (flag && nbiter.at(i) > iter_max/2) tangent = (tangent_Y )/( dm.dval(phimax) ) - residu * dm.dp(phimax)/dm.dval(phimax);   
                //double tangent = (tangent_Y + static_cast<double>(flag)*(phimaxY-Yc[iphimax])*dm.dp(phimax)/2.0)/( Yc*(dm.dval(phimax)-dm.dval(phimin)) ) - ((1.0+static_cast<double>(flag)/2.0)*dm.dp(phimax)/pow(dm.dval(phimax)-dm.dval(phimin),2)) * (YbarmYc/Yc);
//cout << "dphi = " << dphi;
            if (fabs(tangent) <= 1.e-10) {
                /*err_crit = 0.;*/ dphi = 0.;
            } else {
                dphi = - residu/tangent;
            }
			if (err_crit <= 1.e-6) dphi = 0.0;
            if (isnan(dphi)) {
                dphi = 0;
                assert(1==0);                
            }

            for (unsigned j = sbegin; j <=send; ++j) {
                phiNL[j] += dphi;//phiNL_before[j] + dphi;
                //enforcing limit of level-set motion
                //phi[j] = min(phi_1[j]+h,phi[j]);
            }
			segments[l]->phipeak += dphi;
			segments[l]->phimin += dphi;
			checkInTLS(segments,inTLS,inTLSnode);
        	//setPeak(x,phiNL,segments,l); //segments[l].phipeak += dphi; 
        } //endwhile
		assert(nbiter[i] >= iter_max || YbarmYc/Yc <= 1.e-6);
		assert(YbarmYc/Yc <= 1.e-6);
            for (unsigned j = sbegin; j <=send; ++j) {
                phiNL[j] = max(phiNL[j],phiNL_1[j]); //constraint: dphi >= 0
            }
        next:
        err_crit = 0.0;
        //setPeak(phiNL,segments,l); //segments[l].phipeak += dphi; 

    } //for segments

    return;
}

void PotentialAvenger::setPeakAll(const vector<double>&phiIn, vector<Segment*>& segments) {
	for (unsigned l = 0; l < segments.size(); ++l) 	setPeak(phiIn,segments,l); //segments[l].phipeak += dphi; 
	return;
}

void PotentialAvenger::setPeak(const vector<double>& phiIn, vector<Segment*>& segments, const unsigned index) {
	unsigned sbegin = segments[index]->begin();
	unsigned send = segments[index]->end();	
	double slope = static_cast<double>(segments[index]->slope);
	double a1,a2,b1,b2,xint,phiint;

	//set peak	
	//find neighboring segment
	unsigned other = index;
	int dist = Nelt;
	double otherSlope = 0.0;
	if (slope == 1) {
		for (unsigned i = 0; i < segments.size(); ++i) {
			int qty = segments.at(i)->begin() - send;
			if (qty < dist && qty > 0 && segments[i]->slope < 1) {
				dist = qty;
				other = i;
				otherSlope = static_cast<double>(segments[i]->slope);
			}
		}

		//if at right edge
		if (other == index && (send == Nnod - 1) ) {
			segments[index]->xpeak = x[send];	
			segments[index]->phipeak = phiIn[send];
			goto setMin;
		}

		if (other == index) {
			segments[index]->xpeak = 0.5 * (x[sbegin] + x[send]);
			segments[index]->phipeak = 0.5 * (phiIn[sbegin] + phiIn[send]);
			other = -1;
			otherSlope = -slope;
			goto setMin;
		}
		assert(other != index);
		assert(otherSlope != slope);
	} else {
        for (unsigned i = 0; i < segments.size(); ++i) {
			int qty = sbegin - segments.at(i)->end();
            if (qty < dist && qty > 0 && segments[i]->slope > -1) {
                dist = qty;
                other = i;
				otherSlope = static_cast<double>(segments[i]->slope);
            }
        }

        //if at left edge
        if (other == index && (sbegin == 0) ) {
            segments[index]->xpeak = x[sbegin];    
            segments[index]->phipeak = phiIn[sbegin];
            goto setMin; 
        }
        if (other == index) {
            segments[index]->xpeak = 0.5 * (x[sbegin] + x[send]);
            segments[index]->phipeak = 0.5 * (phiIn[sbegin] + phiIn[send]);
			other = -1;
            otherSlope = -slope;
			goto setMin;
        }
	
        assert(other != index);
        assert(otherSlope != slope);
	}

	//get slopes & intercepts: phi = a*x + b
	a1 = slope;
	a2 = otherSlope;
	b1 = phiIn[sbegin] - slope * x[sbegin]; 
	b2 = phiIn[segments[other]->begin()] - segments[other]->slope * x[segments[other]->begin()];;
	assert(a1 - a2 != 0.0);	

	//intersect
	xint = (b2 - b1) / (a1 - a2);
	phiint = (a1*b2 - b1*a2) / (a1 - a2);

	//save peaks
	segments[index]->xpeak = xint;	
	segments[index]->phipeak = phiint;	

	setMin:
	//set minimum	
	//find neighboring segment
	other = index;
	dist = Nelt;
	otherSlope = 0.0;
	if (slope == 1) {
		for (unsigned i = 0; i < segments.size(); ++i) {
			int qty = sbegin - segments.at(i)->end();
			if (qty < dist && qty > 0 && segments[i]->slope < 1) {
				dist = qty;
				other = i;
				otherSlope = static_cast<double>(segments[i]->slope);
			}
		}

		//if at left edge
		if (other == index && (sbegin == 0) ) {
			segments[index]->xmin = x[sbegin];	
			segments[index]->phimin = phiIn[sbegin];
			if (segments[index]->xpeak < x[0]) {
				segments[index]->phipeak -= segments[index]->xpeak;
				segments[index]->xpeak = 0.0;
			}
			goto end;
		}

        if (other == index) {
            segments[index]->xmin = 0.5 * (x[sbegin] + x[send]);
            segments[index]->phimin = 0.5 * (phiIn[sbegin] + phiIn[send]);
            otherSlope = -slope;
			other = -1;
			goto end;
        }

		assert(other != index);
		assert(otherSlope != slope);
	} else {
        for (unsigned i = 0; i < segments.size(); ++i) {
			int qty = segments.at(i)->begin() - send;
            if (qty < dist && qty > 0 && segments[i]->slope > -1) {
                dist = qty;
                other = i;
				otherSlope = static_cast<double>(segments[i]->slope);
            }
        }

        //if at right edge
        if (other == index && (send == Nnod - 1) ) {
            segments[index]->xmin = x[send];    
            segments[index]->phimin = phiIn[send];
            if (segments[index]->xpeak > x[Nelt]) {
                segments[index]->phipeak += segments[index]->xpeak - x[Nelt];
                segments[index]->xpeak = x[Nelt];
            }
            goto end; 
        }

        if (other == index) {
            segments[index]->xmin = 0.5 * (x[sbegin] + x[send]);
            segments[index]->phimin = 0.5 * (phiIn[sbegin] + phiIn[send]);
            otherSlope = -slope;
			other = -1;
			goto end;
        }
	
        assert(other != index);
        assert(otherSlope != slope);
	}

	//get slopes & intercepts: phi = a*x + b
	a1 = slope;
	a2 = otherSlope;
	b1 = phiIn[sbegin] - slope * x[sbegin]; 
	b2 = phiIn[segments[other]->begin()] - segments[other]->slope * x[segments[other]->begin()];;
	assert(a1 - a2 != 0.0);

	//intersect
	xint = (b2 - b1) / (a1 - a2);
	phiint = (a1*b2 - b1*a2) / (a1 - a2);

	//save peaks
	segments[index]->xmin = xint;	
	segments[index]->phimin = phiint;	

	end:
	
	//correct if needed
	if (segments[index]->xpeak < 0) {
		double qty = segments[index]->xpeak;
		segments[index]->xpeak = 0;
		segments[index]->phipeak -= slope * qty;
	}
    if (segments[index]->xpeak > L) {
        double qty = segments[index]->xpeak - L;
        segments[index]->xpeak = L;
        segments[index]->phipeak -= slope * qty;
    }
    if (segments[index]->xmin < 0) {
        double qty = segments[index]->xmin;
        segments[index]->xmin = 0;
        segments[index]->phimin -= slope * qty;
    }
    if (segments[index]->xmin > L) {
        double qty = segments[index]->xmin - L;
        segments[index]->xmin = 0;
        segments[index]->phimin -= slope * qty;
    }

    assert(segments[index]->xpeak <= L);
    assert(segments[index]->xpeak >= 0.0);
    assert(segments[index]->xmin <= L);
    assert(segments[index]->xmin >= 0.0);

	double qty = (segments[index]->phipeak-segments[index]->phimin)/(segments[index]->xpeak-segments[index]->xmin);
	assert( segments[index]->phimin <= segments[index]->phipeak);

	return;
}

unsigned PotentialAvenger::calculateYbar(const vector<double>& pg, const vector<double>& wg, double& Ycavg, double& YbarmYc, double& residu_Y, double& tangent_Y, double& phimin, double& phimax, double& phiminY, double& phimaxY, unsigned& nbiter, const unsigned sbegin, const unsigned send, Segment* segment) {
    residu_Y = 0; 
    tangent_Y = 0.0; 
    unsigned loop_residu = 0;
    unsigned loop_tangent = 0;

	double segLength = 0;
	Ycavg = 0.0;

    phimin = phiNL[sbegin];
    unsigned iphimin = sbegin;
    for (unsigned j = 0; j <= Nelt; ++j) {
		if (x[j+1] < min(segment->xpeak,segment->xmin)) continue;
		if (x[j] > max(segment->xpeak,segment->xmin)) continue;

		if (inTLSnode[j]+inTLSnode[j+1] == 0) continue;
        assert(pg.size() == wg.size());

        for (unsigned k = 0; k < pg.size(); ++k) {
            double philoc = 0.0;
			double delta = 0.0;
			double weight = 1.0;

			double xpeak = segment->xpeak;
			double xmin = segment->xmin;
            philoc = pg[k]*phiNL[j] + (1-pg[k]) * phiNL[j+1];
			double dist;
			if (segment->slope == 1) {
				assert(xpeak >= xmin);
				assert(xpeak >= xmin - EPS);
				dist = min( min(xpeak - x[j], x[j+1]-xmin), xpeak-xmin);
			} else if (segment->slope == -1) {
				assert(xmin >= xpeak);
				assert(xmin >= xpeak - EPS);
				dist = min( min(x[j+1] - xpeak, xmin - x[j]), xmin - xpeak); 
			} else {
				assert(1 == 0);
			}
			weight *= max(0.0,min(dist,h));
        
			if  (phiNL[j] > 0 && phiNL[j+1] <= 0) {
                delta = h * fabs(phiNL[j]) / (fabs(phiNL[j])+fabs(phiNL[j+1])); //phi>0 portion
                weight = min(weight, delta);//x[j] + delta - max(x[j], xpeak);
				weight = max(0.0,min(weight,h));
                philoc = pg[k] * weight;
                residu_Y += weight * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dp(philoc);
                tangent_Y += weight * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dpp(philoc)
							 -weight * wg[k] * d2H(j,dm.dval(philoc)) * pow(dm.dp(philoc),2);
        		phimin = 0.0;
        		iphimin = j;

				if (k == 0) {
            		if (delta < h || j+1==Nnod) tangent_Y += (0.5 * E * e[j] * e[j] - dH(j,0.0) - Ycv[j])* dm.dp(0.) ;
            		else tangent_Y += (0.5 * E * e[j+1] * e[j+1] - dH(j,0.0) - Ycv[j])  * dm.dp(0.);
				}
            	loop_tangent++;
            } else if  (phiNL[j] <= 0 && phiNL[j+1] > 0) {

           		delta = h * fabs(phiNL[j+1]) / (fabs(phiNL[j])+fabs(phiNL[j+1])); //phi>0 portion
                weight = min(weight,delta);//min(xpeak, x[j+1]) - x[j+1] + delta;
				weight = max(0.0,min(weight,h));
               	philoc = pg[k] * weight;
                residu_Y += weight * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dp(philoc);
                tangent_Y += weight * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dpp(philoc)
						   - delta * wg[k] * d2H(j,dm.dval(philoc)) * pow(dm.dp(philoc),2);
       			phimin = 0.0;
       			iphimin = j;

				if (k == 0) {
               		if (delta < h || j == 0) tangent_Y += (0.5 * E * e[j] * e[j] - dH(j,0.0) - Ycv[j])* dm.dp(0.);  
              		else tangent_Y += (0.5 * E * e[j-1] * e[j-1] - dH(j,0.0) - Ycv[j])  * dm.dp(0.);
				}
            	loop_tangent++;
			} else {
				philoc = pg[k] * phiNL[j] + (1.0 - pg[k]) * phiNL[j+1];
               	residu_Y += weight * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dp(philoc);
               	tangent_Y += weight * wg[k] * (0.5 * E * e[j] * e[j] - dH(j,dm.dval(philoc)) - Ycv[j]) * dm.dpp(philoc)
			        			 - weight * wg[k] * d2H(j,dm.dval(philoc)) * pow(dm.dp(philoc),2);
           	}
           	loop_residu++;
			Ycavg += Ycv[j] * weight/h;
			segLength += weight/h;
        
        }
     }//end loop-nodes
	Ycavg /= static_cast<double>(pg.size());
	segLength /= static_cast<double>(pg.size());

    phimax = phiNL[sbegin];
    unsigned iphimax = sbegin;
    for (unsigned k = sbegin; k <= send; ++k) {
       if (phiNL[k] > phimax) {
            phimax = phiNL[k];
            iphimax = k;
        }
        if (phiNL[k] < phimin) {
            phimin = phiNL[k];
            iphimin = k;
        }
    }
    phimax = max(phimax,segment->phipeak);// + dphi;//max(0.0,dphi);
    phimin = min(phimin,segment->phimin);
    if (dm.dval(phimin) == 1 && nbiter == 1) return 0;
    if (phimin == phimax) return 0;

    phimaxY = 0.0;
    if (iphimax == Nnod-1) phimaxY = 0.5*E*pow(e[Nelt-1],2) - dH(iphimax, dm.dval(phimax)); //1/2*s(i,Nelt)*e(i,Nelt);
    else {
        phimaxY = 0.5*E*pow(e[iphimax],2);// 1/2*s(i,iphimax)*e(i,iphimax);
        for (unsigned k = 0; k < d_quad_wt[iphimax].size(); ++k) {
	        phimaxY -= d_quad_wt[iphimax][k] * dH(iphimax,d_quad[iphimax][k]);
        }
    }

    phiminY = 0.0;
    if (iphimin == Nnod-1) phiminY = 0.5*E*pow(e[Nelt-1],2) - dH(iphimin, dm.dval(phimin)); //1/2*s(i,Nelt)*e(i,Nelt);
    else {
		phiminY = 0.5*E*pow(e[iphimin],2);// 1/2*s(i,iphimax)*e(i,iphimax);
        for (unsigned k = 0; k < d_quad_wt[iphimin].size(); ++k) {
            phiminY -= d_quad_wt[iphimin][k] * dH(iphimin,d_quad[iphimin][k]);
        }
    }

                    
    YbarmYc = residu_Y/(dm.dval(phimax)-dm.dval(phimin));
	if (residu_Y == 0.0) YbarmYc = 0.0;
//cout << "Ybar:   residuY = " << residu_Y << "   tangentY = " << tangent_Y << endl;
//    cout << "segment " <<  " begin = " << sbegin << "  end = " << send << "  |  YbarmYc = " << YbarmYc << "    Yc = " << Yc << "  -> ratio= " << YbarmYc/Yc << endl;
/*    if (YbarmYc/Yc > 0.001) {
    //cout << " YbarmYc = " << YbarmYc << "    Yc = " << Yc << "  -> ratio= " << YbarmYc/Yc << endl;
    cout << "residuY = " << residu_Y << endl;
    cout << " phimax = " << phimax << "   ( " << dm.dval(phimax) << endl;
    cout << " phimin = " << phimin << "   ( " << dm.dval(phimin) << endl;
    cout << " diff-d = " << dm.dval(phimax)-dm.dval(phimin) << endl;
    }				
*/
    segment->YbarmYc = YbarmYc;
if (segLength <= 0.0) {
//	cout << " begin-end = " << segment->begin() << "  - " << segment->end() << endl;
//    cout << "   YbarmYc = " << YbarmYc << "   saved as " << segment->YbarmYc << endl;
    cout << endl;
    cout << " residuY = " << residu_Y << "    Yc = " << Yc << endl;
    cout << " YbarmYc = " << YbarmYc << endl;
}
	assert(segLength <= fabs(segment->xpeak - segment->xmin)/h + 1.0e-6);
	assert(segLength > 0.0);
	Ycavg /= segLength;

    for (unsigned j = max(0,static_cast<int>(sbegin)-1); j <= min(send+1,Nelt-1); ++j) {
        if (j < 0) continue;
        if (inTLSnode[j]+inTLSnode[j+1] == 0) continue;
		Ybar[j] = YbarmYc/Ycavg+1.0;
	}

	return 1;
}

void PotentialAvenger::nucleate(const double t, const std::vector<double>& xnuc, const std::vector<double>& phinuc, std::vector<Segment*>& newSegment, const std::string& elemOrNodal){
    //t      -time
    //x      -mesh
    //phi    -level-set calculated at this time-step
    //xnuc   -location(s) of localizations to be nucleated
    //phinuc -amount of the level-set to be set at nucleated localizations

    assert(xnuc.size() == phinuc.size());
    assert(xnuc.size() > 0);

    for (unsigned j = 0; j < xnuc.size(); ++j) {
        int loc = -1;
        double delta = 0;
        nucleated++;
        for (unsigned i = 0; i < x.size()-1; ++i) {
            if ((xnuc[j] >= x[i]) && (xnuc[j] < x[i+1])) {
                loc = i;
                delta = (xnuc[j] - x[i])/h;
                break;
            }

        }
        if (loc == -1 && xnuc[j] == 1.0) {
			loc = Nnod - 1;
			delta = 0.0;
		}

        assert(loc != -1);
        double proposed1 = phinuc[j] - delta*h;
        double proposed2 = phinuc[j] - (1-delta)*h;
        if (elemOrNodal.compare("nodal") == 0) {
			assert(delta == 0.0);

            inTLSnode[loc] = 1;
            inTLS[loc] = 1;
            if (loc > 0) inTLS[loc-1] = 1;
            if (loc > 0) inTLSnode[loc-1] = 1;
            inTLSnode[loc+1] = 1;
        
            if (loc < static_cast<int>(Nnod)-1) inTLSnode[loc+1] = 1;
            double gradient = 0;
            if (loc >= 1) {
                if (d_1[loc] > d_1[loc-1]) gradient = 1.0; else gradient = -1.0;
                if (d_1[loc] < d_1[loc-1]) gradient = -1.0;
            } else gradient = -1.0;
			if (loc == static_cast<int>(Nnod)-1) gradient = 1.0;
            assert(gradient != 0);
	        if (gradient == 1.0) {
				assert(loc >= 1);
				double phicrit = phiNL[loc];
				if (loc > 0) phicrit = max(phicrit,phiL[loc-1]); 
				if (loc < static_cast<int>(Nnod)) phicrit = max(phicrit,phiL[loc]); 
				if (loc > 0) phiNL[loc-1] = max(max(phicrit-h,phiL[loc-1]),phiNL[loc-1]);
				phiNL[loc] = phicrit;
				if (loc+1 < static_cast<int>(Nnod)) phiNL[loc+1] = phicrit;
				if (loc+1 < static_cast<int>(Nelt)) phiNL[loc+1] = max(phicrit,phiL[loc+1]);
				if (loc+1 < static_cast<int>(Nnod)) delta = 0.5 * (h + phiNL[loc+1] - phiNL[loc]);
				else delta = 0.0;	
			assert(delta >= 0.0); assert(delta <= h);
    	    } else {
                assert(loc <= static_cast<int>(Nnod)-1);
                double phicrit = max(phiL[loc],phiNL[loc]);
				if (loc > 0) phicrit = max(phicrit, phiL[loc-1]);
                //phiNL[loc+1] = max(phicrit-h,phiNL[loc+1]); //max(max(phicrit-h,phiL[loc+1]),phiNL[loc+1]);
                if (loc + 1 < static_cast<int>(Nnod) ) phiNL[loc+1] = max(phicrit-h,phiNL[loc+1]);
                if (loc + 1 < static_cast<int>(Nelt) ) phiNL[loc+1] = max(phiL[loc+1],phiNL[loc+1]);
                phiNL[loc] = phicrit;
                if (loc-1 >= 0) phiNL[loc-1] = max(phicrit,phiL[loc-1]);
				if (loc-1 >= 0) delta = 0.5 * (-h + phiNL[loc] - phiNL[loc-1]);
				else delta = 0.0;
			assert(delta <= 0.0); assert(delta >= -h);
        	}
             //create two new segments
             if (xnuc[j] > x[0]) {
                 Segment* seg1 = new Segment(xnuc[j]+delta,phiNL[loc]+fabs(delta),-1);
                 seg1->indices.push_back(loc);
				 seg1->xpeak = xnuc[j] + delta;
				 seg1->phipeak = phiNL[loc]+fabs(delta);
                 newSegment.push_back(seg1);
             }
             if (xnuc[j] < x.back()) {
                 Segment* seg2 = new Segment(xnuc[j]+delta,phiNL[loc]+fabs(delta),1);
                 seg2->indices.push_back(loc+1);
				 seg2->xpeak = xnuc[j] + delta;
				 seg2->phipeak = phiNL[loc]+fabs(delta);
                 newSegment.push_back(seg2);
             }

        } else {
			//elem nucleation
			inTLSnode[loc] = 1;
			inTLSnode[loc+1] = 1;
			inTLS[loc] = 1;
			proposed1 = max(proposed1, dm.phi(d_1[loc]));	
			proposed2 = max(proposed2, dm.phi(d_1[loc]));
			if (loc > 0) proposed1 = max(proposed1, dm.phi(d_1[loc-1]));	
			if (loc > 0) proposed2 = max(proposed2, dm.phi(d_1[loc-1]));	
			if (loc < (int)Nnod-1) proposed1 = max(proposed1, dm.phi(d_1[loc+1]));	
			if (loc < (int)Nnod-1) proposed2 = max(proposed2, dm.phi(d_1[loc+1]));	
            phiNL[loc] = max(phiNL[loc], proposed1);
            phiNL[loc+1] = max(phiNL[loc+1], proposed2);

double zero = 0.0;
            //create two new segments
            if (xnuc[j] > x[0]) {
                 Segment* seg1 = new Segment(xnuc[j]-delta*h*zero,phinuc[j]-delta*h*zero,-1);
                 seg1->indices.push_back(loc);
                 newSegment.push_back(seg1);
             }
             if (xnuc[j] < x.back()) {
                 Segment* seg2 = new Segment(xnuc[j]+(1-delta)*h*zero,phinuc[j]-(1-delta)*h*zero,1);
                 seg2->indices.push_back(loc+1);
                 newSegment.push_back(seg2);
             }

        }
        printf("crack nucleated, t = %f, x = %f \n",t,xnuc[j]);
        
        //now that there has been nucleation, get rid of zero-slope segments
        vector<unsigned> delList;
        for (unsigned i = 0; i < newSegment.size(); ++i) {
            if (newSegment[i]->slope == 0 || newSegment[i]->phipeak == -1) delList.push_back(i);
        }
        while (delList.size() > 0) {
            unsigned index = delList.back(); 
            delete newSegment.at(index);
            newSegment.erase(newSegment.begin() + index);
            delList.pop_back();
        }

    }
};

vector<double> PotentialAvenger::findFragments(DamageModel& dm, const std::vector<double>& phiLocal, const std::vector<double>& phiNonLocal, unsigned& nfrags, const vector<Segment*>& segments) {
    
    //calculate total number of fragments (removing symmetry simplification)
    vector<double> fragLength = fragmentLength(segments); 
    nfrags = fragLength.size();
    fragmentStats(fragLength);   

    return fragLength; 
};


vector<double> PotentialAvenger::fragmentLength(const vector<Segment*>& segments) { 
	
    vector<double> fragLength;
    double powderLength = 0.0;

	//assign indices to fragments
    int begin = -1;
    int firstbegin = -1;
    for (unsigned j = 0; j < Nelt; ++j) {
		//don't add damage if whole element is damaged, either local or nonlocal
        if ( (phiL[j] >= lc) || (phiNL[j] >= lc && phiNL[j+1] >= lc && fabs(phiNL[j]-phiNL[j+1]) == h) ) {
			begin = -1;
			powderLength += h;
            continue;
		}

	    double solidLength = h;	
		
		//element partially failing (simple)
		if ( (phiNL[j] >= lc || phiNL[j+1] >= lc) && ( fabs(phiNL[j]-phiNL[j+1]) == h) ) {
			if (phiNL[j] < phiNL[j+1]) {
				double delta = lc - phiNL[j];
				assert(delta >= 0); assert(delta <= h);
			    fragLength.back() += delta;	
			    powderLength += (h - delta);
			    
			    solidLength = 0.0;
			    begin = -1;
			} else if (phiNL[j] > phiNL[j+1]) {
                double delta = phiNL[j] - lc;
                assert(delta >= 0); assert(delta <= h);
                powderLength += delta;
                
                fragLength.push_back(0.0); //end old fragment, find length for new one
                solidLength = h - delta;
                begin = j;
			} else {
				assert(1==0);
			}
		}

		//element partially failing (hat)
		if ( fabs(phiNL[j]-phiNL[j+1]) < h + EPS && (0.5 * (phiNL[j] + phiNL[j+1]) >= lc - 0.5 * h) ) {
			bool hasPeak = false;
			bool hasMin = false;
			//check for peaks -> hasPeak (false = antipeak, true = peak)
			for (unsigned l = 0; l < segments.size(); ++l) {
				if ( (segments[l]->xpeak >= x[j]) && (segments[l]->xpeak <= x[j+1]) ) hasPeak = true;
				if ( (segments[l]->xmin >= x[j]) && (segments[l]->xmin <= x[j+1]) ) hasMin = true;
			}
			if (hasPeak && hasMin) {
				//could be slope = -1, 1, -1 or 1, -1 , 1

				//TODO
				solidLength = h;

			
			}

            if (hasPeak && !hasMin) {
				//peak
				solidLength = 0.0;
				double delta = 0.5 * (phiNL[j+1] - phiNL[j] + h);
				assert(delta >= -EPS); assert(delta <= h+EPS);
				if (phiNL[j] + delta < lc) {
					solidLength = h;	
					continue;
				}
				assert(phiNL[j] + delta >= lc);
				//check for & deal with intersection on first slope
				double s  = lc - phiNL[j];
                assert(s <= delta);
				if (s > 0) {
					fragLength.back() += s;
					powderLength += (delta - s);
				} else {
					powderLength += delta;
				}
				begin = -1;

				//check for & deal with intersection on second slope
                 s  = phiNL[j] + delta - lc;
                assert(s >= 0);
                if (s < (h-delta)) {
                    powderLength += s;
			        fragLength.push_back(0.0);
					begin = j;
					solidLength = (h-delta)-s;
                } else {
                    powderLength += h-delta;
                }


			}
			if (hasMin && !hasPeak) {
				//anti-peak
				double delta = 0.5 * (phiNL[j] - phiNL[j+1] + h);
        	    if (phiNL[j] < lc && phiNL[j+1] < lc) {
					solidLength = h;
					continue;
				}
				if (fabs(delta) < 2*EPS) delta = 0.0;
				if (fabs(delta-h) < 2*EPS) delta = h;
				assert(delta >= 0); assert(delta <= h);
				solidLength = 0.0;
                if (phiNL[j] - delta <= lc) {
        	        assert(phiNL[j] >= lc || phiNL[j+1] >= lc);
    	            //check for & deal with intersection on first slope
	                double s  = phiNL[j] - lc;
                	assert(s <= delta);
            	    if (s > 0) {
        	            powderLength += s;
						begin = -1;
	                    solidLength = (delta - s);
                	} else {
            	        fragLength.back() += delta;
        	        }
                
    	            //check for & deal with intersection on second slope
	                s  = lc - phiNL[j] + delta;
                	assert(s >= 0);
            	    if (s < (h-delta)) {
						solidLength += s;
						fragLength.push_back(solidLength);
						solidLength = 0.0;
						powderLength += (h-delta) - s;
						begin = -1;
            	    } else {
        	            solidLength += (h-delta);
						begin = j;
	                }
				} else {
					//whole thing failed
					powderLength += h;
					begin = -1;		
				}
			}//end peak/antipeak
		} //end hat

		if (firstbegin == -1) firstbegin = j;
		if (begin == -1) {
			begin = j;
			fragLength.push_back(0.0);
		}
		assert(solidLength <= h); assert(solidLength >= 0.0);
		fragLength.back() += solidLength;
	
    }

	//copy for negative side
    unsigned numFL = fragLength.size();
	//double length of first fragment if it was intact (firstbegin)
    if (firstbegin == 0 && numFL > 0) fragLength[0] *= 2.0;
	else fragLength.push_back(fragLength[0]);
    for (unsigned j = 1; j < numFL; ++j) fragLength.push_back(fragLength[j]);
	powderLength *= 2;

	assert( (fragLength.size() == numFL*2 && firstbegin != 0) || (fragLength.size() == numFL*2-1 && firstbegin == 0) );

	//length check
    double sumfrag = 0.0;
	for (unsigned j = 0; j < fragLength.size(); ++j) 	sumfrag += fragLength[j];
	assert(fabs(sumfrag + powderLength - L * 2.0) < EPS*Nelt );

	return fragLength;
};

unsigned PotentialAvenger::checkFailureCriteria(const unsigned ts, std::vector<double>& criterion, const std::string elemOrNodal, const std::vector<double>& qty, const bool absOrAsIs, const bool phiPos, const double failvalue, std::vector<Segment*>& newSegment, vector<unsigned>& nbiter, const vector<double>& pg, const vector<double>& wg){

    //x              -mesh
    //phi            -level-set calculated at this time-step
    //criterion      -criterion to compare against for failure
    //elemOrNodal    -either 'elem' or 'nodal' - is criterion elemental or nodal
    //qty            -the quantity to be compared to the criterion -e.g. s,Y
    //absOrAsIs      -whether to compare (0) qty or (1) abs(qty) to criterion
    //phiPos         -whether(1) or not(0) failure cannot occur depending on if phi>0
    //failvalue      -what to call phi at localization zone if created - e.g. h
    //failure if qty > criterion
	//return: xlist - number of nucleations performed

    vector<double> margin;
    vector<unsigned> index;

    assert(elemOrNodal.compare("elem") == 0 || elemOrNodal.compare("nodal") == 0);
    assert(absOrAsIs == false || absOrAsIs == true);
    if (elemOrNodal.compare("nodal") == 0) {
        assert(x.size() == qty.size());
    } else {
        assert(x.size() == qty.size()+1);
    }
    assert((qty.size() == criterion.size()) || (criterion.size() == 1));

    if (criterion.size() == 1) {
        double val = criterion[0];
        criterion.assign(qty.size(),val);
    }
    vector<double> xlist;
    for (unsigned i = 0; i < qty.size(); ++i) {
        if (phiPos == 0) {//can't fail if phi>0
            if (elemOrNodal.compare("nodal") == 0) {
                if (phiNL[i] > 0) continue;
            } else {
                if (phiNL[i]>0 || phiNL[i+1]>0) continue;
            }
        }
        double qtyc = qty[i];
		//can't fail if already nucleated
        double minOpen = max(h,minOpenDist);
        for (unsigned j = 0; j < newSegment.size(); ++j) {
            if (nucleated == 0) continue;	// the null level-set can't be an impediment to nucleation		
            
			if (elemOrNodal.compare("nodal") == 0) {
                if (fabs(newSegment[j]->xpeak-x[i]) < minOpen) goto nextLoop;
            } else {
                double xavg = 0.5*(x[i] + x[i+1]);
                if (fabs(newSegment[j]->xpeak - xavg) < minOpen) goto nextLoop;
            }
		}

		//compare against arelady accepted nucleation sites - xlist
        for (unsigned j = 0; j < xlist.size(); ++j) {
            if (elemOrNodal.compare("nodal") == 0) {
                if (fabs(xlist[j]-x[i]) < minOpen) goto nextLoop;
            } else {
                double xavg = 0.5*(x[i] + x[i+1]);
                if (fabs(xlist[j] - xavg) < minOpen) goto nextLoop;
            }
        }
		
		if (absOrAsIs) {
            qtyc = fabs(qtyc);
        }

        if (qtyc > criterion[i]) {
            if (elemOrNodal.compare("nodal") == 0) {
                xlist.push_back(x[i]);
            } else {
                //assume middle of element
                xlist.push_back(0.5*(x[i]+x[i+1]));
            }
            margin.push_back(qtyc/criterion[i]);
            index.push_back(i);
        }
        nextLoop: //jump to here if can't nucleate
        qtyc = 0;
    }


    //limited to one nucleation per timestep - IF OneAtATime=true
    if (oneAtATime) {
        double marmax = 0;
        unsigned index = 0;
        if (xlist.size() > 0){
            for (unsigned i = 0; i < xlist.size(); ++i) {
                if (margin[i] > marmax) {
                    marmax = margin[i];
                    index = i;
                }
            }
            double temp1 = xlist[index];
            xlist.clear(); xlist.push_back(temp1);
            margin.clear(); margin.push_back(marmax);
        }
        assert(xlist.size() <= 1);
    }
    
    if (elemOrNodal.compare("elem") == 0) {
	    for (unsigned i = 0; i < xlist.size(); ++i) {
    	    criterion[index[i]] *= (1-alfa);  //modify Yc at the location of nucleation by a factor alpha : TODO is this good???
	    }
    }

    //nucleate list
    if (xlist.size() > 0) {
        vector<double> failvalueList = vector<double>(xlist.size(),failvalue);
        nucleate(t[ts],xlist,failvalueList, newSegment, elemOrNodal);
    }
	return xlist.size();
};


void PotentialAvenger::analyzeDamage(vector<double>& phiV, const double h, vector<Segment*>& newSegment) {
    //produce:
    //new phi based on distances - maxima

    //if all negative one, skip
    unsigned sum = 0;
    for (unsigned i = 0; i < phiV.size(); ++i) {
        if (phiV[i] > -1) sum++;
    }
    if (sum == 0) return;
    if (nucleated == 0) return;

    vector<double> list_max;
    vector<double> value_max;
    vector<double> slope;
    vector<double> YbarmYc;
    sort(newSegment.begin(), newSegment.end());
   
    assert(x.size() >= 1);

    //simply use pre-defined segments
    if (newSegment.size() == 0) return;
    for (unsigned i = 0; i < newSegment.size(); ++i) {
        //assert(newSegment[i].size() > 0);
        list_max.push_back(newSegment[i]->xpeak);
        value_max.push_back(newSegment[i]->phipeak);
        slope.push_back(newSegment[i]->slope);
        YbarmYc.push_back(newSegment[i]->YbarmYc);
        newSegment[i]->indices.clear();
    }

    //delete segments, make new ones
    unsigned nSegs = newSegment.size();
	for (unsigned i = 0; i < nSegs; ++i) delete newSegment[i];
    newSegment.clear();
    newSegment.resize(nSegs*2);
	for (unsigned i = 0; i < nSegs*2; ++i) newSegment[i] = new Segment(); 
	for (unsigned i = 0; i < nSegs; ++i) {
		newSegment[2*i]->YbarmYc = YbarmYc[i];
		newSegment[2*i]->slope = 1;
		newSegment[2*i+1]->YbarmYc = YbarmYc[i];
		newSegment[2*i+1]->slope = -1;
	}
    vector<unsigned> removeList;

    //re-define segments.indices and phi
    vector<double> phinew = vector<double>(phiV.size(),-1);
    for (unsigned i = 0; i < phiV.size(); ++i) {
        
        int segphimin = -1;
        double min = 9999999999;
        for (unsigned k = 0; k < value_max.size(); ++k) {
            if (value_max.size() > 1 && value_max[k] == 0.0) continue;
            double qty = -value_max[k] + fabs(x[i] - list_max[k]);
            if (qty < min) {
                min = qty;
                segphimin = k;
            }
        }
        assert(segphimin > -1);

        phinew[i] = -min;
       	if (x[i] < list_max[segphimin])     newSegment[2*segphimin]->indices.push_back(i);
   	    if (x[i] > list_max[segphimin])     newSegment[2*segphimin+1]->indices.push_back(i);
        if (x[i] == list_max[segphimin]) {
			if (slope[segphimin] > 0) newSegment[2*segphimin]->indices.push_back(i);
			else newSegment[2*segphimin+1]->indices.push_back(i);
		}
        //assert(newSegment[segphimin].slope != 0);
        phinew[i] = max(phinew[i],phiV[i]);
    }

    //delete empty segments
    vector<unsigned> delList;
    for (unsigned i = 0; i < newSegment.size(); ++i) {
        if (newSegment[i]->size() == 0) {                            //delete empty
            delList.push_back(i);        
            continue;
        }

		assert(newSegment[i]->slope != 0);
    }
    while (delList.size() > 0) {
        unsigned index = delList.back(); 
        delete newSegment.at(index);
        newSegment.erase(newSegment.begin() + index);
        delList.pop_back();
    }

	//make sure segments don't overlap
	for (unsigned i = 0; i < newSegment.size(); ++i) {
		for (unsigned j = i + 1; j < newSegment.size(); ++j) {
			vector<int> endpoints;
			endpoints.push_back(newSegment[i]->begin());
			endpoints.push_back(newSegment[i]->end());
			endpoints.push_back(newSegment[j]->begin());
			endpoints.push_back(newSegment[j]->end());
			sort(endpoints.begin(),endpoints.end());
			int L1 = abs(static_cast<int>(newSegment[i]->begin()) - static_cast<int>(newSegment[i]->end()));	
			int L2 = abs(static_cast<int>(newSegment[j]->begin()) - static_cast<int>(newSegment[j]->end()));
			int dist = endpoints.back() - endpoints.front();
			assert(dist > L1 + L2);	
		}

	}	

    unsigned tot_indices = 0;
    for (unsigned i = 0; i < newSegment.size(); ++i) {
        setPeak(phinew,newSegment,i);
        tot_indices += newSegment[i]->size();
        if (newSegment[i]->phipeak> 0 ) assert(newSegment[i]->indices.size() <= x.size());
    }

    assert(tot_indices + removeList.size() == x.size());

    //return phinew as phi
    for (unsigned i = 0; i < phiV.size(); ++i) {
        phiV[i] = phinew[i];
    }

    if (nucleated == 0) assert(nSegs == newSegment.size());
    
    //ensure that segment indices are contiguous
/*
    bool flag = true;
    while (flag == true) {
    flag = false;
        for (unsigned j = 0; j < newSegment.size(); ++j) {
            if (newSegment[j]->indices.size() <= 1) continue;
            // if not contiguous, split
            if (newSegment[j]->end() != newSegment[j]->begin() + newSegment[j]->indices.size() - 1) {
				flag = true;
                int loca = -1;
                for (unsigned k = 1; k < newSegment[j]->indices.size(); ++k) {
                    if (newSegment[j]->indices[k] != newSegment[j]->indices[k-1] + 1) {
						loca = k;
						break;
					}
                }
				assert(loca > -1);
				//move loca & later to new segment, erase from original
				//Segment seg = Segment();
				//newSegment.push_back(seg);
				newSegment.push_back(new Segment());
				for (unsigned k = loca; k < newSegment[j]->indices.size(); ++k) newSegment.back()->indices.push_back(newSegment[j]->indices[k]);
				setPeak(x,phinew,newSegment,newSegment.size()-1);
				newSegment.back()->slope = newSegment[j]->slope;
				newSegment[j]->indices.resize(loca);
            }
            assert(newSegment[j]->end() == newSegment[j]->begin() + newSegment[j]->indices.size() - 1);
        }
    }

*/
};  

void PotentialAvenger::printRunInfo() {
    cout << endl;
    cout << "Run Info:" << endl;
    cout << "Strain rate = " << strain_rate << endl;
    cout << "# Elements = " << Nelt << endl;
    cout << "End Time (s) = " << end_t << endl;
    cout << "Time-step refinement ratio = " << ts_refine << endl;
    cout << "Damage gradient length (lc) = " << lc << endl;
    cout << "Beginning run... " << endl;
    cout << endl;

};

void PotentialAvenger::plotEnergies () {
    // Gnuplot file for energies
    FILE * pFileW;
    std::string stressFile = _path+"/gnuplot/plotEnrg.plt";		//../results
    pFileW = fopen( stressFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Global energies\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"energy (J)\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgSpr.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'Wspr' w l\n" );
    fprintf( pFileW, "set output './pngFiles/enrgDissip.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:3 ti 'Wdissip' w l, \\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:8 ti 'local' w l, \\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:9 ti 'non-local' w l \n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgExt.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:4 ti 'Wext' w l\n\n" );
    fprintf( pFileW, "set output './pngFiles/enrgKin.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:5 ti 'Wkin' w l\n\n" );
    fprintf( pFileW, "set ylabel \"Energy Balance Check\"\n" );
    fprintf( pFileW, "set output './pngFiles/enrgBalance.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:(abs($7)) ti 'Wsum' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:6 ti '0.01 * Wmax' w l\n\n" );
    fprintf( pFileW, "set ylabel \"J/s\"\n" );

    fprintf( pFileW, "set output './pngFiles/enrgAll.svg'\n");
    fprintf( pFileW, "plot './datFiles/energies.dat' usi 1:2 ti 'Wspr' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:3 ti 'Wdis' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:4 ti 'Wext' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:5 ti 'Wkin' w l ,\\\n");
    fprintf( pFileW, "     './datFiles/energies.dat' usi 1:(abs($2+$3+$5)) ti 'Wsum' w l\n\n");

	
    fprintf( pFileW, "set output './pngFiles/phidotC.svg'\n");
    fprintf( pFileW, "set ylabel \"damage front speed phidot/c\"\n" );
    fprintf( pFileW, "plot for [i=10:100] './datFiles/energies.dat' usi 1:i title \"Segment \".(i-9) w l \n");

    fclose( pFileW );

    // Prepare Gnuplot data file
    _EnrgFile = _path+"/datFiles/energies.dat";		//../results
    FILE * pFile;
    pFile = fopen( _EnrgFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Total energies for the system\n" );
    fprintf( pFile, "#       time        Wspr        Wdis        Wext");
    fprintf( pFile, "        Wkin   0.01*Wmax        Wsum     WdisLoc     WdisTLS" );
    for (unsigned i = 1; i <= 100; ++i) fprintf( pFile, "   Segment %u", i); 
    fprintf( pFile, "\n");
    fclose( pFile );
}

void PotentialAvenger::plotFrags (){
    // Gnuplot file for fragmentation
    FILE * pFileW;
    std::string fragFile = _path+"/gnuplot/plotFragInfo.plt";		//../results
    pFileW = fopen( fragFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "# Fragmentation Information\n" );
    fprintf( pFileW, "set xlabel \"time (s)\"\n" );
    fprintf( pFileW, "set ylabel \"Number of Fragments\"\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
    fprintf( pFileW, "set output './pngFiles/numFrag.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraginfo.dat' usi 1:3 ti 'Sum of Damage' w l,\\\n" );
    fprintf( pFileW, "     './datFiles/fraginfo.dat' usi 1:2 ti '# Frags' w l\n\n" );

    fclose( pFileW );

    // Prepare Gnuplot data file
    _FragFile = _path+"/datFiles/fraginfo.dat";		//../results
    FILE * pFile;
    pFile = fopen( _FragFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#       time      #frags   DamageSum        Mean      Median         Max         Min");
    fprintf( pFile, "       StDev       Range        Skew    Ex. Kurt.");
    fprintf( pFile, "((R*L^2)/|L|) (Locations)\n");
    fclose( pFile );
}

void PotentialAvenger::plotHisto () {
    // Gnuplot file for fragmentation histogram
    FILE * pFileW;
    std::string histoFile = _path+"/gnuplot/plotHisto.plt";		//../results
    pFileW = fopen( histoFile.c_str(), "w" );
    fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
    fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
    fprintf( pFileW, " -- MH[DCML] (2010)\n");
    fprintf( pFileW, "set title \"Fragment Length CDF Graph\"\n"); 
    fprintf( pFileW, "set xlabel \"Fragment Length, Lf (m)\"\n" );
    fprintf( pFileW, "set ylabel \"# ( Length > Lf )\"\n" );
    if (_numFrag > 0) fprintf( pFileW, "set yrange [0:%u]\n", _numFrag);
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/fraginvcdf.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' usi 1:2 ti '' w l;\n\n" );
    fprintf( pFileW, "set boxwidth 0.9 absolute\n" );
    fprintf( pFileW, "set style fill   solid 1.00 border -1\n" );
    fprintf( pFileW, "set title \"Fragmentation Histogram\"\n"); 
    fprintf( pFileW, "set xlabel \"Size Distribution Relative to Max. Frag. Size (Percent)\"\n" );
    fprintf( pFileW, "set ylabel \"Frequency\"\n" );
    fprintf( pFileW, "set xrange [0:100]\n" );
    fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
    fprintf( pFileW, "set output './pngFiles/fragHisto.svg'\n");
    fprintf( pFileW, "plot './datFiles/fraghisto.dat' using 3:4:(4) ti '' with boxes;\n" );
    fclose( pFileW );

    // Prepare Gnuplot data file
    _HistoFile = _path+"/datFiles/fraghisto.dat";		//../results
    FILE * pFile;
    pFile = fopen( _HistoFile.c_str(), "w" );
    fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#Length, Lf   # With Length > Lf   Bin Center   Frequency\n" );
    fclose( pFile );
}

void PotentialAvenger::plotSTheta () {
	// Gnuplot file for fragmentation histogram
	FILE * pFileW;
	std::string sThetaFile = _path+"/gnuplot/plotSTheta.plt";	//../results/
	pFileW = fopen( sThetaFile.c_str(), "w" );
	fprintf( pFileW, "#!/usr/bin/gnuplot\n" );
	fprintf( pFileW, "# GNUPLOT file generated by <PotentialAvenger.h>");
	fprintf( pFileW, " -- MH[DCML] (2010)\n");
	fprintf( pFileW, "datafile = './datFiles/stresstheta.dat'\n");
	fprintf( pFileW, "stats datafile;\n");
	fprintf( pFileW, "set title \"Cohesive Link Stress vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaCL.svg'\n");
	fprintf( pFileW, "plot for[i=1:1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 4:5 ti 'Link Stress' w l;\n\n" );
	fprintf( pFileW, "set title \"Spring Element Stress vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Stress (MPa)\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800\n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaSE.svg'\n");
	fprintf( pFileW, "plot for[i=1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 2:3 ti 'Spring Stress' w l;\n\n" );
	fprintf( pFileW, "set title \"Cohesive Link Damage vs. Theta Graph\"\n"); 
	fprintf( pFileW, "set xlabel \"Theta (degrees)\"\n" );
	fprintf( pFileW, "set ylabel \"Damage\"\n" );
	fprintf( pFileW, "set xrange [0:360]\n");
	fprintf( pFileW, "set terminal svg size 1200, 800 \n\n" );
	fprintf( pFileW, "set output './pngFiles/stressThetaCLD.svg'\n");
	fprintf( pFileW, "plot for[i=1:STATS_blocks] './datFiles/stresstheta.dat' index i-1 usi 4:6 ti 'Damage' w l;\n\n" );
	fclose( pFileW );

    // Prepare Gnuplot data file
	_SThetaFile = _path+"/datFiles/stresstheta.dat";		//../results

    FILE * pFile;
    pFile = fopen( _SThetaFile.c_str(), "w" );
    	fprintf( pFile, "# GNUPLOT file generated by <ring.h>" );
    fprintf( pFile, " -- MH [DCML] (2010)\n" );
    fprintf( pFile, "# Fragmentation Information\n" );
    fprintf( pFile, "#Time       SprTheta    SprStress   CohTheta    CohStress           i         _Nt\n" );
    fclose( pFile );
}

/*------------------------------ P R I V A T E -------------------------------*/


void PotentialAvenger::printVtk ( const unsigned timStepNum ) const {

    // Build a name for the vtk file
    std::string resuPath = _path+"/vtkFiles/";			//../results
    unsigned zeroNum = 6 - (unsigned) floor( log10( timStepNum ) );
    std::string baseName = "ring_";//+ convertInt(_myid) + "_";
    for ( unsigned i = 0; i < zeroNum; i++ ) {
        baseName += "0";
    }
    baseName += convertInt(timStepNum);
    std::string vtkFile = resuPath + baseName + ".vtk";

    // Print in the vtk file
    printHeader ( vtkFile );
    unsigned Ncell = printMesh ( vtkFile );
    printPointData ( vtkFile );
    printCellData ( vtkFile, Ncell );
}

void PotentialAvenger::printHeader ( const std::string& vtkFile ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "w" );
    fprintf ( pFile, "# vtk DataFile Version 2.0\n" );
    fprintf ( pFile, "Generated by <ring.h> -- MH [DCML] (2010)\n" );
    fprintf ( pFile, "ASCII\nDATASET UNSTRUCTURED_GRID\n\n" );
    fclose( pFile );
}

unsigned PotentialAvenger::printMesh ( const std::string& vtkFile ) const {
    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    fprintf ( pFile, "POINTS %d float\n", Nnod);
    for ( unsigned i = 0; i < Nnod; i++ ) {
        double xx = x[i];			//NodPos
        double y = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", xx, y, 0.0 );
    }

    unsigned Ncell = 0;
    if (visualizeCracks) {
        for ( unsigned i = 0; i < Nelt; i++ ) {
	    	if (d[i] < 1) Ncell++;
    	} 
    } else {
        Ncell = Nelt;
    }

    fprintf ( pFile, "\nCELLS %d %d\n", Ncell, 3*Ncell );
    for ( unsigned i = 0; i < Nelt; i++ ) {
        if (d[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12d %12d %12d\n", 2, i, i+1 );
    }
    fprintf ( pFile, "\nCELL_TYPES %d\n", Ncell );
    for ( unsigned i = 0; i < Nelt; i++ ) {
        if (d[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12d\n", 3 );
    }
    fprintf ( pFile, "\n" );
    fclose( pFile );

    return Ncell;
}

void PotentialAvenger::printPointData ( const std::string& vtkFile ) const {
    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    //int pointData = _NodPos.size();

    fprintf ( pFile, "POINT_DATA %d", Nnod);
    fprintf ( pFile, "\nVECTORS displacements float\n" );
    for ( unsigned i = 0; i < u.size(); i++ ) {
        double dx = printable(u[i]);	//Dis[i][0][0]
        double dy = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", dx, dy, 0.0 );
    }
    fprintf ( pFile, "\nVECTORS velocities float\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) {
        double vx = printable(v[i]);
        double vy = 0.0;
        fprintf ( pFile, " %12.3e %12.3e %12.3e\n", vx, vy, 0.0 );
    }
    fprintf ( pFile, "\n" );

    fprintf ( pFile, "\nSCALARS phiNL float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) fprintf ( pFile, " %12.3e \n", printable(phiNL[i]));
    fprintf ( pFile, "\n" );
    
    fprintf ( pFile, "\nSCALARS inTLSnode int\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < v.size(); i++ ) fprintf ( pFile, " %u \n", inTLSnode[i]);
    fprintf ( pFile, "\n" );
    
    fprintf ( pFile, "\nSCALARS absGradPhiL float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nnod; i++ ) fprintf ( pFile, " %12.3e \n", printable(fabs(gradPhiL[i])));
    fprintf ( pFile, "\n" );
    
    fprintf ( pFile, "\nSCALARS absGradPhiNL float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nnod; i++ ) fprintf ( pFile, " %12.3e \n", printable(fabs(gradPhiNL[i])));
    fprintf ( pFile, "\n" );
    
    fclose( pFile );
}

void PotentialAvenger::printCellData ( const std::string& vtkFile, const unsigned& Ncell ) const {

    FILE * pFile;
    pFile = fopen( vtkFile.c_str(), "a" );
    fprintf( pFile, "CELL_DATA %d", Ncell );

    fprintf ( pFile, "\nSCALARS absGradPhiNLelem float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) fprintf ( pFile, " %12.3e \n", printable(fabs(gradPhiNLelem[i])));
    fprintf ( pFile, "\n" );	

    fprintf ( pFile, "\nSCALARS phiL float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) fprintf ( pFile, " %12.3e \n", printable(phiL[i]));
    fprintf ( pFile, "\n" );
    
    fprintf( pFile, "\nSCALARS stress float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", printable(s[i]));
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS strain float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e\n", printable(e[i]));
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS Yraw/Yc float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", printable(e[i]*e[i]*E*0.5/Yc));
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS Y/Yc float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", printable(Y[i]/Yc));
    fprintf( pFile, "\n" );

    fprintf( pFile, "\nSCALARS Ybar/Yc float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf( pFile, " %12.3e \n", printable(Ybar[i]));
    fprintf( pFile, "\n" );

    fprintf ( pFile, "\nSCALARS damage float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12.3e \n", printable(d[i]));
    fprintf ( pFile, "\n" );

	
    fprintf ( pFile, "\nSCALARS damageRate float\n" );
    fprintf( pFile, "LOOKUP_TABLE default\n" );
    for ( unsigned i = 0; i < Nelt; i++ ) if (d[i] < 1 || visualizeCracks == 0) fprintf ( pFile, " %12.3e \n", printable((d[i] - d_1[i]) / dt));
    fprintf ( pFile, "\n" );

    fprintf( pFile, "\nSCALARS inTLS int\n");
    fprintf( pFile, "LOOKUP_TABLE default\n");
    for ( unsigned i = 0; i < Nelt; i++) if (d[i] < 1 || visualizeCracks == 0) fprintf(pFile, "%u \n", inTLS[i]);
    fprintf( pFile, "\n");

    fclose( pFile );
}

void PotentialAvenger::printGlobalInfo () const {

    if ( _EnrgFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _EnrgFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", t[_Nt] );
        fprintf( pFile, "%12.3e", strain_energy );
        fprintf( pFile, "%12.3e", dissip_energy );
        fprintf( pFile, "%12.3e", ext_energy );
        fprintf( pFile, "%12.3e", kinetic_energy );
	fprintf( pFile, "%12.3e", max_energy * 0.01 );
	fprintf( pFile, "%12.3e", tot_energy );
	fprintf( pFile, "%12.3e", dissip_energy_local );
	fprintf( pFile, "%12.3e", dissip_energy_TLS );
	for (unsigned i = 0; i < phidot[_Nt].size(); ++i) fprintf( pFile, "%12.3e", phidot[_Nt].at(i)/sqrt(E/rho)  );
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::printFrags (const vector<double>& fragLength) {
    double DSum = 0.0;
    for (unsigned i = 0; i < d.size(); ++i) DSum += d[i];

    if ( _FragFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _FragFile.c_str(), "a" );
        fprintf( pFile, "%12.3e", t[_Nt] );
        fprintf( pFile, "%12u", _numFrag );
        fprintf( pFile, "%12.3f", DSum );
        fprintf( pFile, "%12.3e", _fMean );
        fprintf( pFile, "%12.3e", _fMed );
        fprintf( pFile, "%12.3e", _fMax );
	fprintf( pFile, "%12.3e", _fMin );
	fprintf( pFile, "%12.3e", _fStDev );
	fprintf( pFile, "%12.3e", _fRange );
	fprintf( pFile, "%12.3f", _fSkew );
	fprintf( pFile, "%12.3f", _fExKurtosis );
	if (_numFrag <= 10){
	    for (unsigned i = 0; i < fragLength.size(); i++){
		fprintf( pFile, "%12f", fragLength[i] );
	    }
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::printSTheta () {
    if ( _SThetaFile.size() > 0 ) {
        FILE * pFile;
        pFile = fopen( _SThetaFile.c_str(), "a" );
        //fprintf( pFile, "%12.3e", _T );
	for (unsigned i = 0; i < Nelt; i++) {
	    double sprTheta = (double)(360*(i+0.5))/(double)(Nelt);
	    double cohTheta = (double)(360*(i+1))/(double)(Nelt);
	    fprintf( pFile, "%12.3e", t[_Nt] );
	    fprintf( pFile, "%12.3f", sprTheta );
        fprintf( pFile, "%12.3e", s[i] );
        fprintf( pFile, "%12.3f", cohTheta );
//        fprintf( pFile, "%12.3e", _sigCoh[i] );
        fprintf( pFile, "%12.3e", d[i] );
        fprintf( pFile, "%12.3f", (double)(i) );
        fprintf( pFile, "%12.3f", (double)(_Nt) );
	    fprintf( pFile, "\n" );
	}
        fprintf( pFile, "\n" );
	fclose( pFile );
    }
}

void PotentialAvenger::fragmentStats(const vector<double>& fragLength) {

    if (fragLength.size() == 0) return;

	//Initialize statistics of fragment length distribution
	_fMean = 0;
	_fMed = 0;
	_fMax = 0;
	_fMin = 0;
	_fStDev = 0;
	_fRange = 0;
	_fSkew = 0;
	_fExKurtosis = 0;

	//If there are any fragments...
	//Calculate Median
	// Sort the list in ascending order
	vector<double> fragLengthSort = fragLength;
    sort(fragLengthSort.begin(), fragLengthSort.end());

	if (fragLength.size() % 2 == 0) {
        	//If even number, take average of two middle values
		_fMed = ( fragLengthSort[ (unsigned)(fragLengthSort.size() * 0.5) ]
			+ fragLengthSort[ (unsigned)(fragLengthSort.size() * 0.5) -1 ] ) * 0.5;
	} else {
		//If odd number, take middle value
		_fMed = fragLengthSort[ (fragLengthSort.size() - 1) / 2 ];
	}
	//Calculate Max, Min, Range
	_fMax = fragLengthSort.back();
	_fMin = fragLengthSort.front();
	_fRange = _fMax - _fMin;

	//Calculate Mean
	for (unsigned k = 0; k < fragLengthSort.size(); k++){
		//Sum of lengths
		_fMean += fragLength[k];
	}
    //Mean = sum / number
	_fMean = _fMean / _numFrag;

	//Calculate Std. Deviation
	for (unsigned k = 0; k < fragLengthSort.size(); k++){
		//Sum of squared (lengths - means)
		_fStDev += pow( (fragLengthSort[k] - _fMean), 2);
	}
	_fStDev = sqrt( _fStDev / _numFrag ) ;

	//Calculate Skew
	for (unsigned k = 0; k < fragLengthSort.size(); k++){
		//Sum of squared (lengths - means)
		_fSkew += pow( (fragLengthSort[k] - _fMean), 3);
	}
	_fSkew = _fSkew / (_numFrag * pow(_fStDev,3) );

	//Calculate Kurtosis
	for (unsigned k = 0; k < fragLengthSort.size(); k++){
		//Sum of squared (lengths - means)
		_fExKurtosis += pow( (fragLengthSort[k] - _fMean), 4);
	}
	_fExKurtosis = _fExKurtosis / (_numFrag * pow(_fStDev,4) ) - 3.0;
    return;
}


void PotentialAvenger::printHisto(const std::vector<double>& fragLength) {
    // Prints Histogram and scaled 1-cdf figure
    vector<vector<double> > fragInvCDF;
    vector<unsigned> fHisto;
    vector<double> fragLengthSort = fragLength;

    if (_numFrag > 1) {

        sort(fragLengthSort.begin(), fragLengthSort.end());

		fragInvCDF.resize(2);
		fragInvCDF[0].resize(1000);	//a length, from zero to the max. fragment size
		fragInvCDF[1].resize(1000);	//number of fragments larger than this length
		fHisto.assign(25, 0);		//number of bins for the fragment histogram
	
		//Histogram - 25 bins
		 double max = _fMax;	//size
		//Step through fragment length list; increase count in the bin if fragment fits
		for (unsigned k = 0; k < fragLengthSort.size(); k++){
            double length = fragLengthSort[k];
//            if (fragment_list.size() % 2 == 1) length *= 2; //if not broken from wall, this segment has twice the length
			if (length < max * 0.04) fHisto[0]++;
			if ((length < max * 0.08) && (length >= max * 0.04)) fHisto[1]++;
			if ((length < max * 0.12) && (length >= max * 0.08)) fHisto[2]++;
			if ((length < max * 0.16) && (length >= max * 0.12)) fHisto[3]++;
			if ((length < max * 0.20) && (length >= max * 0.16)) fHisto[4]++;
			if ((length < max * 0.24) && (length >= max * 0.20)) fHisto[5]++;
			if ((length < max * 0.28) && (length >= max * 0.24)) fHisto[6]++;
			if ((length < max * 0.32) && (length >= max * 0.28)) fHisto[7]++;
			if ((length < max * 0.36) && (length >= max * 0.32)) fHisto[8]++;
			if ((length < max * 0.40) && (length >= max * 0.36)) fHisto[9]++;
			if ((length < max * 0.44) && (length >= max * 0.40)) fHisto[10]++;
			if ((length < max * 0.48) && (length >= max * 0.44)) fHisto[11]++;
			if ((length < max * 0.52) && (length >= max * 0.48)) fHisto[12]++;
			if ((length < max * 0.56) && (length >= max * 0.52)) fHisto[13]++;
			if ((length < max * 0.60) && (length >= max * 0.56)) fHisto[14]++;
			if ((length < max * 0.64) && (length >= max * 0.60)) fHisto[15]++;
			if ((length < max * 0.68) && (length >= max * 0.64)) fHisto[16]++;
			if ((length < max * 0.72) && (length >= max * 0.68)) fHisto[17]++;
			if ((length < max * 0.76) && (length >= max * 0.72)) fHisto[18]++;
			if ((length < max * 0.80) && (length >= max * 0.76)) fHisto[19]++;
			if ((length < max * 0.84) && (length >= max * 0.80)) fHisto[20]++;
			if ((length < max * 0.88) && (length >= max * 0.84)) fHisto[21]++;
			if ((length < max * 0.92) && (length >= max * 0.88)) fHisto[22]++;
			if ((length < max * 0.96) && (length >= max * 0.92)) fHisto[23]++;
			if ((length <= max) && (length >= max * 0.96)) fHisto[24]++;
		}

		//Open file to record histogram and 1-cdf data
		if ( _HistoFile.size() > 0 ) {
			FILE * pFile;
			pFile = fopen( _HistoFile.c_str(), "a" );
			double j = 0;
			for (unsigned i = 0; i < 1000; i++) {

				//grab the 1-cdf data; 
				unsigned count = 0;
				j = max * (static_cast<double>(i) / 1000.0);	//from 0 to max length, 1000 increments
				for (unsigned k = 0; k < fragLengthSort.size(); k++) {
                    double length = fragLengthSort[k];
					if (length > j) {		//if frag length greater than j, add to count
						count += 1;
					}
				}
		
				//save to vector
				fragInvCDF[0][i] = j;
				fragInvCDF[1][i] = (double)count;
				fprintf( pFile, "%6.3e %u", j, count);		//print to file

				//print histogram info to file - relative size (% of max frag length) & count
				if (i < 25) {	//piggybacking the for loop, only need the first 25
					fprintf( pFile, " %f %u", (double)(i*4+2), fHisto[i] );
				} else {
					fprintf( pFile, " 0 0");
				}
				fprintf( pFile, "\n" );
			}

			//print raw fragment sizes to file
			fprintf( pFile, "# Sizes: \n" );
			for (unsigned k = 0; k < fragLength.size(); k++){
                double length = fragLength[k];
				fprintf( pFile, "%12.3e \n", length );
			}

			fclose( pFile );
		}
    }
    return;
}


void PotentialAvenger::printClean () const {
    std::string cleanPath = _path+"/clean.sh";
    FILE * pFile;
    pFile = fopen( cleanPath.c_str(), "w" );
    fprintf( pFile, "#!/bin/bash\n\n" );
    fprintf( pFile, "# Go to results directory\n" );
    fprintf( pFile, "cd %s\n\n", _path.c_str() );
    fprintf( pFile, "# Remove the data files\n" );
    fprintf( pFile, "cd ./datFiles/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "cd ./automatedRuns/; rm *.dat; cd -\n\n" );
    fprintf( pFile, "# Remove the gnuplot files\n" );
    fprintf( pFile, "cd ./gnuplot/ ; rm *.plt; cd -\n\n" );
    fprintf( pFile, "# Remove the png/svg files\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.png; cd -\n\n" );
    fprintf( pFile, "cd ./pngFiles/; rm *.svg; cd -\n\n" );
    fprintf( pFile, "# Remove the vtk files\n" );
    fprintf( pFile, "cd ./vtkFiles/; find . -name \"*.vtk\" -print0 | xargs -0 rm -f; cd -\n\n" );
    fprintf( pFile, "# Remove plot.sh\n" );
    fprintf( pFile, "rm plot.sh\n" );
    fclose( pFile );
    std::string shellCmd = "chmod u+x " + cleanPath;
    //int status = system( shellCmd.c_str() );
	system( shellCmd.c_str() );

    shellCmd = "./" + cleanPath;
	system( shellCmd.c_str() );

}

